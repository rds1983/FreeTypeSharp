// Generated by Sichem at 2/24/2021 2:58:41 AM

using System;
using System.Runtime.InteropServices;

namespace FreeTypeSharp
{
	unsafe partial class FreeType
	{
		public const int FT_PIXEL_MODE_NONE = 0;
		public const int FT_PIXEL_MODE_MONO = 1;
		public const int FT_PIXEL_MODE_GRAY = 2;
		public const int FT_PIXEL_MODE_GRAY2 = 3;
		public const int FT_PIXEL_MODE_GRAY4 = 4;
		public const int FT_PIXEL_MODE_LCD = 5;
		public const int FT_PIXEL_MODE_LCD_V = 6;
		public const int FT_PIXEL_MODE_BGRA = 7;
		public const int FT_PIXEL_MODE_MAX = 8;
		public const int FT_GLYPH_FORMAT_NONE = ((0 << 24) | (0 << 16) | (0 << 8) | 0);
		public const int FT_GLYPH_FORMAT_COMPOSITE = (('c' << 24) | ('o' << 16) | ('m' << 8) | 'p');
		public const int FT_GLYPH_FORMAT_BITMAP = (('b' << 24) | ('i' << 16) | ('t' << 8) | 's');
		public const int FT_GLYPH_FORMAT_OUTLINE = (('o' << 24) | ('u' << 16) | ('t' << 8) | 'l');
		public const int FT_GLYPH_FORMAT_PLOTTER = (('p' << 24) | ('l' << 16) | ('o' << 8) | 't');
		public const int FT_Mod_Err_Base = 0;
		public const int FT_Mod_Err_Autofit = 0;
		public const int FT_Mod_Err_BDF = 0;
		public const int FT_Mod_Err_Bzip2 = 0;
		public const int FT_Mod_Err_Cache = 0;
		public const int FT_Mod_Err_CFF = 0;
		public const int FT_Mod_Err_CID = 0;
		public const int FT_Mod_Err_Gzip = 0;
		public const int FT_Mod_Err_LZW = 0;
		public const int FT_Mod_Err_OTvalid = 0;
		public const int FT_Mod_Err_PCF = 0;
		public const int FT_Mod_Err_PFR = 0;
		public const int FT_Mod_Err_PSaux = 0;
		public const int FT_Mod_Err_PShinter = 0;
		public const int FT_Mod_Err_PSnames = 0;
		public const int FT_Mod_Err_Raster = 0;
		public const int FT_Mod_Err_SFNT = 0;
		public const int FT_Mod_Err_Smooth = 0;
		public const int FT_Mod_Err_TrueType = 0;
		public const int FT_Mod_Err_Type1 = 0;
		public const int FT_Mod_Err_Type42 = 0;
		public const int FT_Mod_Err_Winfonts = 0;
		public const int FT_Mod_Err_GXvalid = 0;
		public const int FT_Mod_Err_Max = 1;
		public const int FT_Err_Ok = 0x00;
		public const int FT_Err_Cannot_Open_Resource = 0x01 + 0;
		public const int FT_Err_Unknown_File_Format = 0x02 + 0;
		public const int FT_Err_Invalid_File_Format = 0x03 + 0;
		public const int FT_Err_Invalid_Version = 0x04 + 0;
		public const int FT_Err_Lower_Module_Version = 0x05 + 0;
		public const int FT_Err_Invalid_Argument = 0x06 + 0;
		public const int FT_Err_Unimplemented_Feature = 0x07 + 0;
		public const int FT_Err_Invalid_Table = 0x08 + 0;
		public const int FT_Err_Invalid_Offset = 0x09 + 0;
		public const int FT_Err_Array_Too_Large = 0x0A + 0;
		public const int FT_Err_Missing_Module = 0x0B + 0;
		public const int FT_Err_Missing_Property = 0x0C + 0;
		public const int FT_Err_Invalid_Glyph_Index = 0x10 + 0;
		public const int FT_Err_Invalid_Character_Code = 0x11 + 0;
		public const int FT_Err_Invalid_Glyph_Format = 0x12 + 0;
		public const int FT_Err_Cannot_Render_Glyph = 0x13 + 0;
		public const int FT_Err_Invalid_Outline = 0x14 + 0;
		public const int FT_Err_Invalid_Composite = 0x15 + 0;
		public const int FT_Err_Too_Many_Hints = 0x16 + 0;
		public const int FT_Err_Invalid_Pixel_Size = 0x17 + 0;
		public const int FT_Err_Invalid_Handle = 0x20 + 0;
		public const int FT_Err_Invalid_Library_Handle = 0x21 + 0;
		public const int FT_Err_Invalid_Driver_Handle = 0x22 + 0;
		public const int FT_Err_Invalid_Face_Handle = 0x23 + 0;
		public const int FT_Err_Invalid_Size_Handle = 0x24 + 0;
		public const int FT_Err_Invalid_Slot_Handle = 0x25 + 0;
		public const int FT_Err_Invalid_CharMap_Handle = 0x26 + 0;
		public const int FT_Err_Invalid_Cache_Handle = 0x27 + 0;
		public const int FT_Err_Invalid_Stream_Handle = 0x28 + 0;
		public const int FT_Err_Too_Many_Drivers = 0x30 + 0;
		public const int FT_Err_Too_Many_Extensions = 0x31 + 0;
		public const int FT_Err_Out_Of_Memory = 0x40 + 0;
		public const int FT_Err_Unlisted_Object = 0x41 + 0;
		public const int FT_Err_Cannot_Open_Stream = 0x51 + 0;
		public const int FT_Err_Invalid_Stream_Seek = 0x52 + 0;
		public const int FT_Err_Invalid_Stream_Skip = 0x53 + 0;
		public const int FT_Err_Invalid_Stream_Read = 0x54 + 0;
		public const int FT_Err_Invalid_Stream_Operation = 0x55 + 0;
		public const int FT_Err_Invalid_Frame_Operation = 0x56 + 0;
		public const int FT_Err_Nested_Frame_Access = 0x57 + 0;
		public const int FT_Err_Invalid_Frame_Read = 0x58 + 0;
		public const int FT_Err_Raster_Uninitialized = 0x60 + 0;
		public const int FT_Err_Raster_Corrupted = 0x61 + 0;
		public const int FT_Err_Raster_Overflow = 0x62 + 0;
		public const int FT_Err_Raster_Negative_Height = 0x63 + 0;
		public const int FT_Err_Too_Many_Caches = 0x70 + 0;
		public const int FT_Err_Invalid_Opcode = 0x80 + 0;
		public const int FT_Err_Too_Few_Arguments = 0x81 + 0;
		public const int FT_Err_Stack_Overflow = 0x82 + 0;
		public const int FT_Err_Code_Overflow = 0x83 + 0;
		public const int FT_Err_Bad_Argument = 0x84 + 0;
		public const int FT_Err_Divide_By_Zero = 0x85 + 0;
		public const int FT_Err_Invalid_Reference = 0x86 + 0;
		public const int FT_Err_Debug_OpCode = 0x87 + 0;
		public const int FT_Err_ENDF_In_Exec_Stream = 0x88 + 0;
		public const int FT_Err_Nested_DEFS = 0x89 + 0;
		public const int FT_Err_Invalid_CodeRange = 0x8A + 0;
		public const int FT_Err_Execution_Too_Long = 0x8B + 0;
		public const int FT_Err_Too_Many_Function_Defs = 0x8C + 0;
		public const int FT_Err_Too_Many_Instruction_Defs = 0x8D + 0;
		public const int FT_Err_Table_Missing = 0x8E + 0;
		public const int FT_Err_Horiz_Header_Missing = 0x8F + 0;
		public const int FT_Err_Locations_Missing = 0x90 + 0;
		public const int FT_Err_Name_Table_Missing = 0x91 + 0;
		public const int FT_Err_CMap_Table_Missing = 0x92 + 0;
		public const int FT_Err_Hmtx_Table_Missing = 0x93 + 0;
		public const int FT_Err_Post_Table_Missing = 0x94 + 0;
		public const int FT_Err_Invalid_Horiz_Metrics = 0x95 + 0;
		public const int FT_Err_Invalid_CharMap_Format = 0x96 + 0;
		public const int FT_Err_Invalid_PPem = 0x97 + 0;
		public const int FT_Err_Invalid_Vert_Metrics = 0x98 + 0;
		public const int FT_Err_Could_Not_Find_Context = 0x99 + 0;
		public const int FT_Err_Invalid_Post_Table_Format = 0x9A + 0;
		public const int FT_Err_Invalid_Post_Table = 0x9B + 0;
		public const int FT_Err_DEF_In_Glyf_Bytecode = 0x9C + 0;
		public const int FT_Err_Missing_Bitmap = 0x9D + 0;
		public const int FT_Err_Syntax_Error = 0xA0 + 0;
		public const int FT_Err_Stack_Underflow = 0xA1 + 0;
		public const int FT_Err_Ignore = 0xA2 + 0;
		public const int FT_Err_No_Unicode_Glyph_Name = 0xA3 + 0;
		public const int FT_Err_Glyph_Too_Big = 0xA4 + 0;
		public const int FT_Err_Missing_Startfont_Field = 0xB0 + 0;
		public const int FT_Err_Missing_Font_Field = 0xB1 + 0;
		public const int FT_Err_Missing_Size_Field = 0xB2 + 0;
		public const int FT_Err_Missing_Fontboundingbox_Field = 0xB3 + 0;
		public const int FT_Err_Missing_Chars_Field = 0xB4 + 0;
		public const int FT_Err_Missing_Startchar_Field = 0xB5 + 0;
		public const int FT_Err_Missing_Encoding_Field = 0xB6 + 0;
		public const int FT_Err_Missing_Bbx_Field = 0xB7 + 0;
		public const int FT_Err_Bbx_Too_Big = 0xB8 + 0;
		public const int FT_Err_Corrupted_Font_Header = 0xB9 + 0;
		public const int FT_Err_Corrupted_Font_Glyphs = 0xBA + 0;
		public const int FT_Err_Max = 93;
		public const int FT_SIZE_REQUEST_TYPE_NOMINAL = 0;
		public const int FT_SIZE_REQUEST_TYPE_REAL_DIM = 1;
		public const int FT_SIZE_REQUEST_TYPE_BBOX = 2;
		public const int FT_SIZE_REQUEST_TYPE_CELL = 3;
		public const int FT_SIZE_REQUEST_TYPE_SCALES = 4;
		public const int FT_SIZE_REQUEST_TYPE_MAX = 5;
		public const int FT_RENDER_MODE_NORMAL = 0;
		public const int FT_RENDER_MODE_LIGHT = 1;
		public const int FT_RENDER_MODE_MONO = 2;
		public const int FT_RENDER_MODE_LCD = 3;
		public const int FT_RENDER_MODE_LCD_V = 4;
		public const int FT_RENDER_MODE_MAX = 5;
		public const int FT_KERNING_DEFAULT = 0;
		public const int FT_KERNING_UNFITTED = 1;
		public const int FT_KERNING_UNSCALED = 2;
		public const int FT_TRUETYPE_ENGINE_TYPE_NONE = 0;
		public const int FT_TRUETYPE_ENGINE_TYPE_UNPATENTED = 1;
		public const int FT_TRUETYPE_ENGINE_TYPE_PATENTED = 2;
		public const int FT_GLYPH_BBOX_UNSCALED = 0;
		public const int FT_GLYPH_BBOX_SUBPIXELS = 0;
		public const int FT_GLYPH_BBOX_GRIDFIT = 1;
		public const int FT_GLYPH_BBOX_TRUNCATE = 2;
		public const int FT_GLYPH_BBOX_PIXELS = 3;
		public const int FT_LCD_FILTER_NONE = 0;
		public const int FT_LCD_FILTER_DEFAULT = 1;
		public const int FT_LCD_FILTER_LIGHT = 2;
		public const int FT_LCD_FILTER_LEGACY1 = 3;
		public const int FT_LCD_FILTER_LEGACY = 16;
		public const int FT_LCD_FILTER_MAX = 17;
		public const int FT_SFNT_HEAD = 0;
		public const int FT_SFNT_MAXP = 1;
		public const int FT_SFNT_OS2 = 2;
		public const int FT_SFNT_HHEA = 3;
		public const int FT_SFNT_VHEA = 4;
		public const int FT_SFNT_POST = 5;
		public const int FT_SFNT_PCLT = 6;
		public const int FT_SFNT_MAX = 7;
		public const int T1_BLEND_UNDERLINE_POSITION = 0;
		public const int T1_BLEND_UNDERLINE_THICKNESS = 1;
		public const int T1_BLEND_ITALIC_ANGLE = 2;
		public const int T1_BLEND_BLUE_VALUES = 3;
		public const int T1_BLEND_OTHER_BLUES = 4;
		public const int T1_BLEND_STANDARD_WIDTH = 5;
		public const int T1_BLEND_STANDARD_HEIGHT = 6;
		public const int T1_BLEND_STEM_SNAP_WIDTHS = 7;
		public const int T1_BLEND_STEM_SNAP_HEIGHTS = 8;
		public const int T1_BLEND_BLUE_SCALE = 9;
		public const int T1_BLEND_BLUE_SHIFT = 10;
		public const int T1_BLEND_FAMILY_BLUES = 11;
		public const int T1_BLEND_FAMILY_OTHER_BLUES = 12;
		public const int T1_BLEND_FORCE_BOLD = 13;
		public const int T1_BLEND_MAX = 14;
		public const int T1_ENCODING_TYPE_NONE = 0;
		public const int T1_ENCODING_TYPE_ARRAY = 1;
		public const int T1_ENCODING_TYPE_STANDARD = 2;
		public const int T1_ENCODING_TYPE_ISOLATIN1 = 3;
		public const int T1_ENCODING_TYPE_EXPERT = 4;
		public const int PS_DICT_FONT_TYPE = 0;
		public const int PS_DICT_FONT_MATRIX = 1;
		public const int PS_DICT_FONT_BBOX = 2;
		public const int PS_DICT_PAINT_TYPE = 3;
		public const int PS_DICT_FONT_NAME = 4;
		public const int PS_DICT_UNIQUE_ID = 5;
		public const int PS_DICT_NUM_CHAR_STRINGS = 6;
		public const int PS_DICT_CHAR_STRING_KEY = 7;
		public const int PS_DICT_CHAR_STRING = 8;
		public const int PS_DICT_ENCODING_TYPE = 9;
		public const int PS_DICT_ENCODING_ENTRY = 10;
		public const int PS_DICT_NUM_SUBRS = 11;
		public const int PS_DICT_SUBR = 12;
		public const int PS_DICT_STD_HW = 13;
		public const int PS_DICT_STD_VW = 14;
		public const int PS_DICT_NUM_BLUE_VALUES = 15;
		public const int PS_DICT_BLUE_VALUE = 16;
		public const int PS_DICT_BLUE_FUZZ = 17;
		public const int PS_DICT_NUM_OTHER_BLUES = 18;
		public const int PS_DICT_OTHER_BLUE = 19;
		public const int PS_DICT_NUM_FAMILY_BLUES = 20;
		public const int PS_DICT_FAMILY_BLUE = 21;
		public const int PS_DICT_NUM_FAMILY_OTHER_BLUES = 22;
		public const int PS_DICT_FAMILY_OTHER_BLUE = 23;
		public const int PS_DICT_BLUE_SCALE = 24;
		public const int PS_DICT_BLUE_SHIFT = 25;
		public const int PS_DICT_NUM_STEM_SNAP_H = 26;
		public const int PS_DICT_STEM_SNAP_H = 27;
		public const int PS_DICT_NUM_STEM_SNAP_V = 28;
		public const int PS_DICT_STEM_SNAP_V = 29;
		public const int PS_DICT_FORCE_BOLD = 30;
		public const int PS_DICT_RND_STEM_UP = 31;
		public const int PS_DICT_MIN_FEATURE = 32;
		public const int PS_DICT_LEN_IV = 33;
		public const int PS_DICT_PASSWORD = 34;
		public const int PS_DICT_LANGUAGE_GROUP = 35;
		public const int PS_DICT_VERSION = 36;
		public const int PS_DICT_NOTICE = 37;
		public const int PS_DICT_FULL_NAME = 38;
		public const int PS_DICT_FAMILY_NAME = 39;
		public const int PS_DICT_WEIGHT = 40;
		public const int PS_DICT_IS_FIXED_PITCH = 41;
		public const int PS_DICT_UNDERLINE_POSITION = 42;
		public const int PS_DICT_UNDERLINE_THICKNESS = 43;
		public const int PS_DICT_FS_TYPE = 44;
		public const int PS_DICT_ITALIC_ANGLE = 45;
		public const int PS_DICT_MAX = PS_DICT_ITALIC_ANGLE;
		public const int TT_SBIT_TABLE_TYPE_NONE = 0;
		public const int TT_SBIT_TABLE_TYPE_EBLC = 1;
		public const int TT_SBIT_TABLE_TYPE_CBLC = 2;
		public const int TT_SBIT_TABLE_TYPE_SBIX = 3;
		public const int TT_SBIT_TABLE_TYPE_MAX = 4;
		public const int ft_frame_end = 0;
		public const int ft_frame_start = ((1 << 2) | (0 << 1) | 0);
		public const int ft_frame_byte = ((2 << 2) | (0 << 1) | 0);
		public const int ft_frame_schar = ((2 << 2) | (0 << 1) | 1);
		public const int ft_frame_ushort_be = ((3 << 2) | (0 << 1) | 0);
		public const int ft_frame_short_be = ((3 << 2) | (0 << 1) | 1);
		public const int ft_frame_ushort_le = ((3 << 2) | (1 << 1) | 0);
		public const int ft_frame_short_le = ((3 << 2) | (1 << 1) | 1);
		public const int ft_frame_ulong_be = ((4 << 2) | (0 << 1) | 0);
		public const int ft_frame_long_be = ((4 << 2) | (0 << 1) | 1);
		public const int ft_frame_ulong_le = ((4 << 2) | (1 << 1) | 0);
		public const int ft_frame_long_le = ((4 << 2) | (1 << 1) | 1);
		public const int ft_frame_uoff3_be = ((5 << 2) | (0 << 1) | 0);
		public const int ft_frame_off3_be = ((5 << 2) | (0 << 1) | 1);
		public const int ft_frame_uoff3_le = ((5 << 2) | (1 << 1) | 0);
		public const int ft_frame_off3_le = ((5 << 2) | (1 << 1) | 1);
		public const int ft_frame_bytes = ((6 << 2) | (0 << 1) | 0);
		public const int ft_frame_skip = ((6 << 2) | (0 << 1) | 1);
		public const int FT_ORIENTATION_TRUETYPE = 0;
		public const int FT_ORIENTATION_POSTSCRIPT = 1;
		public const int FT_ORIENTATION_FILL_RIGHT = FT_ORIENTATION_TRUETYPE;
		public const int FT_ORIENTATION_FILL_LEFT = FT_ORIENTATION_POSTSCRIPT;
		public const int FT_ORIENTATION_NONE = 4;
		public const int FT_VALIDATE_DEFAULT = 0;
		public const int FT_VALIDATE_TIGHT = 1;
		public const int FT_VALIDATE_PARANOID = 2;
		public const int FT_RFork_Rule_invalid = -2;
		public const int FT_RFork_Rule_uknown = -1;
		public const int FT_RFork_Rule_apple_double = 0;
		public const int FT_RFork_Rule_apple_single = 1;
		public const int FT_RFork_Rule_darwin_ufs_export = 2;
		public const int FT_RFork_Rule_darwin_newvfs = 3;
		public const int FT_RFork_Rule_darwin_hfsplus = 4;
		public const int FT_RFork_Rule_vfat = 5;
		public const int FT_RFork_Rule_linux_cap = 6;
		public const int FT_RFork_Rule_linux_double = 7;
		public const int FT_RFork_Rule_linux_netatalk = 8;
		public const int T1_TOKEN_TYPE_NONE = 0;
		public const int T1_TOKEN_TYPE_ANY = 1;
		public const int T1_TOKEN_TYPE_STRING = 2;
		public const int T1_TOKEN_TYPE_ARRAY = 3;
		public const int T1_TOKEN_TYPE_KEY = 4;
		public const int T1_TOKEN_TYPE_MAX = 5;
		public const int T1_FIELD_TYPE_NONE = 0;
		public const int T1_FIELD_TYPE_BOOL = 1;
		public const int T1_FIELD_TYPE_INTEGER = 2;
		public const int T1_FIELD_TYPE_FIXED = 3;
		public const int T1_FIELD_TYPE_FIXED_1000 = 4;
		public const int T1_FIELD_TYPE_STRING = 5;
		public const int T1_FIELD_TYPE_KEY = 6;
		public const int T1_FIELD_TYPE_BBOX = 7;
		public const int T1_FIELD_TYPE_MM_BBOX = 8;
		public const int T1_FIELD_TYPE_INTEGER_ARRAY = 9;
		public const int T1_FIELD_TYPE_FIXED_ARRAY = 10;
		public const int T1_FIELD_TYPE_CALLBACK = 11;
		public const int T1_FIELD_TYPE_MAX = 12;
		public const int T1_FIELD_LOCATION_CID_INFO = 0;
		public const int T1_FIELD_LOCATION_FONT_DICT = 1;
		public const int T1_FIELD_LOCATION_FONT_EXTRA = 2;
		public const int T1_FIELD_LOCATION_FONT_INFO = 3;
		public const int T1_FIELD_LOCATION_PRIVATE = 4;
		public const int T1_FIELD_LOCATION_BBOX = 5;
		public const int T1_FIELD_LOCATION_LOADER = 6;
		public const int T1_FIELD_LOCATION_FACE = 7;
		public const int T1_FIELD_LOCATION_BLEND = 8;
		public const int T1_FIELD_LOCATION_MAX = 9;
		public const int T1_Parse_Start = 0;
		public const int T1_Parse_Have_Width = 1;
		public const int T1_Parse_Have_Moveto = 2;
		public const int T1_Parse_Have_Path = 3;
		public static readonly FT_Raster_Funcs_ ft_default_raster = new FT_Raster_Funcs_();
		public static readonly FT_Palette_Data_ null_palette_data = (FT_Palette_Data_)(new FT_Palette_Data_ { num_palettes = 0, palette_name_ids = null, palette_flags = null, num_palette_entries = 0, palette_entry_name_ids = null });
		public static readonly FT_Glyph_Class_ ft_bitmap_glyph_class = new FT_Glyph_Class_();
		public static readonly FT_Glyph_Class_ ft_outline_glyph_class = new FT_Glyph_Class_();
		public static readonly FT_Outline_ null_outline = (FT_Outline_)(new FT_Outline_ { n_contours = 0, n_points = 0, points = null, tags = null, contours = null, flags = 0 });
		public static readonly ft_raccess_guess_rec_[] ft_raccess_guess_table = { new ft_raccess_guess_rec_ { func = raccess_guess_apple_double, type = FT_RFork_Rule_apple_double }, new ft_raccess_guess_rec_ { func = raccess_guess_apple_single, type = FT_RFork_Rule_apple_single }, new ft_raccess_guess_rec_ { func = raccess_guess_darwin_ufs_export, type = FT_RFork_Rule_darwin_ufs_export }, new ft_raccess_guess_rec_ { func = raccess_guess_darwin_newvfs, type = FT_RFork_Rule_darwin_newvfs }, new ft_raccess_guess_rec_ { func = raccess_guess_darwin_hfsplus, type = FT_RFork_Rule_darwin_hfsplus }, new ft_raccess_guess_rec_ { func = raccess_guess_vfat, type = FT_RFork_Rule_vfat }, new ft_raccess_guess_rec_ { func = raccess_guess_linux_cap, type = FT_RFork_Rule_linux_cap }, new ft_raccess_guess_rec_ { func = raccess_guess_linux_double, type = FT_RFork_Rule_linux_double }, new ft_raccess_guess_rec_ { func = raccess_guess_linux_netatalk, type = FT_RFork_Rule_linux_netatalk } };
		public static readonly int[] ft_trig_arctan_table = { 1740967, 919879, 466945, 234379, 117304, 58666, 29335, 14668, 7334, 3667, 1833, 917, 458, 229, 115, 57, 29, 14, 7, 4, 2, 1 };
		public enum FT_Pixel_Mode_
		{
			FT_PIXEL_MODE_NONE = 0,
			FT_PIXEL_MODE_MONO,
			FT_PIXEL_MODE_GRAY,
			FT_PIXEL_MODE_GRAY2,
			FT_PIXEL_MODE_GRAY4,
			FT_PIXEL_MODE_LCD,
			FT_PIXEL_MODE_LCD_V,
			FT_PIXEL_MODE_BGRA,
			FT_PIXEL_MODE_MAX
		}

		public enum FT_Glyph_Format_
		{
			FT_GLYPH_FORMAT_NONE = ((0 << 24) | (0 << 16) | (0 << 8) | 0),
			FT_GLYPH_FORMAT_COMPOSITE = (('c' << 24) | ('o' << 16) | ('m' << 8) | 'p'),
			FT_GLYPH_FORMAT_BITMAP = (('b' << 24) | ('i' << 16) | ('t' << 8) | 's'),
			FT_GLYPH_FORMAT_OUTLINE = (('o' << 24) | ('u' << 16) | ('t' << 8) | 'l'),
			FT_GLYPH_FORMAT_PLOTTER = (('p' << 24) | ('l' << 16) | ('o' << 8) | 't')
		}

		public enum FT_Size_Request_Type_
		{
			FT_SIZE_REQUEST_TYPE_NOMINAL,
			FT_SIZE_REQUEST_TYPE_REAL_DIM,
			FT_SIZE_REQUEST_TYPE_BBOX,
			FT_SIZE_REQUEST_TYPE_CELL,
			FT_SIZE_REQUEST_TYPE_SCALES,
			FT_SIZE_REQUEST_TYPE_MAX
		}

		public enum FT_Render_Mode_
		{
			FT_RENDER_MODE_NORMAL = 0,
			FT_RENDER_MODE_LIGHT,
			FT_RENDER_MODE_MONO,
			FT_RENDER_MODE_LCD,
			FT_RENDER_MODE_LCD_V,
			FT_RENDER_MODE_MAX
		}

		public enum FT_Kerning_Mode_
		{
			FT_KERNING_DEFAULT = 0,
			FT_KERNING_UNFITTED,
			FT_KERNING_UNSCALED
		}

		public enum FT_TrueTypeEngineType_
		{
			FT_TRUETYPE_ENGINE_TYPE_NONE = 0,
			FT_TRUETYPE_ENGINE_TYPE_UNPATENTED,
			FT_TRUETYPE_ENGINE_TYPE_PATENTED
		}

		public enum FT_Glyph_BBox_Mode_
		{
			FT_GLYPH_BBOX_UNSCALED = 0,
			FT_GLYPH_BBOX_SUBPIXELS = 0,
			FT_GLYPH_BBOX_GRIDFIT = 1,
			FT_GLYPH_BBOX_TRUNCATE = 2,
			FT_GLYPH_BBOX_PIXELS = 3
		}

		public enum FT_LcdFilter_
		{
			FT_LCD_FILTER_NONE = 0,
			FT_LCD_FILTER_DEFAULT = 1,
			FT_LCD_FILTER_LIGHT = 2,
			FT_LCD_FILTER_LEGACY1 = 3,
			FT_LCD_FILTER_LEGACY = 16,
			FT_LCD_FILTER_MAX
		}

		public enum FT_Sfnt_Tag_
		{
			FT_SFNT_HEAD,
			FT_SFNT_MAXP,
			FT_SFNT_OS2,
			FT_SFNT_HHEA,
			FT_SFNT_VHEA,
			FT_SFNT_POST,
			FT_SFNT_PCLT,
			FT_SFNT_MAX
		}

		public enum T1_Blend_Flags_
		{
			T1_BLEND_UNDERLINE_POSITION = 0,
			T1_BLEND_UNDERLINE_THICKNESS,
			T1_BLEND_ITALIC_ANGLE,
			T1_BLEND_BLUE_VALUES,
			T1_BLEND_OTHER_BLUES,
			T1_BLEND_STANDARD_WIDTH,
			T1_BLEND_STANDARD_HEIGHT,
			T1_BLEND_STEM_SNAP_WIDTHS,
			T1_BLEND_STEM_SNAP_HEIGHTS,
			T1_BLEND_BLUE_SCALE,
			T1_BLEND_BLUE_SHIFT,
			T1_BLEND_FAMILY_BLUES,
			T1_BLEND_FAMILY_OTHER_BLUES,
			T1_BLEND_FORCE_BOLD,
			T1_BLEND_MAX
		}

		public enum T1_EncodingType_
		{
			T1_ENCODING_TYPE_NONE = 0,
			T1_ENCODING_TYPE_ARRAY,
			T1_ENCODING_TYPE_STANDARD,
			T1_ENCODING_TYPE_ISOLATIN1,
			T1_ENCODING_TYPE_EXPERT
		}

		public enum PS_Dict_Keys_
		{
			PS_DICT_FONT_TYPE,
			PS_DICT_FONT_MATRIX,
			PS_DICT_FONT_BBOX,
			PS_DICT_PAINT_TYPE,
			PS_DICT_FONT_NAME,
			PS_DICT_UNIQUE_ID,
			PS_DICT_NUM_CHAR_STRINGS,
			PS_DICT_CHAR_STRING_KEY,
			PS_DICT_CHAR_STRING,
			PS_DICT_ENCODING_TYPE,
			PS_DICT_ENCODING_ENTRY,
			PS_DICT_NUM_SUBRS,
			PS_DICT_SUBR,
			PS_DICT_STD_HW,
			PS_DICT_STD_VW,
			PS_DICT_NUM_BLUE_VALUES,
			PS_DICT_BLUE_VALUE,
			PS_DICT_BLUE_FUZZ,
			PS_DICT_NUM_OTHER_BLUES,
			PS_DICT_OTHER_BLUE,
			PS_DICT_NUM_FAMILY_BLUES,
			PS_DICT_FAMILY_BLUE,
			PS_DICT_NUM_FAMILY_OTHER_BLUES,
			PS_DICT_FAMILY_OTHER_BLUE,
			PS_DICT_BLUE_SCALE,
			PS_DICT_BLUE_SHIFT,
			PS_DICT_NUM_STEM_SNAP_H,
			PS_DICT_STEM_SNAP_H,
			PS_DICT_NUM_STEM_SNAP_V,
			PS_DICT_STEM_SNAP_V,
			PS_DICT_FORCE_BOLD,
			PS_DICT_RND_STEM_UP,
			PS_DICT_MIN_FEATURE,
			PS_DICT_LEN_IV,
			PS_DICT_PASSWORD,
			PS_DICT_LANGUAGE_GROUP,
			PS_DICT_VERSION,
			PS_DICT_NOTICE,
			PS_DICT_FULL_NAME,
			PS_DICT_FAMILY_NAME,
			PS_DICT_WEIGHT,
			PS_DICT_IS_FIXED_PITCH,
			PS_DICT_UNDERLINE_POSITION,
			PS_DICT_UNDERLINE_THICKNESS,
			PS_DICT_FS_TYPE,
			PS_DICT_ITALIC_ANGLE,
			PS_DICT_MAX = PS_DICT_ITALIC_ANGLE
		}

		public enum TT_SbitTableType_
		{
			TT_SBIT_TABLE_TYPE_NONE = 0,
			TT_SBIT_TABLE_TYPE_EBLC,
			TT_SBIT_TABLE_TYPE_CBLC,
			TT_SBIT_TABLE_TYPE_SBIX,
			TT_SBIT_TABLE_TYPE_MAX
		}

		public enum FT_Frame_Op_
		{
			ft_frame_end = 0,
			ft_frame_start = ((1 << 2) | (0 << 1) | 0),
			ft_frame_byte = ((2 << 2) | (0 << 1) | 0),
			ft_frame_schar = ((2 << 2) | (0 << 1) | 1),
			ft_frame_ushort_be = ((3 << 2) | (0 << 1) | 0),
			ft_frame_short_be = ((3 << 2) | (0 << 1) | 1),
			ft_frame_ushort_le = ((3 << 2) | (1 << 1) | 0),
			ft_frame_short_le = ((3 << 2) | (1 << 1) | 1),
			ft_frame_ulong_be = ((4 << 2) | (0 << 1) | 0),
			ft_frame_long_be = ((4 << 2) | (0 << 1) | 1),
			ft_frame_ulong_le = ((4 << 2) | (1 << 1) | 0),
			ft_frame_long_le = ((4 << 2) | (1 << 1) | 1),
			ft_frame_uoff3_be = ((5 << 2) | (0 << 1) | 0),
			ft_frame_off3_be = ((5 << 2) | (0 << 1) | 1),
			ft_frame_uoff3_le = ((5 << 2) | (1 << 1) | 0),
			ft_frame_off3_le = ((5 << 2) | (1 << 1) | 1),
			ft_frame_bytes = ((6 << 2) | (0 << 1) | 0),
			ft_frame_skip = ((6 << 2) | (0 << 1) | 1)
		}

		public enum FT_Orientation_
		{
			FT_ORIENTATION_TRUETYPE = 0,
			FT_ORIENTATION_POSTSCRIPT = 1,
			FT_ORIENTATION_FILL_RIGHT = FT_ORIENTATION_TRUETYPE,
			FT_ORIENTATION_FILL_LEFT = FT_ORIENTATION_POSTSCRIPT,
			FT_ORIENTATION_NONE
		}

		public enum FT_ValidationLevel_
		{
			FT_VALIDATE_DEFAULT = 0,
			FT_VALIDATE_TIGHT,
			FT_VALIDATE_PARANOID
		}

		public enum FT_RFork_Rule_
		{
			FT_RFork_Rule_invalid = -2,
			FT_RFork_Rule_uknown,
			FT_RFork_Rule_apple_double,
			FT_RFork_Rule_apple_single,
			FT_RFork_Rule_darwin_ufs_export,
			FT_RFork_Rule_darwin_newvfs,
			FT_RFork_Rule_darwin_hfsplus,
			FT_RFork_Rule_vfat,
			FT_RFork_Rule_linux_cap,
			FT_RFork_Rule_linux_double,
			FT_RFork_Rule_linux_netatalk
		}

		public enum T1_TokenType_
		{
			T1_TOKEN_TYPE_NONE = 0,
			T1_TOKEN_TYPE_ANY,
			T1_TOKEN_TYPE_STRING,
			T1_TOKEN_TYPE_ARRAY,
			T1_TOKEN_TYPE_KEY,
			T1_TOKEN_TYPE_MAX
		}

		public enum T1_FieldType_
		{
			T1_FIELD_TYPE_NONE = 0,
			T1_FIELD_TYPE_BOOL,
			T1_FIELD_TYPE_INTEGER,
			T1_FIELD_TYPE_FIXED,
			T1_FIELD_TYPE_FIXED_1000,
			T1_FIELD_TYPE_STRING,
			T1_FIELD_TYPE_KEY,
			T1_FIELD_TYPE_BBOX,
			T1_FIELD_TYPE_MM_BBOX,
			T1_FIELD_TYPE_INTEGER_ARRAY,
			T1_FIELD_TYPE_FIXED_ARRAY,
			T1_FIELD_TYPE_CALLBACK,
			T1_FIELD_TYPE_MAX
		}

		public enum T1_FieldLocation_
		{
			T1_FIELD_LOCATION_CID_INFO,
			T1_FIELD_LOCATION_FONT_DICT,
			T1_FIELD_LOCATION_FONT_EXTRA,
			T1_FIELD_LOCATION_FONT_INFO,
			T1_FIELD_LOCATION_PRIVATE,
			T1_FIELD_LOCATION_BBOX,
			T1_FIELD_LOCATION_LOADER,
			T1_FIELD_LOCATION_FACE,
			T1_FIELD_LOCATION_BLEND,
			T1_FIELD_LOCATION_MAX
		}

		public enum T1_ParseState_
		{
			T1_Parse_Start,
			T1_Parse_Have_Width,
			T1_Parse_Have_Moveto,
			T1_Parse_Have_Path
		}

		public class FT_MemoryRec_
		{
			public void* user;
			public delegate void* alloc_func(FT_MemoryRec_ a, long b); public alloc_func alloc;
			public delegate void free_func(FT_MemoryRec_ a, void* b); public free_func free;
			public delegate void* realloc_func(FT_MemoryRec_ a, long b, long c, void* d); public realloc_func realloc;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_StreamDesc_
		{
			public int value;
			public void* pointer;
		}
		public class FT_StreamRec_
		{
			public byte* _base_;
			public int size = 0;
			public int pos = 0;
			public union FT_StreamDesc_ descriptor = new union FT_StreamDesc_();
			public union FT_StreamDesc_ pathname = new union FT_StreamDesc_();
			public delegate unsigned long read_func(FT_StreamRec_ a, unsigned long b, unsigned char* c, unsigned long d); public read_func read;
			public delegate void close_func(FT_StreamRec_ a); public close_func close;
			public FT_MemoryRec_ memory;
			public byte* cursor;
			public byte* limit;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Vector_
		{
			public int x;
			public int y;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_BBox_
		{
			public int xMin;
			public int yMin;
			public int xMax;
			public int yMax;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Bitmap_
		{
			public uint rows;
			public uint width;
			public int pitch;
			public byte* buffer;
			public ushort num_grays;
			public byte pixel_mode;
			public byte palette_mode;
			public void* palette;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Outline_
		{
			public short n_contours;
			public short n_points;
			public FT_Vector_* points;
			public sbyte* tags;
			public short* contours;
			public int flags;
		}
		public class FT_Outline_Funcs_
		{
			public delegate int move_to_func(FT_Vector_* a, void* b); public move_to_func move_to;
			public delegate int line_to_func(FT_Vector_* a, void* b); public line_to_func line_to;
			public delegate int conic_to_func(FT_Vector_* a, FT_Vector_* b, void* c); public conic_to_func conic_to;
			public delegate int cubic_to_func(FT_Vector_* a, FT_Vector_* b, FT_Vector_* c, void* d); public cubic_to_func cubic_to;
			public int shift = 0;
			public int delta = 0;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Span_
		{
			public short x;
			public ushort len;
			public byte coverage;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Raster_Params_
		{
			public FT_Bitmap_* target;
			public void* source;
			public int flags;
			public delegate void gray_spans_func(int a, int b, FT_Span_* c, void* d); public gray_spans_func gray_spans;
			public delegate void black_spans_func(int a, int b, FT_Span_* c, void* d); public black_spans_func black_spans;
			public delegate int bit_test_func(int a, int b, void* c); public bit_test_func bit_test;
			public delegate void bit_set_func(int a, int b, void* c); public bit_set_func bit_set;
			public void* user;
			public FT_BBox_ clip_box;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Raster_Funcs_
		{
			public int glyph_format;
			public delegate int raster_new_func(void* a, void** b); public raster_new_func raster_new;
			public delegate void raster_reset_func(void* a, unsigned char* b, unsigned long c); public raster_reset_func raster_reset;
			public delegate int raster_set_mode_func(void* a, unsigned long b, void* c); public raster_set_mode_func raster_set_mode;
			public delegate int raster_render_func(void* a, FT_Raster_Params_* b); public raster_render_func raster_render;
			public delegate void raster_done_func(void* a); public raster_done_func raster_done;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_UnitVector_
		{
			public short x;
			public short y;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Matrix_
		{
			public int xx;
			public int xy;
			public int yx;
			public int yy;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Data_
		{
			public byte* pointer;
			public int length;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Generic_
		{
			public void* data;
			public delegate void finalizer_func(void* a); public finalizer_func finalizer;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_ListNodeRec_
		{
			public FT_ListNodeRec_* prev;
			public FT_ListNodeRec_* next;
			public void* data;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_ListRec_
		{
			public FT_ListNodeRec_* head;
			public FT_ListNodeRec_* tail;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Glyph_Metrics_
		{
			public int width;
			public int height;
			public int horiBearingX;
			public int horiBearingY;
			public int horiAdvance;
			public int vertBearingX;
			public int vertBearingY;
			public int vertAdvance;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Bitmap_Size_
		{
			public short height;
			public short width;
			public int size;
			public int x_ppem;
			public int y_ppem;
		}
		public class FT_CharMapRec_
		{
			public FT_FaceRec_ face;
			public int encoding = 0;
			public ushort platform_id = 0;
			public ushort encoding_id = 0;
		}
		public class FT_FaceRec_
		{
			public int num_faces = 0;
			public int face_index = 0;
			public int face_flags = 0;
			public int style_flags = 0;
			public int num_glyphs = 0;
			public sbyte* family_name;
			public sbyte* style_name;
			public int num_fixed_sizes = 0;
			public FT_Bitmap_Size_* available_sizes;
			public int num_charmaps = 0;
			public FT_CharMapRec_ charmaps;
			public FT_Generic_ generic = new FT_Generic_();
			public FT_BBox_ bbox = new FT_BBox_();
			public ushort units_per_EM = 0;
			public short ascender = 0;
			public short descender = 0;
			public short height = 0;
			public short max_advance_width = 0;
			public short max_advance_height = 0;
			public short underline_position = 0;
			public short underline_thickness = 0;
			public FT_GlyphSlotRec_* glyph;
			public FT_SizeRec_* size;
			public FT_CharMapRec_ charmap;
			public FT_DriverRec_* driver;
			public FT_MemoryRec_ memory;
			public FT_StreamRec_ stream;
			public FT_ListRec_ sizes_list = new FT_ListRec_();
			public FT_Generic_ autohint = new FT_Generic_();
			public void* extensions;
			public FT_Face_InternalRec_* internal;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Size_Metrics_
		{
			public ushort x_ppem;
			public ushort y_ppem;
			public int x_scale;
			public int y_scale;
			public int ascender;
			public int descender;
			public int height;
			public int max_advance;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_SizeRec_
		{
			public FT_FaceRec_ face;
			public FT_Generic_ generic;
			public FT_Size_Metrics_ metrics;
			public FT_Size_InternalRec_* internal;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_GlyphSlotRec_
		{
			public FT_LibraryRec_ library;
			public FT_FaceRec_ face;
			public FT_GlyphSlotRec_* next;
			public uint glyph_index;
			public FT_Generic_ generic;
			public FT_Glyph_Metrics_ metrics;
			public int linearHoriAdvance;
			public int linearVertAdvance;
			public FT_Vector_ advance;
			public int format;
			public FT_Bitmap_ bitmap;
			public int bitmap_left;
			public int bitmap_top;
			public FT_Outline_ outline;
			public uint num_subglyphs;
			public FT_SubGlyphRec_* subglyphs;
			public void* control_data;
			public int control_len;
			public int lsb_delta;
			public int rsb_delta;
			public void* other;
			public FT_Slot_InternalRec_* internal;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Parameter_
		{
			public int tag;
			public void* data;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Open_Args_
		{
			public uint flags;
			public byte* memory_base;
			public int memory_size;
			public sbyte* pathname;
			public FT_StreamRec_ stream;
			public FT_ModuleRec_ driver;
			public int num_params;
			public FT_Parameter_* params;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Size_RequestRec_
		{
			public int type;
			public int width;
			public int height;
			public uint horiResolution;
			public uint vertResolution;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_LayerIterator_
		{
			public uint num_layers;
			public uint layer;
			public byte* p;
		}
		public class FT_Module_Class_
		{
			public int module_flags = 0;
			public int module_size = 0;
			public sbyte* module_name;
			public int module_version = 0;
			public int module_requires = 0;
			public void* module_interface;
			public delegate int module_init_func(FT_ModuleRec_ a); public module_init_func module_init;
			public delegate void module_done_func(FT_ModuleRec_ a); public module_done_func module_done;
			public delegate void* get_interface_func(FT_ModuleRec_ a, char* b); public get_interface_func get_interface;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_GlyphRec_
		{
			public FT_LibraryRec_ library;
			public FT_Glyph_Class_* clazz;
			public int format;
			public FT_Vector_ advance;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_BitmapGlyphRec_
		{
			public FT_GlyphRec_ root;
			public int left;
			public int top;
			public FT_Bitmap_ bitmap;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_OutlineGlyphRec_
		{
			public FT_GlyphRec_ root;
			public FT_Outline_ outline;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Glyph_Class_
		{
			public int glyph_size;
			public int glyph_format;
			public delegate int glyph_init_func(FT_GlyphRec_* a, FT_GlyphSlotRec_* b); public glyph_init_func glyph_init;
			public delegate void glyph_done_func(FT_GlyphRec_* a); public glyph_done_func glyph_done;
			public delegate int glyph_copy_func(FT_GlyphRec_* a, FT_GlyphRec_* b); public glyph_copy_func glyph_copy;
			public delegate void glyph_transform_func(FT_GlyphRec_* a, FT_Matrix_* b, FT_Vector_* c); public glyph_transform_func glyph_transform;
			public delegate void glyph_bbox_func(FT_GlyphRec_* a, FT_BBox_* b); public glyph_bbox_func glyph_bbox;
			public delegate int glyph_prepare_func(FT_GlyphRec_* a, FT_GlyphSlotRec_* b); public glyph_prepare_func glyph_prepare;
		}
		public class FT_Renderer_Class_
		{
			public FT_Module_Class_ root = new FT_Module_Class_();
			public int glyph_format = 0;
			public delegate int render_glyph_func(FT_RendererRec_ a, FT_GlyphSlotRec_* b,  enum FT_Render_Mode_ c,  FT_Vector_* d); public render_glyph_func render_glyph;
			public delegate int transform_glyph_func(FT_RendererRec_ a, FT_GlyphSlotRec_* b, FT_Matrix_* c, FT_Vector_* d); public transform_glyph_func transform_glyph;
			public delegate void get_glyph_cbox_func(FT_RendererRec_ a, FT_GlyphSlotRec_* b, FT_BBox_* c); public get_glyph_cbox_func get_glyph_cbox;
			public delegate int set_mode_func(FT_RendererRec_ a, unsigned long b, void* c); public set_mode_func set_mode;
			public FT_Raster_Funcs_* raster_class;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_SubGlyphRec_
		{
			public int index;
			public ushort flags;
			public int arg1;
			public int arg2;
			public FT_Matrix_ transform;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_GlyphLoadRec_
		{
			public FT_Outline_ outline;
			public FT_Vector_* extra_points;
			public FT_Vector_* extra_points2;
			public uint num_subglyphs;
			public FT_SubGlyphRec_* subglyphs;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_GlyphLoaderRec_
		{
			public FT_MemoryRec_ memory;
			public uint max_points;
			public uint max_contours;
			public uint max_subglyphs;
			public byte use_extra;
			public FT_GlyphLoadRec_ _base_;
			public FT_GlyphLoadRec_ current;
			public void* other;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Driver_ClassRec_
		{
			public FT_Module_Class_ root;
			public int face_object_size;
			public int size_object_size;
			public int slot_object_size;
			public delegate int init_face_func(FT_StreamRec_ a, FT_FaceRec_ b, int c, int d, FT_Parameter_* e); public init_face_func init_face;
			public delegate void done_face_func(FT_FaceRec_ a); public done_face_func done_face;
			public delegate int init_size_func(FT_SizeRec_* a); public init_size_func init_size;
			public delegate void done_size_func(FT_SizeRec_* a); public done_size_func done_size;
			public delegate int init_slot_func(FT_GlyphSlotRec_* a); public init_slot_func init_slot;
			public delegate void done_slot_func(FT_GlyphSlotRec_* a); public done_slot_func done_slot;
			public delegate int load_glyph_func(FT_GlyphSlotRec_* a, FT_SizeRec_* b, unsigned int c, int d); public load_glyph_func load_glyph;
			public delegate int get_kerning_func(FT_FaceRec_ a, unsigned int b, unsigned int c, FT_Vector_* d); public get_kerning_func get_kerning;
			public delegate int attach_file_func(FT_FaceRec_ a, FT_StreamRec_ b); public attach_file_func attach_file;
			public delegate int get_advances_func(FT_FaceRec_ a, unsigned int b, unsigned int c, int d, long* e); public get_advances_func get_advances;
			public delegate int request_size_func(FT_SizeRec_* a, FT_Size_RequestRec_* b); public request_size_func request_size;
			public delegate int select_size_func(FT_SizeRec_* a, unsigned long b); public select_size_func select_size;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_AutoHinter_InterfaceRec_
		{
			public delegate void reset_face_func(FT_AutoHinterRec_* a, FT_FaceRec_ b); public reset_face_func reset_face;
			public delegate void get_global_hints_func(FT_AutoHinterRec_* a, FT_FaceRec_ b, void** c, long* d); public get_global_hints_func get_global_hints;
			public delegate void done_global_hints_func(FT_AutoHinterRec_* a, void* b); public done_global_hints_func done_global_hints;
			public delegate int load_glyph_func(FT_AutoHinterRec_* a, FT_GlyphSlotRec_* b, FT_SizeRec_* c, unsigned int d, int e); public load_glyph_func load_glyph;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_ServiceDescRec_
		{
			public sbyte* serv_id;
			public void* serv_data;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_ServiceCacheRec_
		{
			public void* service_POSTSCRIPT_FONT_NAME;
			public void* service_MULTI_MASTERS;
			public void* service_METRICS_VARIATIONS;
			public void* service_GLYPH_DICT;
			public void* service_PFR_METRICS;
			public void* service_WINFNT;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Incremental_MetricsRec_
		{
			public int bearing_x;
			public int bearing_y;
			public int advance;
			public int advance_v;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Incremental_FuncsRec_
		{
			public delegate int get_glyph_data_func(FT_IncrementalRec_* a, unsigned int b, FT_Data_* c); public get_glyph_data_func get_glyph_data;
			public delegate void free_glyph_data_func(FT_IncrementalRec_* a, FT_Data_* b); public free_glyph_data_func free_glyph_data;
			public delegate int get_glyph_metrics_func(FT_IncrementalRec_* a, unsigned int b, unsigned char c, FT_Incremental_MetricsRec_* d); public get_glyph_metrics_func get_glyph_metrics;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Incremental_InterfaceRec_
		{
			public FT_Incremental_FuncsRec_* funcs;
			public FT_IncrementalRec_* object;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_CMapRec_
		{
			public FT_CharMapRec_ charmap;
			public FT_CMap_ClassRec_* clazz;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_CMap_ClassRec_
		{
			public int size;
			public delegate int init_func(FT_CMapRec_* a, void* b); public init_func init;
			public delegate void done_func(FT_CMapRec_* a); public done_func done;
			public delegate unsigned int char_index_func(FT_CMapRec_* a, unsigned int b); public char_index_func char_index;
			public delegate unsigned int char_next_func(FT_CMapRec_* a, unsigned int* b); public char_next_func char_next;
			public delegate unsigned int char_var_index_func(FT_CMapRec_* a, FT_CMapRec_* b, unsigned int c, unsigned int d); public char_var_index_func char_var_index;
			public delegate int char_var_default_func(FT_CMapRec_* a, unsigned int b, unsigned int c); public char_var_default_func char_var_default;
			public delegate unsigned int* variant_list_func(FT_CMapRec_* a, FT_MemoryRec_ b); public variant_list_func variant_list;
			public delegate unsigned int* charvariant_list_func(FT_CMapRec_* a, FT_MemoryRec_ b, unsigned int c); public charvariant_list_func charvariant_list;
			public delegate unsigned int* variantchar_list_func(FT_CMapRec_* a, FT_MemoryRec_ b, unsigned int c); public variantchar_list_func variantchar_list;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Face_InternalRec_
		{
			public FT_Matrix_ transform_matrix;
			public FT_Vector_ transform_delta;
			public int transform_flags;
			public FT_ServiceCacheRec_ services;
			public FT_Incremental_InterfaceRec_* incremental_interface;
			public sbyte no_stem_darkening;
			public int random_seed;
			public int refcount;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Slot_InternalRec_
		{
			public FT_GlyphLoaderRec_* loader;
			public uint flags;
			public byte glyph_transformed;
			public FT_Matrix_ glyph_matrix;
			public FT_Vector_ glyph_delta;
			public void* glyph_hints;
			public int load_flags;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Size_InternalRec_
		{
			public void* module_data;
			public int autohint_mode;
			public FT_Size_Metrics_ autohint_metrics;
		}
		public class FT_ModuleRec_
		{
			public FT_Module_Class_ clazz;
			public FT_LibraryRec_ library;
			public FT_MemoryRec_ memory;
		}
		public class FT_RendererRec_
		{
			public FT_ModuleRec_ root = new FT_ModuleRec_();
			public FT_Renderer_Class_ clazz;
			public int glyph_format = 0;
			public FT_Glyph_Class_ glyph_class = new FT_Glyph_Class_();
			public void* raster;
			public delegate int raster_render_func(void* a, FT_Raster_Params_* b); public raster_render_func raster_render;
			public delegate int render_func(FT_RendererRec_ a, FT_GlyphSlotRec_* b,  enum FT_Render_Mode_ c,  FT_Vector_* d); public render_func render;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_DriverRec_
		{
			public FT_ModuleRec_ root;
			public FT_Driver_ClassRec_* clazz;
			public FT_ListRec_ faces_list;
			public FT_GlyphLoaderRec_* glyph_loader;
		}
		public class FT_LibraryRec_
		{
			public FT_MemoryRec_ memory;
			public int version_major = 0;
			public int version_minor = 0;
			public int version_patch = 0;
			public uint num_modules = 0;
			public FT_ModuleRec_[] modules = new FT_ModuleRec_[32];
			public FT_ListRec_ renderers = new FT_ListRec_();
			public FT_RendererRec_ cur_renderer;
			public FT_ModuleRec_ auto_hinter;
			public delegate int debug_hooks_func(void* a); public debug_hooks_func debug_hooks;
			public FT_Vector_[] lcd_geometry = new FT_Vector_[3];
			public int refcount = 0;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_Header_
		{
			public int Table_Version;
			public int Font_Revision;
			public int CheckSum_Adjust;
			public int Magic_Number;
			public ushort Flags;
			public ushort Units_Per_EM;
			public fixed int Created[2];
			public fixed int Modified[2];
			public short xMin;
			public short yMin;
			public short xMax;
			public short yMax;
			public ushort Mac_Style;
			public ushort Lowest_Rec_PPEM;
			public short Font_Direction;
			public short Index_To_Loc_Format;
			public short Glyph_Data_Format;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_HoriHeader_
		{
			public int Version;
			public short Ascender;
			public short Descender;
			public short Line_Gap;
			public ushort advance_Width_Max;
			public short min_Left_Side_Bearing;
			public short min_Right_Side_Bearing;
			public short xMax_Extent;
			public short caret_Slope_Rise;
			public short caret_Slope_Run;
			public short caret_Offset;
			public fixed short Reserved[4];
			public short metric_Data_Format;
			public ushort number_Of_HMetrics;
			public void* long_metrics;
			public void* short_metrics;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_VertHeader_
		{
			public int Version;
			public short Ascender;
			public short Descender;
			public short Line_Gap;
			public ushort advance_Height_Max;
			public short min_Top_Side_Bearing;
			public short min_Bottom_Side_Bearing;
			public short yMax_Extent;
			public short caret_Slope_Rise;
			public short caret_Slope_Run;
			public short caret_Offset;
			public fixed short Reserved[4];
			public short metric_Data_Format;
			public ushort number_Of_VMetrics;
			public void* long_metrics;
			public void* short_metrics;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_OS2_
		{
			public ushort version;
			public short xAvgCharWidth;
			public ushort usWeightClass;
			public ushort usWidthClass;
			public ushort fsType;
			public short ySubscriptXSize;
			public short ySubscriptYSize;
			public short ySubscriptXOffset;
			public short ySubscriptYOffset;
			public short ySuperscriptXSize;
			public short ySuperscriptYSize;
			public short ySuperscriptXOffset;
			public short ySuperscriptYOffset;
			public short yStrikeoutSize;
			public short yStrikeoutPosition;
			public short sFamilyClass;
			public fixed byte panose[10];
			public int ulUnicodeRange1;
			public int ulUnicodeRange2;
			public int ulUnicodeRange3;
			public int ulUnicodeRange4;
			public fixed sbyte achVendID[4];
			public ushort fsSelection;
			public ushort usFirstCharIndex;
			public ushort usLastCharIndex;
			public short sTypoAscender;
			public short sTypoDescender;
			public short sTypoLineGap;
			public ushort usWinAscent;
			public ushort usWinDescent;
			public int ulCodePageRange1;
			public int ulCodePageRange2;
			public short sxHeight;
			public short sCapHeight;
			public ushort usDefaultChar;
			public ushort usBreakChar;
			public ushort usMaxContext;
			public ushort usLowerOpticalPointSize;
			public ushort usUpperOpticalPointSize;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_Postscript_
		{
			public int FormatType;
			public int italicAngle;
			public short underlinePosition;
			public short underlineThickness;
			public int isFixedPitch;
			public int minMemType42;
			public int maxMemType42;
			public int minMemType1;
			public int maxMemType1;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_PCLT_
		{
			public int Version;
			public int FontNumber;
			public ushort Pitch;
			public ushort xHeight;
			public ushort Style;
			public ushort TypeFamily;
			public ushort CapHeight;
			public ushort SymbolSet;
			public fixed sbyte TypeFace[16];
			public fixed sbyte CharacterComplement[8];
			public fixed sbyte FileName[6];
			public sbyte StrokeWeight;
			public sbyte WidthType;
			public byte SerifStyle;
			public byte Reserved;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_MaxProfile_
		{
			public int version;
			public ushort numGlyphs;
			public ushort maxPoints;
			public ushort maxContours;
			public ushort maxCompositePoints;
			public ushort maxCompositeContours;
			public ushort maxZones;
			public ushort maxTwilightPoints;
			public ushort maxStorage;
			public ushort maxFunctionDefs;
			public ushort maxInstructionDefs;
			public ushort maxStackElements;
			public ushort maxSizeOfInstructions;
			public ushort maxComponentElements;
			public ushort maxComponentDepth;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Color_
		{
			public byte blue;
			public byte green;
			public byte red;
			public byte alpha;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Palette_Data_
		{
			public ushort num_palettes;
			public ushort* palette_name_ids;
			public ushort* palette_flags;
			public ushort num_palette_entries;
			public ushort* palette_entry_name_ids;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_FontInfoRec_
		{
			public sbyte* version;
			public sbyte* notice;
			public sbyte* full_name;
			public sbyte* family_name;
			public sbyte* weight;
			public int italic_angle;
			public byte is_fixed_pitch;
			public short underline_position;
			public ushort underline_thickness;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_PrivateRec_
		{
			public int unique_id;
			public int lenIV;
			public byte num_blue_values;
			public byte num_other_blues;
			public byte num_family_blues;
			public byte num_family_other_blues;
			public fixed short blue_values[14];
			public fixed short other_blues[10];
			public fixed short family_blues[14];
			public fixed short family_other_blues[10];
			public int blue_scale;
			public int blue_shift;
			public int blue_fuzz;
			public fixed ushort standard_width[1];
			public fixed ushort standard_height[1];
			public byte num_snap_widths;
			public byte num_snap_heights;
			public byte force_bold;
			public byte round_stem_up;
			public fixed short snap_widths[13];
			public fixed short snap_heights[13];
			public int expansion_factor;
			public int language_group;
			public int password;
			public fixed short min_feature[2];
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_DesignMap_
		{
			public byte num_points;
			public int* design_points;
			public int* blend_points;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_BlendRec_
		{
			public uint num_designs;
			public uint num_axis;
			public fixed sbyte axis_names[4];
			public fixed int design_pos[16];
			public PS_DesignMap_[] design_map;
			public int* weight_vector;
			public int* default_weight_vector;
			public PS_FontInfoRec_*[] font_infos;
			public PS_PrivateRec_*[] privates;
			public int blend_bitflags;
			public FT_BBox_*[] bboxes;
			public fixed uint default_design_vector[16];
			public uint num_default_design_vector;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CID_FaceDictRec_
		{
			public PS_PrivateRec_ private_dict;
			public uint len_buildchar;
			public int forcebold_threshold;
			public int stroke_width;
			public int expansion_factor;
			public byte paint_type;
			public byte font_type;
			public FT_Matrix_ font_matrix;
			public FT_Vector_ font_offset;
			public uint num_subrs;
			public int subrmap_offset;
			public int sd_bytes;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CID_FaceInfoRec_
		{
			public sbyte* cid_font_name;
			public int cid_version;
			public int cid_font_type;
			public sbyte* registry;
			public sbyte* ordering;
			public int supplement;
			public PS_FontInfoRec_ font_info;
			public FT_BBox_ font_bbox;
			public int uid_base;
			public int num_xuid;
			public fixed int xuid[16];
			public int cidmap_offset;
			public int fd_bytes;
			public int gd_bytes;
			public int cid_count;
			public int num_dicts;
			public CID_FaceDictRec_* font_dicts;
			public int data_offset;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_MM_Axis_
		{
			public sbyte* name;
			public int minimum;
			public int maximum;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Multi_Master_
		{
			public uint num_axis;
			public uint num_designs;
			public FT_MM_Axis_[] axis;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Var_Axis_
		{
			public sbyte* name;
			public int minimum;
			public int def;
			public int maximum;
			public int tag;
			public uint strid;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Var_Named_Style_
		{
			public int* coords;
			public uint strid;
			public uint psid;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_MM_Var_
		{
			public uint num_axis;
			public uint num_designs;
			public uint num_namedstyles;
			public FT_Var_Axis_* axis;
			public FT_Var_Named_Style_* namedstyle;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TTC_HeaderRec_
		{
			public int tag;
			public int version;
			public int count;
			public int* offsets;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct SFNT_HeaderRec_
		{
			public int format_tag;
			public ushort num_tables;
			public ushort search_range;
			public ushort entry_selector;
			public ushort range_shift;
			public int offset;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_TableRec_
		{
			public int Tag;
			public int CheckSum;
			public int Offset;
			public int Length;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_LongMetricsRec_
		{
			public ushort advance;
			public short bearing;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_NameRec_
		{
			public ushort platformID;
			public ushort encodingID;
			public ushort languageID;
			public ushort nameID;
			public ushort stringLength;
			public int stringOffset;
			public byte* _string_;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_LangTagRec_
		{
			public ushort stringLength;
			public int stringOffset;
			public byte* _string_;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_NameTableRec_
		{
			public ushort format;
			public uint numNameRecords;
			public uint storageOffset;
			public TT_NameRec_* names;
			public uint numLangTagRecords;
			public TT_LangTagRec_* langTags;
			public FT_StreamRec_ stream;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_GaspRangeRec_
		{
			public ushort maxPPEM;
			public ushort gaspFlag;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_Gasp_
		{
			public ushort version;
			public ushort numRanges;
			public TT_GaspRangeRec_* gaspRanges;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_SBit_MetricsRec_
		{
			public ushort height;
			public ushort width;
			public short horiBearingX;
			public short horiBearingY;
			public ushort horiAdvance;
			public short vertBearingX;
			public short vertBearingY;
			public ushort vertAdvance;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_SBit_Small_Metrics_
		{
			public byte height;
			public byte width;
			public sbyte bearingX;
			public sbyte bearingY;
			public byte advance;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_SBit_LineMetricsRec_
		{
			public sbyte ascender;
			public sbyte descender;
			public byte max_width;
			public sbyte caret_slope_numerator;
			public sbyte caret_slope_denominator;
			public sbyte caret_offset;
			public sbyte min_origin_SB;
			public sbyte min_advance_SB;
			public sbyte max_before_BL;
			public sbyte min_after_BL;
			public fixed sbyte pads[2];
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_SBit_RangeRec_
		{
			public ushort first_glyph;
			public ushort last_glyph;
			public ushort index_format;
			public ushort image_format;
			public int image_offset;
			public int image_size;
			public TT_SBit_MetricsRec_ metrics;
			public int num_glyphs;
			public int* glyph_offsets;
			public ushort* glyph_codes;
			public int table_offset;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_SBit_StrikeRec_
		{
			public int num_ranges;
			public TT_SBit_RangeRec_* sbit_ranges;
			public int ranges_offset;
			public int color_ref;
			public TT_SBit_LineMetricsRec_ hori;
			public TT_SBit_LineMetricsRec_ vert;
			public ushort start_glyph;
			public ushort end_glyph;
			public byte x_ppem;
			public byte y_ppem;
			public byte bit_depth;
			public sbyte flags;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_SBit_ComponentRec_
		{
			public ushort glyph_code;
			public sbyte x_offset;
			public sbyte y_offset;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_SBit_ScaleRec_
		{
			public TT_SBit_LineMetricsRec_ hori;
			public TT_SBit_LineMetricsRec_ vert;
			public byte x_ppem;
			public byte y_ppem;
			public byte x_ppem_substitute;
			public byte y_ppem_substitute;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_Post_20Rec_
		{
			public ushort num_glyphs;
			public ushort num_names;
			public ushort* glyph_indices;
			public sbyte** glyph_names;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_Post_25_
		{
			public ushort num_glyphs;
			public sbyte* offsets;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_Post_NamesRec_names
		{
			public TT_Post_20Rec_ format_20;
			public TT_Post_25_ format_25;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_Post_NamesRec_
		{
			public byte loaded;
			public union TT_Post_NamesRec_names names;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_BDFRec_
		{
			public byte* table;
			public byte* table_end;
			public byte* strings;
			public int strings_size;
			public uint num_strikes;
			public byte loaded;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_FaceRec_
		{
			public FT_FaceRec_ root;
			public TTC_HeaderRec_ ttc_header;
			public int format_tag;
			public ushort num_tables;
			public TT_TableRec_* dir_tables;
			public TT_Header_ header;
			public TT_HoriHeader_ horizontal;
			public TT_MaxProfile_ max_profile;
			public byte vertical_info;
			public TT_VertHeader_ vertical;
			public ushort num_names;
			public TT_NameTableRec_ name_table;
			public TT_OS2_ os2;
			public TT_Postscript_ postscript;
			public byte* cmap_table;
			public int cmap_size;
			public delegate int goto_table_func(TT_FaceRec_* a, unsigned long b, FT_StreamRec_ c, unsigned long* d); public goto_table_func goto_table;
			public delegate int access_glyph_frame_func(TT_LoaderRec_* a, unsigned int b, unsigned long c, unsigned int d); public access_glyph_frame_func access_glyph_frame;
			public delegate void forget_glyph_frame_func(TT_LoaderRec_* a); public forget_glyph_frame_func forget_glyph_frame;
			public delegate int read_glyph_header_func(TT_LoaderRec_* a); public read_glyph_header_func read_glyph_header;
			public delegate int read_simple_glyph_func(TT_LoaderRec_* a); public read_simple_glyph_func read_simple_glyph;
			public delegate int read_composite_glyph_func(TT_LoaderRec_* a); public read_composite_glyph_func read_composite_glyph;
			public void* sfnt;
			public void* psnames;
			public void* mm;
			public void* var;
			public void* psaux;
			public TT_Gasp_ gasp;
			public TT_PCLT_ pclt;
			public int num_sbit_scales;
			public TT_SBit_ScaleRec_* sbit_scales;
			public TT_Post_NamesRec_ postscript_names;
			public FT_Palette_Data_ palette_data;
			public ushort palette_index;
			public FT_Color_* palette;
			public byte have_foreground_color;
			public FT_Color_ foreground_color;
			public int font_program_size;
			public byte* font_program;
			public int cvt_program_size;
			public byte* cvt_program;
			public int cvt_size;
			public int* cvt;
			public delegate int interpreter_func(void* a); public interpreter_func interpreter;
			public FT_Generic_ extra;
			public sbyte* postscript_name;
			public int glyf_len;
			public int glyf_offset;
			public byte is_cff2;
			public byte doblend;
			public GX_BlendRec_* blend;
			public uint variation_support;
			public sbyte* var_postscript_prefix;
			public uint var_postscript_prefix_len;
			public int horz_metrics_size;
			public int vert_metrics_size;
			public int num_locations;
			public byte* glyph_locations;
			public byte* hdmx_table;
			public int hdmx_table_size;
			public uint hdmx_record_count;
			public int hdmx_record_size;
			public byte* hdmx_record_sizes;
			public byte* sbit_table;
			public int sbit_table_size;
			public int sbit_table_type;
			public uint sbit_num_strikes;
			public uint* sbit_strike_map;
			public byte* kern_table;
			public int kern_table_size;
			public uint num_kern_tables;
			public uint kern_avail_bits;
			public uint kern_order_bits;
			public TT_BDFRec_ bdf;
			public int horz_metrics_offset;
			public int vert_metrics_offset;
			public int ebdt_start;
			public int ebdt_size;
			public void* cpal;
			public void* colr;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_GlyphZoneRec_
		{
			public FT_MemoryRec_ memory;
			public ushort max_points;
			public short max_contours;
			public ushort n_points;
			public short n_contours;
			public FT_Vector_* org;
			public FT_Vector_* cur;
			public FT_Vector_* orus;
			public byte* tags;
			public ushort* contours;
			public ushort first_point;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_LoaderRec_
		{
			public TT_FaceRec_* face;
			public TT_SizeRec_* size;
			public FT_GlyphSlotRec_* glyph;
			public FT_GlyphLoaderRec_* gloader;
			public int load_flags;
			public uint glyph_index;
			public FT_StreamRec_ stream;
			public int byte_len;
			public short n_contours;
			public FT_BBox_ bbox;
			public int left_bearing;
			public int advance;
			public int linear;
			public byte linear_def;
			public FT_Vector_ pp1;
			public FT_Vector_ pp2;
			public TT_GlyphZoneRec_ _base_;
			public TT_GlyphZoneRec_ zone;
			public TT_ExecContextRec_* exec;
			public byte* instructions;
			public int ins_pos;
			public void* other;
			public int top_bearing;
			public int vadvance;
			public FT_Vector_ pp3;
			public FT_Vector_ pp4;
			public byte* cursor;
			public byte* limit;
			public FT_ListRec_ composites;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct WOFF_HeaderRec_
		{
			public int signature;
			public int flavor;
			public int length;
			public ushort num_tables;
			public ushort reserved;
			public int totalSfntSize;
			public ushort majorVersion;
			public ushort minorVersion;
			public int metaOffset;
			public int metaLength;
			public int metaOrigLength;
			public int privOffset;
			public int privLength;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct WOFF_TableRec_
		{
			public int Tag;
			public int Offset;
			public int CompLength;
			public int OrigLength;
			public int CheckSum;
			public int OrigOffset;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct WOFF2_TtcFontRec_
		{
			public int flavor;
			public ushort num_tables;
			public ushort* table_indices;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct WOFF2_HeaderRec_
		{
			public int signature;
			public int flavor;
			public int length;
			public ushort num_tables;
			public int totalSfntSize;
			public int totalCompressedSize;
			public int metaOffset;
			public int metaLength;
			public int metaOrigLength;
			public int privOffset;
			public int privLength;
			public int uncompressed_size;
			public int compressed_offset;
			public int header_version;
			public ushort num_fonts;
			public int actual_sfnt_size;
			public WOFF2_TtcFontRec_* ttc_fonts;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct WOFF2_TableRec_
		{
			public byte FlagByte;
			public int Tag;
			public int dst_length;
			public int TransformLength;
			public int flags;
			public int src_offset;
			public int src_length;
			public int dst_offset;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct WOFF2_InfoRec_
		{
			public int header_checksum;
			public ushort num_glyphs;
			public ushort num_hmetrics;
			public short* x_mins;
			public WOFF2_TableRec_* glyf_table;
			public WOFF2_TableRec_* loca_table;
			public WOFF2_TableRec_* head_table;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct WOFF2_SubstreamRec_
		{
			public int start;
			public int offset;
			public int size;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct WOFF2_PointRec_
		{
			public int x;
			public int y;
			public byte on_curve;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct SFNT_Interface_
		{
			public delegate int goto_table_func(TT_FaceRec_* a, unsigned long b, FT_StreamRec_ c, unsigned long* d); public goto_table_func goto_table;
			public delegate int init_face_func(FT_StreamRec_ a, TT_FaceRec_* b, int c, int d, FT_Parameter_* e); public init_face_func init_face;
			public delegate int load_face_func(FT_StreamRec_ a, TT_FaceRec_* b, int c, int d, FT_Parameter_* e); public load_face_func load_face;
			public delegate void done_face_func(TT_FaceRec_* a); public done_face_func done_face;
			public delegate void* get_interface_func(FT_ModuleRec_ a, char* b); public get_interface_func get_interface;
			public delegate int load_any_func(TT_FaceRec_* a, unsigned long b, long c, unsigned char* d, unsigned long* e); public load_any_func load_any;
			public delegate int load_head_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_head_func load_head;
			public delegate int load_hhea_func(TT_FaceRec_* a, FT_StreamRec_ b, unsigned char c); public load_hhea_func load_hhea;
			public delegate int load_cmap_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_cmap_func load_cmap;
			public delegate int load_maxp_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_maxp_func load_maxp;
			public delegate int load_os2_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_os2_func load_os2;
			public delegate int load_post_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_post_func load_post;
			public delegate int load_name_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_name_func load_name;
			public delegate void free_name_func(TT_FaceRec_* a); public free_name_func free_name;
			public delegate int load_kern_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_kern_func load_kern;
			public delegate int load_gasp_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_gasp_func load_gasp;
			public delegate int load_pclt_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_pclt_func load_pclt;
			public delegate int load_bhed_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_bhed_func load_bhed;
			public delegate int load_sbit_image_func(TT_FaceRec_* a, unsigned long b, unsigned int c, unsigned int d, FT_StreamRec_ e, FT_Bitmap_* f, TT_SBit_MetricsRec_* g); public load_sbit_image_func load_sbit_image;
			public delegate int get_psname_func(TT_FaceRec_* a, unsigned int b, char** c); public get_psname_func get_psname;
			public delegate void free_psnames_func(TT_FaceRec_* a); public free_psnames_func free_psnames;
			public delegate int get_kerning_func(TT_FaceRec_* a, unsigned int b, unsigned int c); public get_kerning_func get_kerning;
			public delegate int load_font_dir_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_font_dir_func load_font_dir;
			public delegate int load_hmtx_func(TT_FaceRec_* a, FT_StreamRec_ b, unsigned char c); public load_hmtx_func load_hmtx;
			public delegate int load_eblc_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_eblc_func load_eblc;
			public delegate void free_eblc_func(TT_FaceRec_* a); public free_eblc_func free_eblc;
			public delegate int set_sbit_strike_func(TT_FaceRec_* a, FT_Size_RequestRec_* b, unsigned long* c); public set_sbit_strike_func set_sbit_strike;
			public delegate int load_strike_metrics_func(TT_FaceRec_* a, unsigned long b, FT_Size_Metrics_* c); public load_strike_metrics_func load_strike_metrics;
			public delegate int load_cpal_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_cpal_func load_cpal;
			public delegate int load_colr_func(TT_FaceRec_* a, FT_StreamRec_ b); public load_colr_func load_colr;
			public delegate void free_cpal_func(TT_FaceRec_* a); public free_cpal_func free_cpal;
			public delegate void free_colr_func(TT_FaceRec_* a); public free_colr_func free_colr;
			public delegate int set_palette_func(TT_FaceRec_* a, unsigned int b); public set_palette_func set_palette;
			public delegate unsigned char get_colr_layer_func(TT_FaceRec_* a, unsigned int b, unsigned int* c, unsigned int* d, FT_LayerIterator_* e); public get_colr_layer_func get_colr_layer;
			public delegate int colr_blend_func(TT_FaceRec_* a, unsigned int b, FT_GlyphSlotRec_* c, FT_GlyphSlotRec_* d); public colr_blend_func colr_blend;
			public delegate void get_metrics_func(TT_FaceRec_* a, unsigned char b, unsigned int c, short* d, unsigned short* e); public get_metrics_func get_metrics;
			public delegate int get_name_func(TT_FaceRec_* a, unsigned short b, char** c); public get_name_func get_name;
			public delegate unsigned char get_name_id_func(TT_FaceRec_* a, unsigned short b, int* c, int* d); public get_name_id_func get_name_id;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Hashkey_
		{
			public int num;
			public sbyte* str;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_HashnodeRec_
		{
			public union FT_Hashkey_ key;
		public ulong data;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_HashRec_
		{
			public uint limit;
			public uint size;
			public uint used;
			public delegate unsigned long lookup_func(union FT_Hashkey_ * a); public lookup_func lookup;
			public delegate unsigned char compare_func(union FT_Hashkey_ * a, union FT_Hashkey_ * b); public compare_func compare;
			public FT_HashnodeRec_** table;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Frame_Field_
		{
			public byte value;
			public byte size;
			public ushort offset;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_ValidatorRec_
		{
			public _SETJMP_FLOAT128[] jump_buffer;
			public byte* _base_;
			public byte* limit;
			public int level;
			public int error;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_RFork_Ref_
		{
			public short res_id;
			public int offset;
		}
		public class ft_raccess_guess_rec_
		{
			public delegate int func_func(FT_LibraryRec_ a, FT_StreamRec_ b, char* c, char** d, long* e); public func_func func;
			public int type = 0;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PSH_Globals_FuncsRec_
		{
			public delegate int create_func(FT_MemoryRec_ a, PS_PrivateRec_* b, PSH_GlobalsRec_** c); public create_func create;
			public delegate void set_scale_func(PSH_GlobalsRec_* a, long b, long c, long d, long e); public set_scale_func set_scale;
			public delegate void destroy_func(PSH_GlobalsRec_* a); public destroy_func destroy;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct T1_Hints_FuncsRec_
		{
			public T1_HintsRec_* hints;
			public delegate void open_func(T1_HintsRec_* a); public open_func open;
			public delegate int close_func(T1_HintsRec_* a, unsigned int b); public close_func close;
			public delegate void stem_func(T1_HintsRec_* a, unsigned int b, long* c); public stem_func stem;
			public delegate void stem3_func(T1_HintsRec_* a, unsigned int b, long* c); public stem3_func stem3;
			public delegate void reset_func(T1_HintsRec_* a, unsigned int b); public reset_func reset;
			public delegate int apply_func(T1_HintsRec_* a, FT_Outline_* b, PSH_GlobalsRec_* c,  enum FT_Render_Mode_ d);public apply_func apply;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct T2_Hints_FuncsRec_
		{
			public T2_HintsRec_* hints;
			public delegate void open_func(T2_HintsRec_* a); public open_func open;
			public delegate int close_func(T2_HintsRec_* a, unsigned int b); public close_func close;
			public delegate void stems_func(T2_HintsRec_* a, unsigned int b, int c, long* d); public stems_func stems;
			public delegate void hintmask_func(T2_HintsRec_* a, unsigned int b, unsigned int c, unsigned char* d); public hintmask_func hintmask;
			public delegate void counter_func(T2_HintsRec_* a, unsigned int b, unsigned char* c); public counter_func counter;
			public delegate int apply_func(T2_HintsRec_* a, FT_Outline_* b, PSH_GlobalsRec_* c,  enum FT_Render_Mode_ d);public apply_func apply;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PSHinter_Interface_
		{
			public delegate PSH_Globals_FuncsRec_* get_globals_funcs_func(FT_ModuleRec_ a); public get_globals_funcs_func get_globals_funcs;
			public delegate const T1_Hints_FuncsRec_* get_t1_funcs_func(FT_ModuleRec_ a); public get_t1_funcs_func get_t1_funcs;
			public delegate const T2_Hints_FuncsRec_* get_t2_funcs_func(FT_ModuleRec_ a); public get_t2_funcs_func get_t2_funcs;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_UniMap_
		{
			public uint unicode;
			public uint glyph_index;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_UnicodesRec_
		{
			public FT_CMapRec_ cmap;
			public uint num_maps;
			public PS_UniMap_* maps;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Service_PsCMapsRec_
		{
			public delegate unsigned int unicode_value_func(char* a); public unicode_value_func unicode_value;
			public int (FT_MemoryRec_*, PS_UnicodesRec_*, unsigned int, const char*(*)(void*, unsigned int), void (*) (void*, const char*), void*)* unicodes_init;
		public delegate unsigned int unicodes_char_index_func(PS_UnicodesRec_* a, unsigned int b); public unicodes_char_index_func unicodes_char_index;
			public delegate unsigned int unicodes_char_next_func(PS_UnicodesRec_* a, unsigned int* b); public unicodes_char_next_func unicodes_char_next;
			public delegate const char* macintosh_name_func(unsigned int a); public macintosh_name_func macintosh_name;
			public delegate const char* adobe_std_strings_func(unsigned int a); public adobe_std_strings_func adobe_std_strings;
			public ushort* adobe_std_encoding;
			public ushort* adobe_expert_encoding;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct T1_EncodingRecRec_
		{
			public int num_chars;
			public int code_first;
			public int code_last;
			public ushort* char_index;
			public sbyte** char_name;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_FontExtraRec_
		{
			public ushort fs_type;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct T1_FontRec_
		{
			public PS_FontInfoRec_ font_info;
			public PS_FontExtraRec_ font_extra;
			public PS_PrivateRec_ private_dict;
			public sbyte* font_name;
			public int encoding_type;
			public T1_EncodingRecRec_ encoding;
			public byte* subrs_block;
			public byte* charstrings_block;
			public byte* glyph_names_block;
			public int num_subrs;
			public byte** subrs;
			public uint* subrs_len;
			public FT_HashRec_* subrs_hash;
			public int num_glyphs;
			public sbyte** glyph_names;
			public byte** charstrings;
			public uint* charstrings_len;
			public byte paint_type;
			public byte font_type;
			public FT_Matrix_ font_matrix;
			public FT_Vector_ font_offset;
			public FT_BBox_ font_bbox;
			public int font_id;
			public int stroke_width;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CID_SubrsRec_
		{
			public int num_subrs;
			public byte** code;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct AFM_TrackKernRec_
		{
			public int degree;
			public int min_ptsize;
			public int min_kern;
			public int max_ptsize;
			public int max_kern;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct AFM_KernPairRec_
		{
			public uint index1;
			public uint index2;
			public int x;
			public int y;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct AFM_FontInfoRec_
		{
			public byte IsCIDFont;
			public FT_BBox_ FontBBox;
			public int Ascender;
			public int Descender;
			public AFM_TrackKernRec_* TrackKerns;
			public uint NumTrackKern;
			public AFM_KernPairRec_* KernPairs;
			public uint NumKernPair;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct T1_FaceRec_
		{
			public FT_FaceRec_ root;
			public T1_FontRec_ type1;
			public void* psnames;
			public void* psaux;
			public void* afm_data;
			public FT_CharMapRec_[] charmaprecs;
			public FT_CharMapRec_[] charmaps;
			public PS_BlendRec_* blend;
			public int ndv_idx;
			public int cdv_idx;
			public uint len_buildchar;
			public int* buildchar;
			public void* pshinter;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CID_FaceRec_
		{
			public FT_FaceRec_ root;
			public void* psnames;
			public void* psaux;
			public CID_FaceInfoRec_ cid;
			public PS_FontExtraRec_ font_extra;
			public CID_SubrsRec_* subrs;
			public void* pshinter;
			public byte* binary_data;
			public FT_StreamRec_ cid_stream;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_IndexRec_
		{
			public FT_StreamRec_ stream;
			public int start;
			public uint hdr_size;
			public uint count;
			public byte off_size;
			public int data_offset;
			public int data_size;
			public int* offsets;
			public byte* bytes;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_EncodingRec_
		{
			public uint format;
			public int offset;
			public uint count;
			public fixed ushort sids[256];
			public fixed ushort codes[256];
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_CharsetRec_
		{
			public uint format;
			public int offset;
			public ushort* sids;
			public ushort* cids;
			public uint max_cid;
			public uint num_glyphs;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_VarData_
		{
			public uint regionIdxCount;
			public uint* regionIndices;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_AxisCoords_
		{
			public int startCoord;
			public int peakCoord;
			public int endCoord;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_VarRegion_
		{
			public CFF_AxisCoords_* axisList;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_VStoreRec_
		{
			public uint dataCount;
			public CFF_VarData_* varData;
			public ushort axisCount;
			public uint regionCount;
			public CFF_VarRegion_* varRegionList;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_BlendRec_
		{
			public byte builtBV;
			public byte usedBV;
			public CFF_FontRec_* font;
			public uint lastVsindex;
			public uint lenNDV;
			public int* lastNDV;
			public uint lenBV;
			public int* BV;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_FontRecDictRec_
		{
			public uint version;
			public uint notice;
			public uint copyright;
			public uint full_name;
			public uint family_name;
			public uint weight;
			public byte is_fixed_pitch;
			public int italic_angle;
			public int underline_position;
			public int underline_thickness;
			public int paint_type;
			public int charstring_type;
			public FT_Matrix_ font_matrix;
			public byte has_font_matrix;
			public int units_per_em;
			public FT_Vector_ font_offset;
			public int unique_id;
			public FT_BBox_ font_bbox;
			public int stroke_width;
			public int charset_offset;
			public int encoding_offset;
			public int charstrings_offset;
			public int private_offset;
			public int private_size;
			public int synthetic_base;
			public uint embedded_postscript;
			public uint cid_registry;
			public uint cid_ordering;
			public int cid_supplement;
			public int cid_font_version;
			public int cid_font_revision;
			public int cid_font_type;
			public int cid_count;
			public int cid_uid_base;
			public int cid_fd_array_offset;
			public int cid_fd_select_offset;
			public uint cid_font_name;
			public ushort num_designs;
			public ushort num_axes;
			public int vstore_offset;
			public uint maxstack;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_PrivateRec_
		{
			public byte num_blue_values;
			public byte num_other_blues;
			public byte num_family_blues;
			public byte num_family_other_blues;
			public fixed int blue_values[14];
			public fixed int other_blues[10];
			public fixed int family_blues[14];
			public fixed int family_other_blues[10];
			public int blue_scale;
			public int blue_shift;
			public int blue_fuzz;
			public int standard_width;
			public int standard_height;
			public byte num_snap_widths;
			public byte num_snap_heights;
			public fixed int snap_widths[13];
			public fixed int snap_heights[13];
			public byte force_bold;
			public int force_bold_threshold;
			public int lenIV;
			public int language_group;
			public int expansion_factor;
			public int initial_random_seed;
			public int local_subrs_offset;
			public int default_width;
			public int nominal_width;
			public uint vsindex;
			public CFF_SubFontRec_* subfont;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_FDSelectRec_
		{
			public byte format;
			public uint range_count;
			public byte* data;
			public uint data_size;
			public uint cache_first;
			public uint cache_count;
			public byte cache_fd;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_SubFontRec_
		{
			public CFF_FontRecDictRec_ font_dict;
			public CFF_PrivateRec_ private_dict;
			public CFF_BlendRec_ blend;
			public uint lenNDV;
			public int* NDV;
			public byte* blend_stack;
			public byte* blend_top;
			public uint blend_used;
			public uint blend_alloc;
			public CFF_IndexRec_ local_subrs_index;
			public byte** local_subrs;
			public uint random;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_FontRec_
		{
			public FT_LibraryRec_ library;
			public FT_StreamRec_ stream;
			public FT_MemoryRec_ memory;
			public int base_offset;
			public uint num_faces;
			public uint num_glyphs;
			public byte version_major;
			public byte version_minor;
			public byte header_size;
			public uint top_dict_length;
			public byte cff2;
			public CFF_IndexRec_ name_index;
			public CFF_IndexRec_ top_dict_index;
			public CFF_IndexRec_ global_subrs_index;
			public CFF_EncodingRec_ encoding;
			public CFF_CharsetRec_ charset;
			public CFF_IndexRec_ charstrings_index;
			public CFF_IndexRec_ font_dict_index;
			public CFF_IndexRec_ private_index;
			public CFF_IndexRec_ local_subrs_index;
			public sbyte* font_name;
			public byte** global_subrs;
			public uint num_strings;
			public byte** strings;
			public byte* string_pool;
			public int string_pool_size;
			public CFF_SubFontRec_ top_font;
			public uint num_subfonts;
			public CFF_SubFontRec_*[] subfonts;
			public CFF_FDSelectRec_ fd_select;
			public PSHinter_Interface_* pshinter;
			public FT_Service_PsCMapsRec_* psnames;
			public void* cffload;
			public PS_FontInfoRec_* font_info;
			public sbyte* registry;
			public sbyte* ordering;
			public FT_Generic_ cf2_instance;
			public CFF_VStoreRec_ vstore;
			public PS_FontExtraRec_* font_extra;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_SizeRec_
		{
			public FT_SizeRec_ root;
			public int strike_index;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_GlyphSlotRec_
		{
			public FT_GlyphSlotRec_ root;
			public byte hint;
			public byte scaled;
			public int x_scale;
			public int y_scale;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_InternalRec_
		{
			public PSH_GlobalsRec_* topfont;
			public PSH_GlobalsRec_*[] subfonts;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_Transform_
		{
			public int xx;
			public int xy;
			public int yx;
			public int yy;
			public int ox;
			public int oy;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_DriverRec_
		{
			public FT_DriverRec_ root;
			public uint hinting_engine;
			public byte no_stem_darkening;
			public fixed int darken_params[8];
			public int random_seed;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_Table_FuncsRec_
		{
			public delegate int init_func(PS_TableRec_* a, int b, FT_MemoryRec_ c); public init_func init;
			public delegate void done_func(PS_TableRec_* a); public done_func done;
			public delegate int add_func(PS_TableRec_* a, int b, void* c, unsigned int d); public add_func add;
			public delegate void release_func(PS_TableRec_* a); public release_func release;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_TableRec_
		{
			public byte* block;
			public ulong cursor;
			public ulong capacity;
			public int init;
			public int max_elems;
			public int num_elems;
			public byte** elements;
			public uint* lengths;
			public FT_MemoryRec_ memory;
			public PS_Table_FuncsRec_ funcs;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct T1_TokenRec_
		{
			public byte* start;
			public byte* limit;
			public int type;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct T1_FieldRec_
		{
			public sbyte* ident;
			public int location;
			public int type;
			public delegate void reader_func(FT_FaceRec_ a, void* b); public reader_func reader;
			public uint offset;
			public byte size;
			public uint array_max;
			public uint count_offset;
			public uint dict;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_Parser_FuncsRec_
		{
			public delegate void init_func(PS_ParserRec_* a, unsigned char* b, unsigned char* c, FT_MemoryRec_ d); public init_func init;
			public delegate void done_func(PS_ParserRec_* a); public done_func done;
			public delegate void skip_spaces_func(PS_ParserRec_* a); public skip_spaces_func skip_spaces;
			public delegate void skip_PS_token_func(PS_ParserRec_* a); public skip_PS_token_func skip_PS_token;
			public delegate long to_int_func(PS_ParserRec_* a); public to_int_func to_int;
			public delegate long to_fixed_func(PS_ParserRec_* a, int b); public to_fixed_func to_fixed;
			public delegate int to_bytes_func(PS_ParserRec_* a, unsigned char* b, unsigned long long c, unsigned long* d, unsigned char e); public to_bytes_func to_bytes;
			public delegate int to_coord_array_func(PS_ParserRec_* a, int b, short* c); public to_coord_array_func to_coord_array;
			public delegate int to_fixed_array_func(PS_ParserRec_* a, int b, long* c, int d); public to_fixed_array_func to_fixed_array;
			public delegate void to_token_func(PS_ParserRec_* a, T1_TokenRec_* b); public to_token_func to_token;
			public delegate void to_token_array_func(PS_ParserRec_* a, T1_TokenRec_* b, unsigned int c, int* d); public to_token_array_func to_token_array;
			public delegate int load_field_func(PS_ParserRec_* a, T1_FieldRec_* b, void** c, unsigned int d, unsigned long* e); public load_field_func load_field;
			public delegate int load_field_table_func(PS_ParserRec_* a, T1_FieldRec_* b, void** c, unsigned int d, unsigned long* e); public load_field_table_func load_field_table;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_ParserRec_
		{
			public byte* cursor;
			public byte* _base_;
			public byte* limit;
			public int error;
			public FT_MemoryRec_ memory;
			public PS_Parser_FuncsRec_ funcs;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_Builder_FuncsRec_
		{
			public delegate void init_func(PS_Builder_* a, void* b, unsigned char c); public init_func init;
			public delegate void done_func(PS_Builder_* a); public done_func done;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_Builder_
		{
			public FT_MemoryRec_ memory;
			public FT_FaceRec_ face;
			public CFF_GlyphSlotRec_* glyph;
			public FT_GlyphLoaderRec_* loader;
			public FT_Outline_* _base_;
			public FT_Outline_* current;
			public int* pos_x;
			public int* pos_y;
			public FT_Vector_* left_bearing;
			public FT_Vector_* advance;
			public FT_BBox_* bbox;
			public byte path_begun;
			public byte load_points;
			public byte no_recurse;
			public byte metrics_only;
			public byte is_t1;
			public PS_Builder_FuncsRec_ funcs;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_Decoder_Zone_
		{
			public byte* _base_;
			public byte* limit;
			public byte* cursor;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PS_Decoder_
		{
			public PS_Builder_ builder;
			public fixed int stack[48 + 1];
			public int* top;
			public PS_Decoder_Zone_[] zones;
			public PS_Decoder_Zone_* zone;
			public int flex_state;
			public int num_flex_vectors;
			public FT_Vector_[] flex_vectors;
			public CFF_FontRec_* cff;
			public CFF_SubFontRec_* current_subfont;
			public FT_Generic_* cf2_instance;
			public int* glyph_width;
			public byte width_only;
			public int num_hints;
			public uint num_locals;
			public uint num_globals;
			public int locals_bias;
			public int globals_bias;
			public byte** locals;
			public byte** globals;
			public byte** glyph_names;
			public uint num_glyphs;
			public int hint_mode;
			public byte seac;
			public delegate int get_glyph_callback_func(TT_FaceRec_* a, unsigned int b, unsigned char** c, unsigned long* d); public get_glyph_callback_func get_glyph_callback;
			public delegate void free_glyph_callback_func(TT_FaceRec_* a, unsigned char** b, unsigned long c); public free_glyph_callback_func free_glyph_callback;
			public FT_Service_PsCMapsRec_* psnames;
			public int lenIV;
			public uint* locals_len;
			public FT_HashRec_* locals_hash;
			public FT_Matrix_ font_matrix;
			public FT_Vector_ font_offset;
			public PS_BlendRec_* blend;
			public int* buildchar;
			public uint len_buildchar;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct T1_Builder_FuncsRec_
		{
			public delegate void init_func(T1_BuilderRec_* a, FT_FaceRec_ b, FT_SizeRec_* c, FT_GlyphSlotRec_* d, unsigned char e); public init_func init;
			public delegate void done_func(T1_BuilderRec_* a); public done_func done;
			public delegate int check_points_func(T1_BuilderRec_* a, int b); public check_points_func check_points;
			public delegate void add_point_func(T1_BuilderRec_* a, long b, long c, unsigned char d); public add_point_func add_point;
			public delegate int add_point1_func(T1_BuilderRec_* a, long b, long c); public add_point1_func add_point1;
			public delegate int add_contour_func(T1_BuilderRec_* a); public add_contour_func add_contour;
			public delegate int start_point_func(T1_BuilderRec_* a, long b, long c); public start_point_func start_point;
			public delegate void close_contour_func(T1_BuilderRec_* a); public close_contour_func close_contour;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct T1_BuilderRec_
		{
			public FT_MemoryRec_ memory;
			public FT_FaceRec_ face;
			public FT_GlyphSlotRec_* glyph;
			public FT_GlyphLoaderRec_* loader;
			public FT_Outline_* _base_;
			public FT_Outline_* current;
			public int pos_x;
			public int pos_y;
			public FT_Vector_ left_bearing;
			public FT_Vector_ advance;
			public FT_BBox_ bbox;
			public int parse_state;
			public byte load_points;
			public byte no_recurse;
			public byte metrics_only;
			public void* hints_funcs;
			public void* hints_globals;
			public T1_Builder_FuncsRec_ funcs;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct T1_Decoder_ZoneRec_
		{
			public byte* cursor;
			public byte* _base_;
			public byte* limit;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct T1_Decoder_FuncsRec_
		{
			public int (T1_DecoderRec_*, FT_FaceRec_*, FT_SizeRec_*, FT_GlyphSlotRec_*, unsigned char**, PS_BlendRec_*, unsigned char, enum FT_Render_Mode_, int (*) (T1_DecoderRec_*, unsigned int))* init;
		public delegate void done_func(T1_DecoderRec_* a); public done_func done;
			public delegate int parse_metrics_func(T1_DecoderRec_* a, unsigned char* b, unsigned int c); public parse_metrics_func parse_metrics;
			public delegate int parse_charstrings_func(PS_Decoder_* a, unsigned char* b, unsigned long c); public parse_charstrings_func parse_charstrings;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct T1_DecoderRec_
		{
			public T1_BuilderRec_ builder;
			public fixed int stack[256];
			public int* top;
			public T1_Decoder_ZoneRec_[] zones;
			public T1_Decoder_ZoneRec_* zone;
			public FT_Service_PsCMapsRec_* psnames;
			public uint num_glyphs;
			public byte** glyph_names;
			public int lenIV;
			public int num_subrs;
			public byte** subrs;
			public uint* subrs_len;
			public FT_HashRec_* subrs_hash;
			public FT_Matrix_ font_matrix;
			public FT_Vector_ font_offset;
			public int flex_state;
			public int num_flex_vectors;
			public FT_Vector_[] flex_vectors;
			public PS_BlendRec_* blend;
			public int hint_mode;
			public delegate int parse_callback_func(T1_DecoderRec_* a, unsigned int b); public parse_callback_func parse_callback;
			public T1_Decoder_FuncsRec_ funcs;
			public int* buildchar;
			public uint len_buildchar;
			public byte seac;
			public FT_Generic_ cf2_instance;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_Builder_FuncsRec_
		{
			public delegate void init_func(CFF_Builder_* a, TT_FaceRec_* b, CFF_SizeRec_* c, CFF_GlyphSlotRec_* d, unsigned char e); public init_func init;
			public delegate void done_func(CFF_Builder_* a); public done_func done;
			public delegate int check_points_func(CFF_Builder_* a, int b); public check_points_func check_points;
			public delegate void add_point_func(CFF_Builder_* a, long b, long c, unsigned char d); public add_point_func add_point;
			public delegate int add_point1_func(CFF_Builder_* a, long b, long c); public add_point1_func add_point1;
			public delegate int add_contour_func(CFF_Builder_* a); public add_contour_func add_contour;
			public delegate int start_point_func(CFF_Builder_* a, long b, long c); public start_point_func start_point;
			public delegate void close_contour_func(CFF_Builder_* a); public close_contour_func close_contour;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_Builder_
		{
			public FT_MemoryRec_ memory;
			public TT_FaceRec_* face;
			public CFF_GlyphSlotRec_* glyph;
			public FT_GlyphLoaderRec_* loader;
			public FT_Outline_* _base_;
			public FT_Outline_* current;
			public int pos_x;
			public int pos_y;
			public FT_Vector_ left_bearing;
			public FT_Vector_ advance;
			public FT_BBox_ bbox;
			public byte path_begun;
			public byte load_points;
			public byte no_recurse;
			public byte metrics_only;
			public void* hints_funcs;
			public void* hints_globals;
			public CFF_Builder_FuncsRec_ funcs;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_Decoder_Zone_
		{
			public byte* _base_;
			public byte* limit;
			public byte* cursor;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_Decoder_
		{
			public CFF_Builder_ builder;
			public CFF_FontRec_* cff;
			public fixed int stack[48 + 1];
			public int* top;
			public CFF_Decoder_Zone_[] zones;
			public CFF_Decoder_Zone_* zone;
			public int flex_state;
			public int num_flex_vectors;
			public FT_Vector_[] flex_vectors;
			public int glyph_width;
			public int nominal_width;
			public byte read_width;
			public byte width_only;
			public int num_hints;
			public fixed int buildchar[32];
			public uint num_locals;
			public uint num_globals;
			public int locals_bias;
			public int globals_bias;
			public byte** locals;
			public byte** globals;
			public byte** glyph_names;
			public uint num_glyphs;
			public int hint_mode;
			public byte seac;
			public CFF_SubFontRec_* current_subfont;
			public delegate int get_glyph_callback_func(TT_FaceRec_* a, unsigned int b, unsigned char** c, unsigned long* d); public get_glyph_callback_func get_glyph_callback;
			public delegate void free_glyph_callback_func(TT_FaceRec_* a, unsigned char** b, unsigned long c); public free_glyph_callback_func free_glyph_callback;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct CFF_Decoder_FuncsRec_
		{
			public void (CFF_Decoder_*, TT_FaceRec_*, CFF_SizeRec_*, CFF_GlyphSlotRec_*, unsigned char, enum FT_Render_Mode_, int (*) (TT_FaceRec_*, unsigned int, unsigned char**, unsigned long*), void (*) (TT_FaceRec_*, unsigned char**, unsigned long))* init;
		public delegate int prepare_func(CFF_Decoder_* a, CFF_SizeRec_* b, unsigned int c); public prepare_func prepare;
			public delegate int parse_charstrings_func(PS_Decoder_* a, unsigned char* b, unsigned long c); public parse_charstrings_func parse_charstrings;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct AFM_Parser_FuncsRec_
		{
			public delegate int init_func(AFM_ParserRec_* a, FT_MemoryRec_ b, unsigned char* c, unsigned char* d); public init_func init;
			public delegate void done_func(AFM_ParserRec_* a); public done_func done;
			public delegate int parse_func(AFM_ParserRec_* a); public parse_func parse;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct AFM_ParserRec_
		{
			public FT_MemoryRec_ memory;
			public AFM_StreamRec_* stream;
			public AFM_FontInfoRec_* FontInfo;
			public delegate int get_index_func(char* a, unsigned long long b, void* c); public get_index_func get_index;
			public void* user_data;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct T1_CMap_ClassesRec_
		{
			public FT_CMap_ClassRec_* standard;
			public FT_CMap_ClassRec_* expert;
			public FT_CMap_ClassRec_* custom;
			public FT_CMap_ClassRec_* unicode;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct PSAux_ServiceRec_
		{
			public PS_Table_FuncsRec_* ps_table_funcs;
			public PS_Parser_FuncsRec_* ps_parser_funcs;
			public T1_Builder_FuncsRec_* t1_builder_funcs;
			public T1_Decoder_FuncsRec_* t1_decoder_funcs;
			public delegate void t1_decrypt_func(unsigned char* a, unsigned long long b, unsigned short c); public t1_decrypt_func t1_decrypt;
			public delegate unsigned int cff_random_func(unsigned int a); public cff_random_func cff_random;
			public delegate void ps_decoder_init_func(PS_Decoder_* a, void* b, unsigned char c); public ps_decoder_init_func ps_decoder_init;
			public delegate void t1_make_subfont_func(FT_FaceRec_ a, PS_PrivateRec_* b, CFF_SubFontRec_* c); public t1_make_subfont_func t1_make_subfont;
			public T1_CMap_ClassesRec_* t1_cmap_classes;
			public AFM_Parser_FuncsRec_* afm_parser_funcs;
			public CFF_Decoder_FuncsRec_* cff_decoder_funcs;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Service_PropertiesRec_
		{
			public delegate int set_property_func(FT_ModuleRec_ a, char* b, void* c, unsigned char d); public set_property_func set_property;
			public delegate int get_property_func(FT_ModuleRec_ a, char* b, void* c); public get_property_func get_property;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Service_SFNT_TableRec_
		{
			public delegate int load_table_func(FT_FaceRec_ a, unsigned long b, long c, unsigned char* d, unsigned long* e); public load_table_func load_table;
			public delegate void* get_table_func(FT_FaceRec_ a,  enum FT_Sfnt_Tag_ b);public get_table_func get_table;
			public delegate int table_info_func(FT_FaceRec_ a, unsigned int b, unsigned long* c, unsigned long* d, unsigned long* e); public table_info_func table_info;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Service_PsFontNameRec_
		{
			public delegate const char* get_ps_font_name_func(FT_FaceRec_ a); public get_ps_font_name_func get_ps_font_name;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Service_GlyphDictRec_
		{
			public delegate int get_name_func(FT_FaceRec_ a, unsigned int b, void* c, unsigned int d); public get_name_func get_name;
			public delegate unsigned int name_index_func(FT_FaceRec_ a, char* b); public name_index_func name_index;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct TT_CMapInfo_
		{
			public int language;
			public int format;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Service_TTCMapsRec_
		{
			public delegate int get_cmap_info_func(FT_CharMapRec_ a, TT_CMapInfo_* b); public get_cmap_info_func get_cmap_info;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Service_KerningRec_
		{
			public delegate int get_track_func(FT_FaceRec_ a, long b, int c, long* d); public get_track_func get_track;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Service_TrueTypeEngineRec_
		{
			public int engine_type;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Prop_GlyphToScriptMap_
		{
			public FT_FaceRec_ face;
			public ushort* map;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_Prop_IncreaseXHeight_
		{
			public FT_FaceRec_ face;
			public uint limit;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_SfntName_
		{
			public ushort platform_id;
			public ushort encoding_id;
			public ushort language_id;
			public ushort name_id;
			public byte* _string_;
			public uint string_len;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct FT_SfntLangTag_
		{
			public byte* _string_;
			public uint string_len;
		}
		public static int _ft_face_scale_advances(FT_FaceRec_ face, int* advances, uint count, int flags)
		{
			int scale = 0;
			uint nn = 0;
			if ((flags & (1 << 0)) != 0)
				return (int)(FT_Err_Ok);
			if (face.size == null)
				return (int)(FT_Err_Invalid_Size_Handle);
			if ((flags & (1 << 4)) != 0)
				scale = (int)(face.size->metrics.y_scale);
			else
				scale = (int)(face.size->metrics.x_scale);
			for (nn = (uint)(0); (nn) < (count); nn++)
			{ advances[nn] = (int)(FT_MulDiv((int)(advances[nn]), (int)(scale), (int)(64))); }
			return (int)(FT_Err_Ok);
		}

		public static int FT_Get_Advance(FT_FaceRec_ face, uint gindex, int flags, int* padvance)
		{
			int(FT_FaceRec_ *, unsigned int, unsigned int, int, long *) * func;
			if (face == null)
				return (int)(FT_Err_Invalid_Face_Handle);
			if (padvance == null)
				return (int)(FT_Err_Invalid_Argument);
			if ((gindex) >= ((uint)(face.num_glyphs)))
				return (int)(FT_Err_Invalid_Glyph_Index);
			func = face.driver->clazz->get_advances;
			if (((func) != null) && (((flags & ((1 << 0) | (1 << 1))) != 0) || ((((flags) >> 16) & 15) == (FT_RENDER_MODE_LIGHT))))
			{
				int error = 0;
				error = (int)(func(face, (uint)(gindex), (uint)(1), (int)(flags), padvance));
				if (error == 0)
					return (int)(_ft_face_scale_advances(face, padvance, (uint)(1), (int)(flags)));
				if ((((error) & 255) != ((FT_Err_Unimplemented_Feature) & 255)))
					return (int)(error);
			}

			return (int)(FT_Get_Advances(face, (uint)(gindex), (uint)(1), (int)(flags), padvance));
		}

		public static int FT_Get_Advances(FT_FaceRec_ face, uint start, uint count, int flags, int* padvances)
		{
			int error = (int)(FT_Err_Ok);
			int(FT_FaceRec_ *, unsigned int, unsigned int, int, long *) * func;
			uint num = 0;
			uint end = 0;
			uint nn = 0;
			int factor = 0;
			if (face == null)
				return (int)(FT_Err_Invalid_Face_Handle);
			if (padvances == null)
				return (int)(FT_Err_Invalid_Argument);
			num = ((uint)(face.num_glyphs));
			end = (uint)(start + count);
			if ((((start) >= (num)) || ((end) < (start))) || ((end) > (num)))
				return (int)(FT_Err_Invalid_Glyph_Index);
			if ((count) == (0))
				return (int)(FT_Err_Ok);
			func = face.driver->clazz->get_advances;
			if (((func) != null) && (((flags & ((1 << 0) | (1 << 1))) != 0) || ((((flags) >> 16) & 15) == (FT_RENDER_MODE_LIGHT))))
			{
				error = (int)(func(face, (uint)(start), (uint)(count), (int)(flags), padvances));
				if (error == 0)
					return (int)(_ft_face_scale_advances(face, padvances, (uint)(count), (int)(flags)));
				if ((((error) & 255) != ((FT_Err_Unimplemented_Feature) & 255)))
					return (int)(error);
			}

			error = (int)(FT_Err_Ok);
			if ((flags & 536870912) != 0)
				return (int)(FT_Err_Unimplemented_Feature);
			flags |= (int)((uint)(1 << 8));
			factor = (int)((flags & (1 << 0)) ? 1 : 1024);
			for (nn = (uint)(0); (nn) < (count); nn++)
			{
				error = (int)(FT_Load_Glyph(face, (uint)(start + nn), (int)(flags)));
				if ((error) != 0)
					break;
				padvances[nn] = (int)((flags & (1 << 4)) ? face.glyph->advance.y * factor : face.glyph->advance.x * factor);
			}
			return (int)(error);
		}

		public static int FT_RoundFix(int a)
		{
			return (int)(((a) + (0x8000 - ((a) < (0)))) & ~0xFFFF);
		}

		public static int FT_CeilFix(int a)
		{
			return (int)(((a) + (0xFFFF)) & ~0xFFFF);
		}

		public static int FT_FloorFix(int a)
		{
			return (int)(a & ~0xFFFF);
		}

		public static int FT_Hypot(int x, int y)
		{
			FT_Vector_ v = new FT_Vector_();
			v.x = (int)(x);
			v.y = (int)(y);
			return (int)(FT_Vector_Length(&v));
		}

		public static int FT_MulDiv(int a_, int b_, int c_)
		{
			int s = (int)(1);
			ulong a = 0;
			ulong b = 0;
			ulong c = 0;
			ulong d = 0;
			int d_ = 0;
			a = ((ulong)(a_));
			b = ((ulong)(b_));
			c = ((ulong)(c_));
			do
			{
				if ((a_) < (0))
				{
					a = (ulong)(0U - (a));
					s = (int)(-s);
				}
			}
			while ((0) != 0);
			do
			{
				if ((b_) < (0))
				{
					b = (ulong)(0U - (b));
					s = (int)(-s);
				}
			}
			while ((0) != 0);
			do
			{
				if ((c_) < (0))
				{
					c = (ulong)(0U - (c));
					s = (int)(-s);
				}
			}
			while ((0) != 0);
			d = (ulong)((c) > (0) ? (a * b + (c >> 1)) / c : 0x7FFFFFFFU);
			d_ = ((int)(d));
			return (int)((s) < (0) ? (0 - (d_)) : d_);
		}

		public static int FT_MulDiv_No_Round(int a_, int b_, int c_)
		{
			int s = (int)(1);
			ulong a = 0;
			ulong b = 0;
			ulong c = 0;
			ulong d = 0;
			int d_ = 0;
			a = ((ulong)(a_));
			b = ((ulong)(b_));
			c = ((ulong)(c_));
			do
			{
				if ((a_) < (0))
				{
					a = (ulong)(0U - (a));
					s = (int)(-s);
				}
			}
			while ((0) != 0);
			do
			{
				if ((b_) < (0))
				{
					b = (ulong)(0U - (b));
					s = (int)(-s);
				}
			}
			while ((0) != 0);
			do
			{
				if ((c_) < (0))
				{
					c = (ulong)(0U - (c));
					s = (int)(-s);
				}
			}
			while ((0) != 0);
			d = (ulong)((c) > (0) ? a * b / c : 0x7FFFFFFFU);
			d_ = ((int)(d));
			return (int)((s) < (0) ? (0 - (d_)) : d_);
		}

		public static int FT_MulFix(int a_, int b_)
		{
			long ab = (long)((long)(a_) * (long)(b_));
			return (int)((ab + 0x8000 - ((ab) < (0))) >> 16);
		}

		public static int FT_DivFix(int a_, int b_)
		{
			int s = (int)(1);
			ulong a = 0;
			ulong b = 0;
			ulong q = 0;
			int q_ = 0;
			a = ((ulong)(a_));
			b = ((ulong)(b_));
			do
			{
				if ((a_) < (0))
				{
					a = (ulong)(0U - (a));
					s = (int)(-s);
				}
			}
			while ((0) != 0);
			do
			{
				if ((b_) < (0))
				{
					b = (ulong)(0U - (b));
					s = (int)(-s);
				}
			}
			while ((0) != 0);
			q = (ulong)((b) > (0) ? ((a << 16) + (b >> 1)) / b : 0x7FFFFFFFU);
			q_ = ((int)(q));
			return (int)((s) < (0) ? (0 - (q_)) : q_);
		}

		public static void FT_Matrix_Multiply(FT_Matrix_* a, FT_Matrix_* b)
		{
			int xx = 0;
			int xy = 0;
			int yx = 0;
			int yy = 0;
			if ((a == null) || (b == null))
				return;
			xx = (int)((FT_MulFix((int)(a->xx), (int)(b->xx))) + (FT_MulFix((int)(a->xy), (int)(b->yx))));
			xy = (int)((FT_MulFix((int)(a->xx), (int)(b->xy))) + (FT_MulFix((int)(a->xy), (int)(b->yy))));
			yx = (int)((FT_MulFix((int)(a->yx), (int)(b->xx))) + (FT_MulFix((int)(a->yy), (int)(b->yx))));
			yy = (int)((FT_MulFix((int)(a->yx), (int)(b->xy))) + (FT_MulFix((int)(a->yy), (int)(b->yy))));
			b->xx = (int)(xx);
			b->xy = (int)(xy);
			b->yx = (int)(yx);
			b->yy = (int)(yy);
		}

		public static int FT_Matrix_Invert(FT_Matrix_* matrix)
		{
			int delta = 0;
			int xx = 0;
			int yy = 0;
			if (matrix == null)
				return (int)(FT_Err_Invalid_Argument);
			delta = (int)(FT_MulFix((int)(matrix->xx), (int)(matrix->yy)) - FT_MulFix((int)(matrix->xy), (int)(matrix->yx)));
			if (delta == 0)
				return (int)(FT_Err_Invalid_Argument);
			matrix->xy = (int)(-FT_DivFix((int)(matrix->xy), (int)(delta)));
			matrix->yx = (int)(-FT_DivFix((int)(matrix->yx), (int)(delta)));
			xx = (int)(matrix->xx);
			yy = (int)(matrix->yy);
			matrix->xx = (int)(FT_DivFix((int)(yy), (int)(delta)));
			matrix->yy = (int)(FT_DivFix((int)(xx), (int)(delta)));
			return (int)(FT_Err_Ok);
		}

		public static void FT_Matrix_Multiply_Scaled(FT_Matrix_* a, FT_Matrix_* b, int scaling)
		{
			int xx = 0;
			int xy = 0;
			int yx = 0;
			int yy = 0;
			int val = (int)(0x10000 * scaling);
			if ((a == null) || (b == null))
				return;
			xx = (int)((FT_MulDiv((int)(a->xx), (int)(b->xx), (int)(val))) + (FT_MulDiv((int)(a->xy), (int)(b->yx), (int)(val))));
			xy = (int)((FT_MulDiv((int)(a->xx), (int)(b->xy), (int)(val))) + (FT_MulDiv((int)(a->xy), (int)(b->yy), (int)(val))));
			yx = (int)((FT_MulDiv((int)(a->yx), (int)(b->xx), (int)(val))) + (FT_MulDiv((int)(a->yy), (int)(b->yx), (int)(val))));
			yy = (int)((FT_MulDiv((int)(a->yx), (int)(b->xy), (int)(val))) + (FT_MulDiv((int)(a->yy), (int)(b->yy), (int)(val))));
			b->xx = (int)(xx);
			b->xy = (int)(xy);
			b->yx = (int)(yx);
			b->yy = (int)(yy);
		}

		public static byte FT_Matrix_Check(FT_Matrix_* matrix)
		{
			FT_Matrix_ m = new FT_Matrix_();
			int* val = stackalloc int[4];
			int nonzero_minval = 0;
			int maxval = 0;
			int temp1 = 0;
			int temp2 = 0;
			uint i = 0;
			if (matrix == null)
				return (byte)(0);
			val[0] = (int)((matrix->xx) < (0) ? -(matrix->xx) : (matrix->xx));
			val[1] = (int)((matrix->xy) < (0) ? -(matrix->xy) : (matrix->xy));
			val[2] = (int)((matrix->yx) < (0) ? -(matrix->yx) : (matrix->yx));
			val[3] = (int)((matrix->yy) < (0) ? -(matrix->yy) : (matrix->yy));
			maxval = (int)(0);
			nonzero_minval = (int)(2147483647);
			for (i = (uint)(0); (i) < (4); i++)
			{
				if ((val[i]) > (maxval))
					maxval = (int)(val[i]);
				if (((val[i]) != 0) && ((val[i]) < (nonzero_minval)))
					nonzero_minval = (int)(val[i]);
			}
			if ((maxval) > (0x7FFFFFFF))
				return (byte)(0);
			if ((maxval) > (23170))
			{
				int scale = (int)(FT_DivFix((int)(maxval), (int)(23170)));
				if (FT_DivFix((int)(nonzero_minval), (int)(scale)) == 0)
					return (byte)(0);
				m.xx = (int)(FT_DivFix((int)(matrix->xx), (int)(scale)));
				m.xy = (int)(FT_DivFix((int)(matrix->xy), (int)(scale)));
				m.yx = (int)(FT_DivFix((int)(matrix->yx), (int)(scale)));
				m.yy = (int)(FT_DivFix((int)(matrix->yy), (int)(scale)));
			}
			else
				m = (FT_Matrix_)(*matrix);
			temp1 = (int)((m.xx * m.yy - m.xy * m.yx) < (0) ? -(m.xx * m.yy - m.xy * m.yx) : (m.xx * m.yy - m.xy * m.yx));
			temp2 = (int)(m.xx * m.xx + m.xy * m.xy + m.yx * m.yx + m.yy * m.yy);
			if (((temp1) == (0)) || ((temp2 / temp1) > (50)))
				return (byte)(0);
			return (byte)(1);
		}

		public static void FT_Vector_Transform_Scaled(FT_Vector_* vector, FT_Matrix_* matrix, int scaling)
		{
			int xz = 0;
			int yz = 0;
			int val = (int)(0x10000 * scaling);
			if ((vector == null) || (matrix == null))
				return;
			xz = (int)((FT_MulDiv((int)(vector->x), (int)(matrix->xx), (int)(val))) + (FT_MulDiv((int)(vector->y), (int)(matrix->xy), (int)(val))));
			yz = (int)((FT_MulDiv((int)(vector->x), (int)(matrix->yx), (int)(val))) + (FT_MulDiv((int)(vector->y), (int)(matrix->yy), (int)(val))));
			vector->x = (int)(xz);
			vector->y = (int)(yz);
		}

		public static uint FT_Vector_NormLen(FT_Vector_* vector)
		{
			int x_ = (int)(vector->x);
			int y_ = (int)(vector->y);
			int b = 0;
			int z = 0;
			uint x = 0;
			uint y = 0;
			uint u = 0;
			uint v = 0;
			uint l = 0;
			int sx = (int)(1);
			int sy = (int)(1);
			int shift = 0;
			x = ((uint)(x_));
			y = ((uint)(y_));
			do
			{
				if ((x_) < (0))
				{
					x = (uint)(0U - (x));
					sx = (int)(-sx);
				}
			}
			while ((0) != 0);
			do
			{
				if ((y_) < (0))
				{
					y = (uint)(0U - (y));
					sy = (int)(-sy);
				}
			}
			while ((0) != 0);
			if ((x) == (0))
			{
				if ((y) > (0))
					vector->y = (int)(sy * 0x10000);
				return (uint)(y);
			}
			else if ((y) == (0))
			{
				if ((x) > (0))
					vector->x = (int)(sx * 0x10000);
				return (uint)(x);
			}

			l = (uint)((x) > (y) ? x + (y >> 1) : y + (x >> 1));
			shift = (int)(31 - (FT_MSB_i386((uint)(l))));
			shift -= (int)(15 + ((l) >= (0xAAAAAAAAU >> shift)));
			if ((shift) > (0))
			{
				x <<= shift;
				y <<= shift;
				l = (uint)((x) > (y) ? x + (y >> 1) : y + (x >> 1));
			}
			else
			{
				x >>= -shift;
				y >>= -shift;
				l >>= -shift;
			}

			b = (int)(0x10000 - (int)(l));
			x_ = ((int)(x));
			y_ = ((int)(y));
			do
			{
				u = ((uint)(x_ + (x_ * b >> 16)));
				v = ((uint)(y_ + (y_ * b >> 16)));
				z = (int)(-(int)(u * u + v * v) / 0x200);
				z = (int)(z * ((0x10000 + b) >> 8) / 0x10000);
				b += (int)(z);
			}
			while ((z) > (0));
			vector->x = (int)((sx) < (0) ? -(int)(u) : (int)(u));
			vector->y = (int)((sy) < (0) ? -(int)(v) : (int)(v));
			l = ((uint)(0x10000 + (int)(u * x + v * y) / 0x10000));
			if ((shift) > (0))
				l = (uint)((l + (1 << (shift - 1))) >> shift);
			else
				l <<= -shift;
			return (uint)(l);
		}

		public static int ft_corner_orientation(int in_x, int in_y, int out_x, int out_y)
		{
			long delta = (long)((ulong)((long)((ulong)(in_x) * (ulong)(out_y))) - (ulong)((long)((ulong)(in_y) * (ulong)(out_x))));
			return (int)(((delta) > (0)) - ((delta) < (0)));
		}

		public static int ft_corner_is_flat(int in_x, int in_y, int out_x, int out_y)
		{
			int ax = (int)(in_x + out_x);
			int ay = (int)(in_y + out_y);
			int d_in = 0;
			int d_out = 0;
			int d_hypot = 0;
			d_in = (int)(in_x = (int)((in_x) < (0) ? -(in_x) : (in_x)), in_y = (int)((in_y) < (0) ? -(in_y) : (in_y)), (in_x) > (in_y) ? in_x + (3 * in_y >> 3) : in_y + (3 * in_x >> 3));
			d_out = (int)(out_x = (int)((out_x) < (0) ? -(out_x) : (out_x)), out_y = (int)((out_y) < (0) ? -(out_y) : (out_y)), (out_x) > (out_y) ? out_x + (3 * out_y >> 3) : out_y + (3 * out_x >> 3));
			d_hypot = (int)(ax = (int)((ax) < (0) ? -(ax) : (ax)), ay = (int)((ay) < (0) ? -(ay) : (ay)), (ax) > (ay) ? ax + (3 * ay >> 3) : ay + (3 * ax >> 3));
			return (int)((d_in + d_out - d_hypot) < (d_hypot >> 4) ? 1 : 0);
		}

		public static int FT_Palette_Data_Get(FT_FaceRec_ face, FT_Palette_Data_* apalette_data)
		{
			if (face == null)
				return (int)(FT_Err_Invalid_Face_Handle);
			if (apalette_data == null)
				return (int)(FT_Err_Invalid_Argument);
			if ((!!((face).face_flags & (1 << 3))))
				*apalette_data = (FT_Palette_Data_)(((TT_FaceRec_*)(face))->palette_data);
			else
				*apalette_data = (FT_Palette_Data_)(null_palette_data);
			return (int)(FT_Err_Ok);
		}

		public static int FT_Palette_Select(FT_FaceRec_ face, ushort palette_index, FT_Color_** apalette)
		{
			int error = 0;
			TT_FaceRec_* ttface;
			SFNT_Interface_* sfnt;
			if (face == null)
				return (int)(FT_Err_Invalid_Face_Handle);
			if (!(!!((face).face_flags & (1 << 3))))
			{
				if ((apalette) != null)
					*apalette = null;
				return (int)(FT_Err_Ok);
			}

			ttface = (TT_FaceRec_*)(face);
			sfnt = (SFNT_Interface_*)(ttface->sfnt);
			error = (int)(sfnt->set_palette(ttface, (uint)(palette_index)));
			if ((error) != 0)
				return (int)(error);
			ttface->palette_index = (ushort)(palette_index);
			if ((apalette) != null)
				*apalette = ttface->palette;
			return (int)(FT_Err_Ok);
		}

		public static int FT_Palette_Set_Foreground_Color(FT_FaceRec_ face, FT_Color_ foreground_color)
		{
			TT_FaceRec_* ttface;
			if (face == null)
				return (int)(FT_Err_Invalid_Face_Handle);
			if (!(!!((face).face_flags & (1 << 3))))
				return (int)(FT_Err_Ok);
			ttface = (TT_FaceRec_*)(face);
			ttface->foreground_color = (FT_Color_)(foreground_color);
			ttface->have_foreground_color = (byte)(1);
			return (int)(FT_Err_Ok);
		}

		public static sbyte* FT_Error_String(int error_code)
		{
			if (((error_code) < (0)) || ((error_code) >= (FT_Err_Max)))
				return null;
			return null;
		}

		public static sbyte* FT_Get_Font_Format(FT_FaceRec_ face)
		{
			sbyte* result = null;
			if ((face) != null)
				do
				{
					FT_ModuleRec_ module = ((FT_ModuleRec_)((face).driver));
					void* _tmp_ = null;
					if ((module.clazz.get_interface) != null)
						_tmp_ = module.clazz.get_interface(module, "font-format");
					result = _tmp_;
				}
				while ((0) != 0);
			return result;
		}

		public static sbyte* FT_Get_X11_Font_Format(FT_FaceRec_ face)
		{
			sbyte* result = null;
			if ((face) != null)
				do
				{
					FT_ModuleRec_ module = ((FT_ModuleRec_)((face).driver));
					void* _tmp_ = null;
					if ((module.clazz.get_interface) != null)
						_tmp_ = module.clazz.get_interface(module, "font-format");
					result = _tmp_;
				}
				while ((0) != 0);
			return result;
		}

		public static int FT_GlyphLoader_New(FT_MemoryRec_ memory, FT_GlyphLoaderRec_** aloader)
		{
			FT_GlyphLoaderRec_* loader = null;
			int error = 0;
			if (!(((loader) = (ft_mem_alloc(memory, (int)(sizeof((*(loader)))), &error))) , error != 0)) {
				loader->memory = memory;
				*aloader = loader;
			}

			return (int)(error);
		}

		public static void FT_GlyphLoader_Rewind(FT_GlyphLoaderRec_* loader)
		{
			FT_GlyphLoadRec_* _base_ = &loader->_base_;
			FT_GlyphLoadRec_* current = &loader->current;
			_base_->outline.n_points = (short)(0);
			_base_->outline.n_contours = (short)(0);
			_base_->outline.flags = (int)(0);
			_base_->num_subglyphs = (uint)(0);
			*current = (FT_GlyphLoadRec_)(*_base_);
		}

		public static void FT_GlyphLoader_Reset(FT_GlyphLoaderRec_* loader)
		{
			FT_MemoryRec_ memory = loader->memory;
			do
			{
				(ft_mem_free(memory, (loader->_base_.outline.points)));
				(loader->_base_.outline.points) = null;
			}
			while ((0) != 0);
			do
			{
				(ft_mem_free(memory, (loader->_base_.outline.tags)));
				(loader->_base_.outline.tags) = null;
			}
			while ((0) != 0);
			do
			{
				(ft_mem_free(memory, (loader->_base_.outline.contours)));
				(loader->_base_.outline.contours) = null;
			}
			while ((0) != 0);
			do
			{
				(ft_mem_free(memory, (loader->_base_.extra_points)));
				(loader->_base_.extra_points) = null;
			}
			while ((0) != 0);
			do
			{
				(ft_mem_free(memory, (loader->_base_.subglyphs)));
				(loader->_base_.subglyphs) = null;
			}
			while ((0) != 0);
			loader->_base_.extra_points2 = null;
			loader->max_points = (uint)(0);
			loader->max_contours = (uint)(0);
			loader->max_subglyphs = (uint)(0);
			FT_GlyphLoader_Rewind(loader);
		}

		public static void FT_GlyphLoader_Done(FT_GlyphLoaderRec_* loader)
		{
			if ((loader) != null)
			{
				FT_MemoryRec_ memory = loader->memory;
				FT_GlyphLoader_Reset(loader);
				do
				{
					(ft_mem_free(memory, (loader)));
					(loader) = null;
				}
				while ((0) != 0);
			}

		}

		public static void FT_GlyphLoader_Adjust_Points(FT_GlyphLoaderRec_* loader)
		{
			FT_Outline_* _base_ = &loader->_base_.outline;
			FT_Outline_* current = &loader->current.outline;
			current->points = ((_base_->points) ? (_base_->points) + (_base_->n_points) : null);
			current->tags = ((_base_->tags) ? (_base_->tags) + (_base_->n_points) : null);
			current->contours = ((_base_->contours) ? (_base_->contours) + (_base_->n_contours) : null);
			if ((loader->use_extra) != 0)
			{
				loader->current.extra_points = loader->_base_.extra_points + _base_->n_points;
				loader->current.extra_points2 = loader->_base_.extra_points2 + _base_->n_points;
			}

		}

		public static int FT_GlyphLoader_CreateExtra(FT_GlyphLoaderRec_* loader)
		{
			int error = 0;
			FT_MemoryRec_ memory = loader->memory;
			if (((loader->max_points) == (0)) || (loader->_base_.extra_points != null))
				return (int)(FT_Err_Ok);
			if (!(((loader->_base_.extra_points) = (ft_mem_realloc(memory, (int)(sizeof((*(loader->_base_.extra_points)))), (int)(0), (int)(2 * loader->max_points), null, &error))) , error != 0)) {
				loader->use_extra = (byte)(1);
				loader->_base_.extra_points2 = loader->_base_.extra_points + loader->max_points;
				FT_GlyphLoader_Adjust_Points(loader);
			}

			return (int)(error);
		}

		public static void FT_GlyphLoader_Adjust_Subglyphs(FT_GlyphLoaderRec_* loader)
		{
			FT_GlyphLoadRec_* _base_ = &loader->_base_;
			FT_GlyphLoadRec_* current = &loader->current;
			current->subglyphs = ((_base_->subglyphs) ? (_base_->subglyphs) + (_base_->num_subglyphs) : null);
		}

		public static int FT_GlyphLoader_CheckPoints(FT_GlyphLoaderRec_* loader, uint n_points, uint n_contours)
		{
			FT_MemoryRec_ memory = loader->memory;
			int error = (int)(FT_Err_Ok);
			FT_Outline_* _base_ = &loader->_base_.outline;
			FT_Outline_* current = &loader->current.outline;
			byte adjust = (byte)(0);
			uint new_max = 0;
			uint old_max = 0;
			error = (int)(FT_GlyphLoader_CreateExtra(loader));
			if ((error) != 0)
				return (int)(error);
			new_max = (uint)((uint)(_base_->n_points) + (uint)(current->n_points) + n_points);
			old_max = (uint)(loader->max_points);
			if ((new_max) > (old_max))
			{
				new_max = (uint)(((new_max) + (8) - 1) & ~((8) - 1));
				if ((new_max) > (32767))
					return (int)(FT_Err_Array_Too_Large);
				if ((((_base_->points) = (ft_mem_realloc(memory, (int)(sizeof((*(_base_->points)))), (int)(old_max), (int)(new_max), (_base_->points), &error))) , error != 0) || (((_base_->tags) = (ft_mem_realloc(memory, (int)(sizeof((*(_base_->tags)))), (int)(old_max), (int)(new_max), (_base_->tags), &error))) , error != 0)) goto Exit;
				if ((loader->use_extra) != 0)
				{
					if ((((loader->_base_.extra_points) = (ft_mem_realloc(memory, (int)(sizeof((*(loader->_base_.extra_points)))), (int)(old_max * 2), (int)(new_max * 2), (loader->_base_.extra_points), &error))) , error != 0)) goto Exit;
					CRuntime.memmove(loader->_base_.extra_points + new_max, loader->_base_.extra_points + old_max, (ulong)((ulong)(old_max) * sizeof((*(loader->_base_.extra_points + new_max)))));
					loader->_base_.extra_points2 = loader->_base_.extra_points + new_max;
				}
				adjust = (byte)(1);
				loader->max_points = (uint)(new_max);
			}

			error = (int)(FT_GlyphLoader_CreateExtra(loader));
			if ((error) != 0)
				return (int)(error);
			old_max = (uint)(loader->max_contours);
			new_max = (uint)((uint)(_base_->n_contours) + (uint)(current->n_contours) + n_contours);
			if ((new_max) > (old_max))
			{
				new_max = (uint)(((new_max) + (4) - 1) & ~((4) - 1));
				if ((new_max) > (32767))
					return (int)(FT_Err_Array_Too_Large);
				if ((((_base_->contours) = (ft_mem_realloc(memory, (int)(sizeof((*(_base_->contours)))), (int)(old_max), (int)(new_max), (_base_->contours), &error))) , error != 0)) goto Exit;
				adjust = (byte)(1);
				loader->max_contours = (uint)(new_max);
			}

			if ((adjust) != 0)
				FT_GlyphLoader_Adjust_Points(loader);
			Exit:
			;
			if ((error) != 0)
				FT_GlyphLoader_Reset(loader);
			return (int)(error);
		}

		public static int FT_GlyphLoader_CheckSubGlyphs(FT_GlyphLoaderRec_* loader, uint n_subs)
		{
			FT_MemoryRec_ memory = loader->memory;
			int error = (int)(FT_Err_Ok);
			uint new_max = 0;
			uint old_max = 0;
			FT_GlyphLoadRec_* _base_ = &loader->_base_;
			FT_GlyphLoadRec_* current = &loader->current;
			new_max = (uint)(_base_->num_subglyphs + current->num_subglyphs + n_subs);
			old_max = (uint)(loader->max_subglyphs);
			if ((new_max) > (old_max))
			{
				new_max = (uint)(((new_max) + (2) - 1) & ~((2) - 1));
				if ((((_base_->subglyphs) = (ft_mem_realloc(memory, (int)(sizeof((*(_base_->subglyphs)))), (int)(old_max), (int)(new_max), (_base_->subglyphs), &error))) , error != 0)) goto Exit;
				loader->max_subglyphs = (uint)(new_max);
				FT_GlyphLoader_Adjust_Subglyphs(loader);
			}

		Exit:
			;
			return (int)(error);
		}

		public static void FT_GlyphLoader_Prepare(FT_GlyphLoaderRec_* loader)
		{
			FT_GlyphLoadRec_* current = &loader->current;
			current->outline.n_points = (short)(0);
			current->outline.n_contours = (short)(0);
			current->num_subglyphs = (uint)(0);
			FT_GlyphLoader_Adjust_Points(loader);
			FT_GlyphLoader_Adjust_Subglyphs(loader);
		}

		public static void FT_GlyphLoader_Add(FT_GlyphLoaderRec_* loader)
		{
			FT_GlyphLoadRec_* _base_;
			FT_GlyphLoadRec_* current;
			int n_curr_contours = 0;
			int n_base_points = 0;
			int n = 0;
			if (loader == null)
				return;
			_base_ = &loader->_base_;
			current = &loader->current;
			n_curr_contours = (int)(current->outline.n_contours);
			n_base_points = (int)(_base_->outline.n_points);
			_base_->outline.n_points = ((short)(_base_->outline.n_points + current->outline.n_points));
			_base_->outline.n_contours = ((short)(_base_->outline.n_contours + current->outline.n_contours));
			_base_->num_subglyphs += (uint)(current->num_subglyphs);
			for (n = (int)(0); (n) < (n_curr_contours); n++)
			{ current->outline.contours[n] = ((short)(current->outline.contours[n] + n_base_points)); }
			FT_GlyphLoader_Prepare(loader);
		}

		public static int hash_str_lookup(union FT_Hashkey_* key)
		{
			sbyte* kp = key->str;
			int res = (int)(0);
			while ((*kp) != 0)
			{ res = (int)((res << 5) - res + (int)(*kp++)); }
			return (int)(res);
		}

		public static int hash_num_lookup(union FT_Hashkey_* key)
		{
			int num = (int)(key->num);
			int res = 0;
			res = (int)(num & 0xFF);
			res = (int)((res << 5) - res + ((num >> 8) & 0xFF));
			res = (int)((res << 5) - res + ((num >> 16) & 0xFF));
			res = (int)((res << 5) - res + ((num >> 24) & 0xFF));
			return (int)(res);
		}

		public static byte hash_str_compare(union FT_Hashkey_* a, union FT_Hashkey_* b)
		{
			if (((a->str[0]) == (b->str[0])) && ((strcmp(a->str, b->str)) == (0)))
				return (byte)(1);
			return (byte)(0);
		}

		public static byte hash_num_compare(union FT_Hashkey_* a, union FT_Hashkey_* b)
		{
			if ((a->num) == (b->num))
				return (byte)(1);
			return (byte)(0);
		}

		public static FT_HashnodeRec_** hash_bucket(union FT_Hashkey_ key, FT_HashRec_* hash)
		{
			int res = (int)(0);
			FT_HashnodeRec_** bp = hash->table;
			FT_HashnodeRec_** ndp;
			res = (int)(hash->lookup(&key));
			ndp = bp + (res % hash->size);
			while ((*ndp) != null)
			{
				if ((hash->compare(&(*ndp)->key, &key)) != 0)
					break;
				ndp--;
				if ((ndp) < (bp))
					ndp = bp + (hash->size - 1);
			}
			return ndp;
		}

		public static int hash_rehash(FT_HashRec_* hash, FT_MemoryRec_ memory)
		{
			FT_HashnodeRec_** obp = hash->table;
			FT_HashnodeRec_** bp;
			FT_HashnodeRec_** nbp;
			uint i = 0;
			uint sz = (uint)(hash->size);
			int error = (int)(FT_Err_Ok);
			hash->size <<= 1;
			hash->limit = (uint)(hash->size / 3);
			if ((((hash->table) = (ft_mem_realloc(memory, (int)(sizeof((*(hash->table)))), (int)(0), (int)(hash->size), null, &error))) , error != 0)) goto Exit;
			for (i = (uint)(0), bp = obp; (i) < (sz); i++, bp++)
			{
				if ((*bp) != null)
				{
					nbp = hash_bucket((union FT_Hashkey_)((*bp)->key), hash);
			*nbp = *bp;
		}
	}
			do {
(ft_mem_free(memory, (obp)));(obp) = null;}
while ((0) != 0) ;
Exit:;
return (int)(error);
		}

		public static int hash_init(FT_HashRec_* hash, byte is_num, FT_MemoryRec_ memory)
{
	uint sz = (uint)(241);
	int error = 0;
	hash->size = (uint)(sz);
	hash->limit = (uint)(sz / 3);
	hash->used = (uint)(0);
	if ((is_num) != 0)
	{
		hash->lookup = hash_num_lookup;
		hash->compare = hash_num_compare;
	}
	else
	{
		hash->lookup = hash_str_lookup;
		hash->compare = hash_str_compare;
	}

			(hash->table) = (ft_mem_realloc(memory, (int)(sizeof((*(hash->table)))), (int)(0), (int)(sz), null, &error));
return (int)(error);
		}

		public static int ft_hash_str_init(FT_HashRec_* hash, FT_MemoryRec_ memory)
{
	return (int)(hash_init(hash, (byte)(0), memory));
}

public static int ft_hash_num_init(FT_HashRec_* hash, FT_MemoryRec_ memory)
{
	return (int)(hash_init(hash, (byte)(1), memory));
}

public static void ft_hash_str_free(FT_HashRec_* hash, FT_MemoryRec_ memory)
{
	if ((hash) != null)
	{
		uint sz = (uint)(hash->size);
		FT_HashnodeRec_** bp = hash->table;
		uint i = 0;
		for (i = (uint)(0); (i) < (sz); i++, bp++)
		{
			do
			{
				(ft_mem_free(memory, (*bp)));
				(*bp) = null;
			}
			while ((0) != 0);
		}
		do
		{
			(ft_mem_free(memory, (hash->table)));
			(hash->table) = null;
		}
		while ((0) != 0);
	}

}

public static int hash_insert(union FT_Hashkey_ key, ulong data, FT_HashRec_* hash, FT_MemoryRec_ memory)
{
	FT_HashnodeRec_* nn;
	FT_HashnodeRec_** bp = hash_bucket((union FT_Hashkey_)(key), hash);
int error = (int)(FT_Err_Ok);
nn = *bp;
if (nn == null)
{
	if ((((nn) = (ft_mem_alloc(memory, (int)(sizeof((*(nn)))), &error))) , error != 0)) goto Exit;
	*bp = nn;
	nn->key = (union FT_Hashkey_)(key);
	nn->data = (ulong)(data);
	if ((hash->used) >= (hash->limit))
	{
		error = (int)(hash_rehash(hash, memory));
		if ((error) != 0)
			goto Exit;
	}
	hash->used++;
}
else
	nn->data = (ulong)(data);
Exit:;
return (int)(error);
		}

		public static int ft_hash_str_insert(sbyte* key, ulong data, FT_HashRec_* hash, FT_MemoryRec_ memory)
{
	union FT_Hashkey_ hk = new union FT_Hashkey_();
	hk.str = key;
	return (int)(hash_insert((union FT_Hashkey_)(hk), (ulong)(data), hash, memory));
		}

		public static int ft_hash_num_insert(int num, ulong data, FT_HashRec_* hash, FT_MemoryRec_ memory)
{
	union FT_Hashkey_ hk = new union FT_Hashkey_();
	hk.num = (int)(num);
	return (int)(hash_insert((union FT_Hashkey_)(hk), (ulong)(data), hash, memory));
		}

		public static ulong* hash_lookup(union FT_Hashkey_ key, FT_HashRec_* hash)
{
	FT_HashnodeRec_** np = hash_bucket((union FT_Hashkey_)(key), hash);
return (*np) ? &(*np)->data : null;
		}

		public static ulong* ft_hash_str_lookup(sbyte* key, FT_HashRec_* hash)
{
	union FT_Hashkey_ hk = new union FT_Hashkey_();
	hk.str = key;
	return hash_lookup((union FT_Hashkey_)(hk), hash);
		}

		public static ulong* ft_hash_num_lookup(int num, FT_HashRec_* hash)
{
	union FT_Hashkey_ hk = new union FT_Hashkey_();
	hk.num = (int)(num);
	return hash_lookup((union FT_Hashkey_)(hk), hash);
		}

		public static void ft_lcd_padding(FT_BBox_* cbox, FT_GlyphSlotRec_* slot, int mode)
{
	FT_Vector_* sub = slot->library.lcd_geometry;
	if ((mode) == (FT_RENDER_MODE_LCD))
	{
		cbox->xMin -= (int)(((sub[0].x) > (sub[1].x) ? (sub[0].x) : (sub[1].x)) > (sub[2].x) ? ((sub[0].x) > (sub[1].x) ? (sub[0].x) : (sub[1].x)) : (sub[2].x));
		cbox->xMax -= (int)(((sub[0].x) < (sub[1].x) ? (sub[0].x) : (sub[1].x)) < (sub[2].x) ? ((sub[0].x) < (sub[1].x) ? (sub[0].x) : (sub[1].x)) : (sub[2].x));
		cbox->yMin -= (int)(((sub[0].y) > (sub[1].y) ? (sub[0].y) : (sub[1].y)) > (sub[2].y) ? ((sub[0].y) > (sub[1].y) ? (sub[0].y) : (sub[1].y)) : (sub[2].y));
		cbox->yMax -= (int)(((sub[0].y) < (sub[1].y) ? (sub[0].y) : (sub[1].y)) < (sub[2].y) ? ((sub[0].y) < (sub[1].y) ? (sub[0].y) : (sub[1].y)) : (sub[2].y));
	}
	else if ((mode) == (FT_RENDER_MODE_LCD_V))
	{
		cbox->xMin -= (int)(((sub[0].y) > (sub[1].y) ? (sub[0].y) : (sub[1].y)) > (sub[2].y) ? ((sub[0].y) > (sub[1].y) ? (sub[0].y) : (sub[1].y)) : (sub[2].y));
		cbox->xMax -= (int)(((sub[0].y) < (sub[1].y) ? (sub[0].y) : (sub[1].y)) < (sub[2].y) ? ((sub[0].y) < (sub[1].y) ? (sub[0].y) : (sub[1].y)) : (sub[2].y));
		cbox->yMin += (int)(((sub[0].x) < (sub[1].x) ? (sub[0].x) : (sub[1].x)) < (sub[2].x) ? ((sub[0].x) < (sub[1].x) ? (sub[0].x) : (sub[1].x)) : (sub[2].x));
		cbox->yMax += (int)(((sub[0].x) > (sub[1].x) ? (sub[0].x) : (sub[1].x)) > (sub[2].x) ? ((sub[0].x) > (sub[1].x) ? (sub[0].x) : (sub[1].x)) : (sub[2].x));
	}

}

public static int FT_Library_SetLcdFilterWeights(FT_LibraryRec_ library, byte* weights)
{
	((library) = (library));
	((weights) = (weights));
	return (int)(FT_Err_Unimplemented_Feature);
}

public static int FT_Library_SetLcdFilter(FT_LibraryRec_ library, int filter)
{
	((library) = (library));
	((filter) = (int)(filter));
	return (int)(FT_Err_Unimplemented_Feature);
}

public static int FT_Library_SetLcdGeometry(FT_LibraryRec_ library, FT_Vector_* sub)
{
	if (library == null)
		return (int)(FT_Err_Invalid_Library_Handle);
	if (sub == null)
		return (int)(FT_Err_Invalid_Argument);
	CRuntime.memcpy(library.lcd_geometry, sub, (ulong)(3 * sizeof(FT_Vector_)));
	return (int)(FT_Err_Unimplemented_Feature);
}

public static void* ft_service_list_lookup(FT_ServiceDescRec_* service_descriptors, sbyte* service_id)
{
	void* result = null;
	FT_ServiceDescRec_* desc = service_descriptors;
	if (((desc) != null) && ((service_id) != null))
	{
		for (; desc->serv_id != null; desc++)
		{
			if ((strcmp(desc->serv_id, service_id)) == (0))
			{
				result = desc->serv_data;
				break;
			}
		}
	}

	return result;
}

public static void ft_validator_init(volatile FT_ValidatorRec_* valid, byte* _base_, byte* limit, int level)
{
	valid->_base_ = _base_;
	valid->limit = limit;
	valid->level = (int)(level);
	valid->error = (int)(FT_Err_Ok);
}

public static int ft_validator_run(volatile FT_ValidatorRec_* valid)
{
	((valid) = (valid));
	return (int)(-1);
}

public static void ft_validator_error(volatile FT_ValidatorRec_* valid, int error)
{
	_SETJMP_FLOAT128[]*jump_buffer = &valid->jump_buffer;
	valid->error = (int)(error);
	longjmp(*jump_buffer, (int)(1));
}

public static int FT_Stream_New(FT_LibraryRec_ library, FT_Open_Args_* args, FT_StreamRec_ astream)
{
	int error = 0;
	FT_MemoryRec_ memory;
	FT_StreamRec_ stream = null;
	astream = null;
	if (library == null)
		return (int)(FT_Err_Invalid_Library_Handle);
	if (args == null)
		return (int)(FT_Err_Invalid_Argument);
	memory = library.memory;
	if ((((stream) = (ft_mem_alloc(memory, (int)(sizeof((stream))), &error))), error != 0))
		goto Exit;
	stream.memory = memory;
	if ((args->flags & 1) != 0)
	{
		FT_Stream_OpenMemory(stream, args->memory_base, (int)(args->memory_size));
	}
	else if ((args->flags & 4) != 0)
	{
		error = (int)(FT_Stream_Open(stream, args->pathname));
		stream.pathname.pointer = args->pathname;
	}
	else if (((args->flags & 2) != 0) && ((args->stream) != null))
	{
		do
		{
			(ft_mem_free(memory, (stream)));
			(stream) = null;
		}
		while ((0) != 0);
		stream = args->stream;
	}
	else
		error = (int)(FT_Err_Invalid_Argument);
	if ((error) != 0)
		do
		{
			(ft_mem_free(memory, (stream)));
			(stream) = null;
		}
		while ((0) != 0);
	else
		stream.memory = memory;
	astream = stream;
Exit:
	;
	return (int)(error);
}

public static void FT_Stream_Free(FT_StreamRec_ stream, int external)
{
	if ((stream) != null)
	{
		FT_MemoryRec_ memory = stream.memory;
		FT_Stream_Close(stream);
		if (external == 0)
			do
			{
				(ft_mem_free(memory, (stream)));
				(stream) = null;
			}
			while ((0) != 0);
	}

}

public static int ft_glyphslot_init(FT_GlyphSlotRec_* slot)
{
	FT_DriverRec_* driver = slot->face.driver;
	FT_Driver_ClassRec_* clazz = driver->clazz;
	FT_MemoryRec_ memory = driver->root.memory;
	int error = (int)(FT_Err_Ok);
	FT_Slot_InternalRec_ * internal = null;
slot->library = driver->root.library;
if ((((internal) = (ft_mem_alloc(memory, (int)(sizeof((*(internal)))), &error))) , error != 0)) goto Exit;
slot->internal = internal;
if ((((FT_ModuleRec_)(driver)).clazz.module_flags & 512) == 0) error = (int)(FT_GlyphLoader_New(memory, &internal->loader));
if ((error == 0) && ((clazz->init_slot) != null)) error = (int)(clazz->init_slot(slot));
Exit:;
return (int)(error);
		}

		public static void ft_glyphslot_free_bitmap(FT_GlyphSlotRec_* slot)
{
	if (((slot->internal) != null) && ((slot->internal->flags & 1)!= 0)) {
	FT_MemoryRec_ memory = (slot->face).memory;
	do
	{
		(ft_mem_free(memory, (slot->bitmap.buffer)));
		(slot->bitmap.buffer) = null;
	}
	while ((0) != 0);
	slot->internal->flags &= (uint)(~1);}
 else
{
	slot->bitmap.buffer = null;
}

		}

		public static byte ft_glyphslot_preset_bitmap(FT_GlyphSlotRec_* slot, int mode, FT_Vector_* origin)
{
	FT_Outline_* outline = &slot->outline;
	FT_Bitmap_* bitmap = &slot->bitmap;
	int pixel_mode = 0;
	FT_BBox_ cbox = new FT_BBox_();
	FT_BBox_ pbox = new FT_BBox_();
	int x_shift = (int)(0);
	int y_shift = (int)(0);
	int x_left = 0;
	int y_top = 0;
	int width = 0;
	int height = 0;
	int pitch = 0;
	if (slot->format != FT_GLYPH_FORMAT_OUTLINE)
		return (byte)(1);
	if ((origin) != null)
	{
		x_shift = (int)(origin->x);
		y_shift = (int)(origin->y);
	}

	FT_Outline_Get_CBox(outline, &cbox);
	pbox.xMin = (int)((cbox.xMin >> 6) + (x_shift >> 6));
	pbox.yMin = (int)((cbox.yMin >> 6) + (y_shift >> 6));
	pbox.xMax = (int)((cbox.xMax >> 6) + (x_shift >> 6));
	pbox.yMax = (int)((cbox.yMax >> 6) + (y_shift >> 6));
	cbox.xMin = (int)((cbox.xMin & 63) + (x_shift & 63));
	cbox.yMin = (int)((cbox.yMin & 63) + (y_shift & 63));
	cbox.xMax = (int)((cbox.xMax & 63) + (x_shift & 63));
	cbox.yMax = (int)((cbox.yMax & 63) + (y_shift & 63));
	switch (mode)
	{
		case FT_RENDER_MODE_MONO:
			pixel_mode = (int)(FT_PIXEL_MODE_MONO);
			pbox.xMin += (int)((cbox.xMin + 31) >> 6);
			pbox.xMax += (int)((cbox.xMax + 32) >> 6);
			if ((pbox.xMin) == (pbox.xMax))
			{
				if ((((cbox.xMin + 31) & 63) - 31 + ((cbox.xMax + 32) & 63) - 32) < (0))
					pbox.xMin -= (int)(1);
				else
					pbox.xMax += (int)(1);
			}
			pbox.yMin += (int)((cbox.yMin + 31) >> 6);
			pbox.yMax += (int)((cbox.yMax + 32) >> 6);
			if ((pbox.yMin) == (pbox.yMax))
			{
				if ((((cbox.yMin + 31) & 63) - 31 + ((cbox.yMax + 32) & 63) - 32) < (0))
					pbox.yMin -= (int)(1);
				else
					pbox.yMax += (int)(1);
			}
			break;
		case FT_RENDER_MODE_LCD:
			pixel_mode = (int)(FT_PIXEL_MODE_LCD);
			ft_lcd_padding(&cbox, slot, (int)(mode));
			goto Adjust;
		case FT_RENDER_MODE_LCD_V:
			pixel_mode = (int)(FT_PIXEL_MODE_LCD_V);
			ft_lcd_padding(&cbox, slot, (int)(mode));
			goto Adjust;
		case FT_RENDER_MODE_NORMAL:
		case FT_RENDER_MODE_LIGHT:
		default:
			pixel_mode = (int)(FT_PIXEL_MODE_GRAY);
		Adjust:
			;
			pbox.xMin += (int)(cbox.xMin >> 6);
			pbox.yMin += (int)(cbox.yMin >> 6);
			pbox.xMax += (int)((cbox.xMax + 63) >> 6);
			pbox.yMax += (int)((cbox.yMax + 63) >> 6);
	}

	x_left = (int)(pbox.xMin);
	y_top = (int)(pbox.yMax);
	width = (int)(pbox.xMax - pbox.xMin);
	height = (int)(pbox.yMax - pbox.yMin);
	switch (pixel_mode)
	{
		case FT_PIXEL_MODE_MONO:
			pitch = (int)(((width + 15) >> 4) << 1);
			break;
		case FT_PIXEL_MODE_LCD:
			width *= (int)(3);
			pitch = (int)(((width) + (4) - 1) & ~((4) - 1));
			break;
		case FT_PIXEL_MODE_LCD_V:
			height *= (int)(3);
		case FT_PIXEL_MODE_GRAY:
		default:
			pitch = (int)(width);
	}

	slot->bitmap_left = (int)(x_left);
	slot->bitmap_top = (int)(y_top);
	bitmap->pixel_mode = ((byte)(pixel_mode));
	bitmap->num_grays = (ushort)(256);
	bitmap->width = ((uint)(width));
	bitmap->rows = ((uint)(height));
	bitmap->pitch = (int)(pitch);
	if (((((pbox.xMin) < (-0x8000)) || ((pbox.xMax) > (0x7FFF))) || ((pbox.yMin) < (-0x8000))) || ((pbox.yMax) > (0x7FFF)))
	{
		do
		{
		}
		while ((0) != 0);
		return (byte)(1);
	}

	return (byte)(0);
}

public static void ft_glyphslot_set_bitmap(FT_GlyphSlotRec_* slot, byte* buffer)
{
	ft_glyphslot_free_bitmap(slot);
	slot->bitmap.buffer = buffer;
	do
	{
	}
	while ((0) != 0);
}

public static int ft_glyphslot_alloc_bitmap(FT_GlyphSlotRec_* slot, int size)
{
	FT_MemoryRec_ memory = (slot->face).memory;
	int error = 0;
	if ((slot->internal->flags & 1) != 0) do
{
	(ft_mem_free(memory, (slot->bitmap.buffer)));
	(slot->bitmap.buffer) = null;
}
while ((0) != 0); else slot->internal->flags |= (uint)(1);
(void)(((slot->bitmap.buffer) = (ft_mem_alloc(memory, (int)(size), &error))), error != 0);
return (int)(error);
		}

		public static void ft_glyphslot_clear(FT_GlyphSlotRec_* slot)
{
	ft_glyphslot_free_bitmap(slot);
	CRuntime.memset(&slot->metrics, (int)(0), (ulong)(sizeof((*(&slot->metrics)))));
CRuntime.memset(&slot->outline, (int)(0), (ulong)(sizeof((*(&slot->outline)))));
slot->bitmap.width = (uint)(0);
slot->bitmap.rows = (uint)(0);
slot->bitmap.pitch = (int)(0);
slot->bitmap.pixel_mode = (byte)(0);
slot->bitmap_left = (int)(0);
slot->bitmap_top = (int)(0);
slot->num_subglyphs = (uint)(0);
slot->subglyphs = null;
slot->control_data = null;
slot->control_len = (int)(0);
slot->other = null;
slot->format = (int)(FT_GLYPH_FORMAT_NONE);
slot->linearHoriAdvance = (int)(0);
slot->linearVertAdvance = (int)(0);
slot->lsb_delta = (int)(0);
slot->rsb_delta = (int)(0);
		}

		public static void ft_glyphslot_done(FT_GlyphSlotRec_* slot)
{
	FT_DriverRec_* driver = slot->face.driver;
	FT_Driver_ClassRec_* clazz = driver->clazz;
	FT_MemoryRec_ memory = driver->root.memory;
	if ((clazz->done_slot) != null)
		clazz->done_slot(slot);
	ft_glyphslot_free_bitmap(slot);
	if ((slot->internal) != null) {
	if ((((FT_ModuleRec_)(driver)).clazz.module_flags & 512) == 0)
	{
		FT_GlyphLoader_Done(slot->internal->loader);
slot->internal->loader = null;}
do
{
	(ft_mem_free(memory, (slot->internal)));
(slot->internal) = null;}
 while ((0) != 0) ;}

		}

		public static int FT_New_GlyphSlot(FT_FaceRec_ face, FT_GlyphSlotRec_** aslot)
{
	int error = 0;
	FT_DriverRec_* driver;
	FT_Driver_ClassRec_* clazz;
	FT_MemoryRec_ memory;
	FT_GlyphSlotRec_* slot = null;
	if (face == null)
		return (int)(FT_Err_Invalid_Face_Handle);
	if (face.driver == null)
		return (int)(FT_Err_Invalid_Argument);
	driver = face.driver;
	clazz = driver->clazz;
	memory = driver->root.memory;
	do
	{
	}
	while ((0) != 0);
	if (!(((slot) = (ft_mem_alloc(memory, (int)(clazz->slot_object_size), &error))), error != 0))
	{
		slot->face = face;
		error = (int)(ft_glyphslot_init(slot));
		if ((error) != 0)
		{
			ft_glyphslot_done(slot);
			do
			{
				(ft_mem_free(memory, (slot)));
				(slot) = null;
			}
			while ((0) != 0);
			goto Exit;
		}
		slot->next = face.glyph;
		face.glyph = slot;
		if ((aslot) != null)
			*aslot = slot;
	}
	else if ((aslot) != null)
		*aslot = null;
	Exit:
	;
	do
	{
	}
	while ((0) != 0);
	return (int)(error);
}

public static void FT_Done_GlyphSlot(FT_GlyphSlotRec_* slot)
{
	if ((slot) != null)
	{
		FT_DriverRec_* driver = slot->face.driver;
		FT_MemoryRec_ memory = driver->root.memory;
		FT_GlyphSlotRec_* prev;
		FT_GlyphSlotRec_* cur;
		prev = null;
		cur = slot->face.glyph;
		while ((cur) != null)
		{
			if ((cur) == (slot))
			{
				if (prev == null)
					slot->face.glyph = cur->next;
				else
					prev->next = cur->next;
				if ((slot->generic.finalizer) != null)
					slot->generic.finalizer(slot);
				ft_glyphslot_done(slot);
				do
				{
					(ft_mem_free(memory, (slot)));
					(slot) = null;
				}
				while ((0) != 0);
				break;
			}
			prev = cur;
			cur = cur->next;
		}
	}

}

public static void FT_Set_Transform(FT_FaceRec_ face, FT_Matrix_* matrix, FT_Vector_* delta)
{
	FT_Face_InternalRec_ * internal;
if (face == null) return;
internal = face.internal;
internal->transform_flags = (int)(0);
if (matrix == null)
{
internal->transform_matrix.xx = (int)(0x10000);
internal->transform_matrix.xy = (int)(0);
internal->transform_matrix.yx = (int)(0);
internal->transform_matrix.yy = (int)(0x10000);
matrix = &internal->transform_matrix;}
 else internal->transform_matrix = (FT_Matrix_)(*matrix);
if ((((matrix->xy | matrix->yx) != 0) || (matrix->xx != 0x10000)) || (matrix->yy != 0x10000)) internal->transform_flags |= (int)(1);
if (delta == null)
{
internal->transform_delta.x = (int)(0);
internal->transform_delta.y = (int)(0);
delta = &internal->transform_delta;}
 else internal->transform_delta = (FT_Vector_)(*delta);
if ((delta->x | delta->y) != 0) internal->transform_flags |= (int)(2);
		}

		public static void ft_glyphslot_grid_fit_metrics(FT_GlyphSlotRec_* slot, byte vertical)
{
	FT_Glyph_Metrics_* metrics = &slot->metrics;
	int right = 0;
	int bottom = 0;
	if ((vertical) != 0)
	{
		metrics->horiBearingX = (int)((metrics->horiBearingX) & ~63);
		metrics->horiBearingY = (int)(((metrics->horiBearingY) + (63)) & ~63);
		right = (int)((((metrics->vertBearingX) + (metrics->width)) + (63)) & ~63);
		bottom = (int)((((metrics->vertBearingY) + (metrics->height)) + (63)) & ~63);
		metrics->vertBearingX = (int)((metrics->vertBearingX) & ~63);
		metrics->vertBearingY = (int)((metrics->vertBearingY) & ~63);
		metrics->width = (int)((right) - (metrics->vertBearingX));
		metrics->height = (int)((bottom) - (metrics->vertBearingY));
	}
	else
	{
		metrics->vertBearingX = (int)((metrics->vertBearingX) & ~63);
		metrics->vertBearingY = (int)((metrics->vertBearingY) & ~63);
		right = (int)((((metrics->horiBearingX) + (metrics->width)) + (63)) & ~63);
		bottom = (int)(((metrics->horiBearingY) - (metrics->height)) & ~63);
		metrics->horiBearingX = (int)((metrics->horiBearingX) & ~63);
		metrics->horiBearingY = (int)(((metrics->horiBearingY) + (63)) & ~63);
		metrics->width = (int)((right) - (metrics->horiBearingX));
		metrics->height = (int)((metrics->horiBearingY) - (bottom));
	}

	metrics->horiAdvance = (int)(((metrics->horiAdvance) + (32)) & ~63);
	metrics->vertAdvance = (int)(((metrics->vertAdvance) + (32)) & ~63);
}

public static int FT_Load_Glyph(FT_FaceRec_ face, uint glyph_index, int load_flags)
{
	int error = 0;
	FT_DriverRec_* driver;
	FT_GlyphSlotRec_* slot;
	FT_LibraryRec_ library;
	byte autohint = (byte)(0);
	FT_ModuleRec_ hinter;
	TT_FaceRec_* ttface = (TT_FaceRec_*)(face);
	if (((face == null) || (face.size == null)) || (face.glyph == null))
		return (int)(FT_Err_Invalid_Face_Handle);
	slot = face.glyph;
	ft_glyphslot_clear(slot);
	driver = face.driver;
	library = driver->root.library;
	hinter = library.auto_hinter;
	if ((load_flags & (1 << 10)) != 0)
		load_flags |= (int)((1 << 0) | (1 << 11));
	if ((load_flags & (1 << 0)) != 0)
	{
		load_flags |= (int)((1 << 1) | (1 << 3));
		load_flags &= (int)(~(1 << 2));
	}

	if ((load_flags & (1 << 22)) != 0)
		load_flags &= (int)(~(1 << 2));
	if (((((((hinter) != null) && ((load_flags & (1 << 1)) == 0)) && ((load_flags & (1 << 15)) == 0)) && (!!((face).face_flags & (1 << 0)))) && (!(!!((face).face_flags & (1 << 13))))) && ((((load_flags & (1 << 11)) != 0) || (((face.internal->transform_matrix.yx) == (0)) && (face.internal->transform_matrix.xx != 0))) || (((face.internal->transform_matrix.xx) == (0)) && (face.internal->transform_matrix.yx != 0)))) {
	if (((load_flags & (1 << 5)) != 0) || ((((FT_ModuleRec_)(driver)).clazz.module_flags & 1024) == 0))
		autohint = (byte)(1);
	else
	{
		int mode = (int)(((load_flags) >> 16) & 15);
		byte is_light_type1 = 0;
		is_light_type1 = (byte)((strstr(FT_Get_Font_Format(face), "Type 1") != null) && ((((PS_DriverRec_*)(driver))->hinting_engine) == (1)));
		if ((((mode) == (FT_RENDER_MODE_LIGHT)) && (((((FT_ModuleRec_)(driver)).clazz.module_flags & 2048) == 0) && (is_light_type1 == 0))) || (((((!!((face).face_flags & (1 << 3))) && ((ttface->num_locations) != 0)) && ((ttface->max_profile.maxSizeOfInstructions) == (0))) && ((ttface->font_program_size) == (0))) && ((ttface->cvt_program_size) == (0))))
			autohint = (byte)(1);
	}
}

if ((autohint) != 0)
{
	FT_AutoHinter_InterfaceRec_* hinting;
	if ((!!((face).face_flags & (1 << 1))) && ((load_flags & (1 << 3)) == (0)))
	{
		error = (int)(driver->clazz->load_glyph(slot, face.size, (uint)(glyph_index), (int)(load_flags | (1 << 14))));
		if ((error == 0) && ((slot->format) == (FT_GLYPH_FORMAT_BITMAP)))
			goto Load_Ok;
	}
	{
		FT_Face_InternalRec_ * internal = face.internal;
int transform_flags = (int)(internal->transform_flags);
internal->transform_flags = (int)(0);
hinting = (FT_AutoHinter_InterfaceRec_*)(hinter.clazz.module_interface);
error = (int)(hinting->load_glyph((FT_AutoHinterRec_*)(hinter), slot, face.size, (uint)(glyph_index), (int)(load_flags)));
internal->transform_flags = (int)(transform_flags);}
}
 else
{
	error = (int)(driver->clazz->load_glyph(slot, face.size, (uint)(glyph_index), (int)(load_flags)));
	if ((error) != 0)
		goto Exit;
	if ((slot->format) == (FT_GLYPH_FORMAT_OUTLINE))
	{
		error = (int)(FT_Outline_Check(&slot->outline));
		if ((error) != 0)
			goto Exit;
		if ((load_flags & (1 << 1)) == 0)
			ft_glyphslot_grid_fit_metrics(slot, ((byte)((load_flags & (1 << 4)) != 0)));
	}
}

Load_Ok:;
if ((load_flags & (1 << 4)) != 0)
{
	slot->advance.x = (int)(0);
	slot->advance.y = (int)(slot->metrics.vertAdvance);
}
else
{
	slot->advance.x = (int)(slot->metrics.horiAdvance);
	slot->advance.y = (int)(0);
}

if (((load_flags & (1 << 13)) == (0)) && (!!((face).face_flags & (1 << 0))))
{
	FT_Size_Metrics_* metrics = &face.size->metrics;
	slot->linearHoriAdvance = (int)(FT_MulDiv((int)(slot->linearHoriAdvance), (int)(metrics->x_scale), (int)(64)));
	slot->linearVertAdvance = (int)(FT_MulDiv((int)(slot->linearVertAdvance), (int)(metrics->y_scale), (int)(64)));
}

if ((load_flags & (1 << 11)) == (0))
{
	FT_Face_InternalRec_ * internal = face.internal;
if ((internal->transform_flags) != 0) {
	FT_RendererRec_ renderer = ft_lookup_glyph_renderer(slot);
	if ((renderer) != null)
		error = (int)(renderer.clazz.transform_glyph(renderer, slot, &internal->transform_matrix, &internal->transform_delta)); else if ((slot->format) == (FT_GLYPH_FORMAT_OUTLINE))
{
	if ((internal->transform_flags & 1) != 0) FT_Outline_Transform(&slot->outline, &internal->transform_matrix);
if ((internal->transform_flags & 2) != 0) FT_Outline_Translate(&slot->outline, (int)(internal->transform_delta.x), (int)(internal->transform_delta.y));}
FT_Vector_Transform(&slot->advance, &internal->transform_matrix);}
}

			slot->glyph_index = (uint)(glyph_index);
slot->internal->load_flags = (int)(load_flags);
if ((((error == 0) && ((load_flags & (1 << 0)) == (0))) && (slot->format != FT_GLYPH_FORMAT_BITMAP)) && (slot->format != FT_GLYPH_FORMAT_COMPOSITE))
{
	int mode = (int)(((load_flags) >> 16) & 15);
	if (((mode) == (FT_RENDER_MODE_NORMAL)) && ((load_flags & (1 << 12)) != 0))
		mode = (int)(FT_RENDER_MODE_MONO);
	if ((load_flags & (1 << 2)) != 0)
		error = (int)(FT_Render_Glyph(slot, (int)(mode)));
	else
		ft_glyphslot_preset_bitmap(slot, (int)(mode), null);
}

Exit:;
return (int)(error);
		}

		public static int FT_Load_Char(FT_FaceRec_ face, int char_code, int load_flags)
{
	uint glyph_index = 0;
	if (face == null)
		return (int)(FT_Err_Invalid_Face_Handle);
	glyph_index = ((uint)(char_code));
	if ((face.charmap) != null)
		glyph_index = (uint)(FT_Get_Char_Index(face, (int)(char_code)));
	return (int)(FT_Load_Glyph(face, (uint)(glyph_index), (int)(load_flags)));
}

public static void destroy_size(FT_MemoryRec_ memory, FT_SizeRec_* size, FT_DriverRec_* driver)
{
	if ((size->generic.finalizer) != null)
		size->generic.finalizer(size);
	if ((driver->clazz->done_size) != null)
		driver->clazz->done_size(size);
	do
	{
		(ft_mem_free(memory, (size->internal)));
(size->internal) = null;}
 while ((0) != 0) ;
do
{
	(ft_mem_free(memory, (size)));
	(size) = null;
}
while ((0) != 0);
		}

		public static void destroy_charmaps(FT_FaceRec_ face, FT_MemoryRec_ memory)
{
	int n = 0;
	if (face == null)
		return;
	for (n = (int)(0); (n) < (face.num_charmaps); n++)
	{
		FT_CMapRec_* cmap = ((FT_CMapRec_*)(face.charmaps[n]));
		ft_cmap_done_internal(cmap);
		face.charmaps[n] = null;
	}
	do
	{
		(ft_mem_free(memory, (face.charmaps)));
		(face.charmaps) = null;
	}
	while ((0) != 0);
	face.num_charmaps = (int)(0);
}

public static void destroy_face(FT_MemoryRec_ memory, FT_FaceRec_ face, FT_DriverRec_* driver)
{
	FT_Driver_ClassRec_* clazz = driver->clazz;
	if ((face.autohint.finalizer) != null)
		face.autohint.finalizer(face.autohint.data);
	while ((face.glyph) != null)
	{ FT_Done_GlyphSlot(face.glyph); }
	FT_List_Finalize(&face.sizes_list, (void(FT_MemoryRec_ *, void *, void *) *)(destroy_size), memory, driver);
	face.size = null;
	if ((face.generic.finalizer) != null)
		face.generic.finalizer(face);
	destroy_charmaps(face, memory);
	if ((clazz->done_face) != null)
		clazz->done_face(face);
	FT_Stream_Free(face.stream, (int)((face.face_flags & (1 << 10)) != 0));
	face.stream = null;
	if ((face.internal) != null) {
	do
	{
		(ft_mem_free(memory, (face.internal)));
(face.internal) = null;}
 while ((0) != 0) ;}

			do
{
	(ft_mem_free(memory, (face)));
	(face) = null;
}
while ((0) != 0);
		}

		public static void Destroy_Driver(FT_DriverRec_* driver)
{
	FT_List_Finalize(&driver->faces_list, (void(FT_MemoryRec_ *, void *, void *) *)(destroy_face), driver->root.memory, driver);
}

public static int find_unicode_charmap(FT_FaceRec_ face)
{
	FT_CharMapRec_ first;
	FT_CharMapRec_ cur;
	do
	{
	}
	while ((0) != 0);
	first = face.charmaps;
	if (first == null)
		return (int)(FT_Err_Invalid_CharMap_Handle);
	cur = first[face.num_charmaps];
	for ((--cur) >= (first);{
		if ((cur[0].encoding) == (FT_ENCODING_UNICODE))
		{
			if ((((cur[0].platform_id) == (3)) && ((cur[0].encoding_id) == (10))) || (((cur[0].platform_id) == (0)) && ((cur[0].encoding_id) == (4))))
			{
				face.charmap = cur[0];
				return (int)(FT_Err_Ok);
			}
		}
	}
;) { }
cur = first[face.num_charmaps];
for ((--cur) >= (first);{
	if ((cur[0].encoding) == (FT_ENCODING_UNICODE))
	{
		face.charmap = cur[0];
		return (int)(FT_Err_Ok);
	}
}
;) { }
return (int)(FT_Err_Invalid_CharMap_Handle);
		}

		public static FT_CharMapRec_ find_variant_selector_charmap(FT_FaceRec_ face)
{
	FT_CharMapRec_ first;
	FT_CharMapRec_ end;
	FT_CharMapRec_ cur;
	do
	{
	}
	while ((0) != 0);
	first = face.charmaps;
	if (first == null)
		return null;
	end = first[face.num_charmaps];
	for (cur = first; (cur) < (end); cur++)
	{
		if ((((cur[0].platform_id) == (0)) && ((cur[0].encoding_id) == (5))) && ((FT_Get_CMap_Format(cur[0])) == (14)))
			return cur[0];
	}
	return null;
}

public static int open_face(FT_DriverRec_* driver, FT_StreamRec_ astream, byte external_stream, int face_index, int num_params, FT_Parameter_* params, FT_FaceRec_ aface)
{
	FT_MemoryRec_ memory;
	FT_Driver_ClassRec_* clazz;
	FT_FaceRec_ face = null;
	FT_Face_InternalRec_ * internal = null;
int error = 0;
int error2 = 0;
clazz = driver->clazz;
memory = driver->root.memory;
if ((((face) = (ft_mem_alloc(memory, (int)(clazz->face_object_size), &error))), error != 0)) goto Fail;
face.driver = driver;
face.memory = memory;
face.stream = astream;
if ((external_stream) != 0) face.face_flags |= (int)(1 << 10);
if ((((internal) = (ft_mem_alloc(memory, (int)(sizeof((*(internal)))), &error))) , error != 0)) goto Fail;
face.internal = internal;
{
	int i = 0;
	face.internal->incremental_interface = null;
for (i = (int)(0); ((i) < (num_params)) && (face.internal->incremental_interface == null);
i++) { if ((params[i].tag) == ((uint)(('i' << 24) | ('n' << 16) | ('c' << 8) | 'r'))) face.internal->incremental_interface = (FT_Incremental_InterfaceRec_*)(params[i].data);}}

			face.internal->random_seed = (int)(-1);
if ((clazz->init_face) != null) error = (int)(clazz->init_face(astream, face, (int)(face_index), (int)(num_params), params));
astream = face.stream;
if ((error) != 0) goto Fail;
error2 = (int)(find_unicode_charmap(face));
if (((error2) != 0) && (((error2) & 255) != ((FT_Err_Invalid_CharMap_Handle) & 255)))
{
	error = (int)(error2);
	goto Fail;
}

aface = face;
Fail:;
if ((error) != 0)
{
	destroy_charmaps(face, memory);
	if ((clazz->done_face) != null)
		clazz->done_face(face);
	do
	{
		(ft_mem_free(memory, (internal)));
(internal) = null;}
 while ((0) != 0) ;
do
{
	(ft_mem_free(memory, (face)));
	(face) = null;
}
while ((0) != 0);
aface = null;}

			return (int)(error);
		}

		public static int FT_New_Face(FT_LibraryRec_ library, sbyte* pathname, int face_index, FT_FaceRec_ aface)
{
	FT_Open_Args_ args = new FT_Open_Args_();
	if (pathname == null)
		return (int)(FT_Err_Invalid_Argument);
	args.flags = (uint)(4);
	args.pathname = pathname;
	args.stream = null;
	return (int)(ft_open_face_internal(library, &args, (int)(face_index), aface, (byte)(1)));
}

public static int FT_New_Memory_Face(FT_LibraryRec_ library, byte* file_base, int file_size, int face_index, FT_FaceRec_ aface)
{
	FT_Open_Args_ args = new FT_Open_Args_();
	if (file_base == null)
		return (int)(FT_Err_Invalid_Argument);
	args.flags = (uint)(1);
	args.memory_base = file_base;
	args.memory_size = (int)(file_size);
	args.stream = null;
	return (int)(ft_open_face_internal(library, &args, (int)(face_index), aface, (byte)(1)));
}

public static void memory_stream_close(FT_StreamRec_ stream)
{
	FT_MemoryRec_ memory = stream.memory;
	do
	{
		(ft_mem_free(memory, (stream._base_)));
		(stream._base_) = null;
	}
	while ((0) != 0);
	stream.size = (int)(0);
	stream._base_ = null;
	stream.close = null;
}

public static int new_memory_stream(FT_LibraryRec_ library, byte* _base_, int size, void (FT_StreamRec_*) * close, FT_StreamRec_ astream)
{
	int error = 0;
	FT_MemoryRec_ memory;
	FT_StreamRec_ stream = null;
	if (library == null)
		return (int)(FT_Err_Invalid_Library_Handle);
	if (_base_ == null)
		return (int)(FT_Err_Invalid_Argument);
	astream = null;
	memory = library.memory;
	if ((((stream) = (ft_mem_alloc(memory, (int)(sizeof((stream))), &error))), error != 0))
		goto Exit;
	FT_Stream_OpenMemory(stream, _base_, (int)(size));
	stream.close = close;
	astream = stream;
Exit:
	;
	return (int)(error);
}

public static int open_face_from_buffer(FT_LibraryRec_ library, byte* _base_, int size, int face_index, sbyte* driver_name, FT_FaceRec_ aface)
{
	FT_Open_Args_ args = new FT_Open_Args_();
	int error = 0;
	FT_StreamRec_ stream = null;
	FT_MemoryRec_ memory = library.memory;
	error = (int)(new_memory_stream(library, _base_, (int)(size), memory_stream_close, stream));
	if ((error) != 0)
	{
		do
		{
			(ft_mem_free(memory, (_base_)));
			(_base_) = null;
		}
		while ((0) != 0);
		return (int)(error);
	}

	args.flags = (uint)(2);
	args.stream = stream;
	if ((driver_name) != null)
	{
		args.flags = (uint)(args.flags | 8);
		args.driver = FT_Get_Module(library, driver_name);
	}

	error = (int)(ft_open_face_internal(library, &args, (int)(face_index), aface, (byte)(0)));
	if (error == 0)
		(aface).face_flags &= (int)(~(1 << 10));
	else
	{
		FT_Stream_Close(stream);
		do
		{
			(ft_mem_free(memory, (stream)));
			(stream) = null;
		}
		while ((0) != 0);
	}

	return (int)(error);
}

public static int ft_lookup_PS_in_sfnt_stream(FT_StreamRec_ stream, int face_index, int* offset, int* length, byte* is_sfnt_cid)
{
	int error = 0;
	ushort numTables = 0;
	int pstable_index = 0;
	int tag = 0;
	int i = 0;
	*offset = (int)(0);
	*length = (int)(0);
	*is_sfnt_cid = (byte)(0);
	if ((tag = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok))
		return (int)(error);
	if (tag != (uint)(('t' << 24) | ('y' << 16) | ('p' << 8) | '1'))
		return (int)(FT_Err_Unknown_File_Format);
	if ((numTables = (ushort)(FT_Stream_ReadUShort(stream, &error)), error != FT_Err_Ok))
		return (int)(error);
	if (((error = (int)(FT_Stream_Skip(stream, (int)(2 * 3)))) != 0))
		return (int)(error);
	pstable_index = (int)(-1);
	*is_sfnt_cid = (byte)(0);
	for (i = (int)(0); (i) < (numTables); i++)
	{
		if ((((tag = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok) || ((error = (int)(FT_Stream_Skip(stream, (int)(4)))) != 0)) || (*offset = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok)) || (*length = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok))
			return (int)(error);
		if ((tag) == ((uint)(('C' << 24) | ('I' << 16) | ('D' << 8) | ' ')))
		{
			pstable_index++;
			*offset += (int)(22);
			*length -= (int)(22);
			*is_sfnt_cid = (byte)(1);
			if ((face_index) < (0))
				return (int)(FT_Err_Ok);
		}
		else if ((tag) == ((uint)(('T' << 24) | ('Y' << 16) | ('P' << 8) | '1')))
		{
			pstable_index++;
			*offset += (int)(24);
			*length -= (int)(24);
			*is_sfnt_cid = (byte)(0);
			if ((face_index) < (0))
				return (int)(FT_Err_Ok);
		}
		if (((face_index) >= (0)) && ((pstable_index) == (face_index)))
			return (int)(FT_Err_Ok);
	}
	return (int)(FT_Err_Table_Missing);
}

public static int open_face_PS_from_sfnt_stream(FT_LibraryRec_ library, FT_StreamRec_ stream, int face_index, int num_params, FT_Parameter_* params, FT_FaceRec_ aface)
{
	int error = 0;
	FT_MemoryRec_ memory = library.memory;
	int offset = 0;
	int length = 0;
	int pos = 0;
	byte is_sfnt_cid = 0;
	byte* sfnt_ps = null;
	((num_params) = (int)(num_params));
	((params) = (params));
	if ((face_index) > (0))
		face_index &= (int)(0xFFFF);
	pos = (int)(FT_Stream_Pos(stream));
	error = (int)(ft_lookup_PS_in_sfnt_stream(stream, (int)(face_index), &offset, &length, &is_sfnt_cid));
	if ((error) != 0)
		goto Exit;
	if ((offset) > (stream.size))
	{
		do
		{
		}
		while ((0) != 0);
		error = (int)(FT_Err_Invalid_Table);
		goto Exit;
	}
	else if ((length) > (stream.size - offset))
	{
		do
		{
		}
		while ((0) != 0);
		error = (int)(FT_Err_Invalid_Table);
		goto Exit;
	}

	error = (int)(FT_Stream_Seek(stream, (int)(pos + offset)));
	if ((error) != 0)
		goto Exit;
	if ((((sfnt_ps) = (ft_mem_alloc(memory, (int)(length), &error))), error != 0))
		goto Exit;
	error = (int)(FT_Stream_Read(stream, sfnt_ps, (int)(length)));
	if ((error) != 0)
	{
		do
		{
			(ft_mem_free(memory, (sfnt_ps)));
			(sfnt_ps) = null;
		}
		while ((0) != 0);
		goto Exit;
	}

	error = (int)(open_face_from_buffer(library, sfnt_ps, (int)(length), (int)((face_index) < (0) ? (face_index) : (0)), (is_sfnt_cid) != 0 ? "cid" : "type1", aface));
Exit:
	;
	{
		int error1 = 0;
		if ((((error) & 255) == ((FT_Err_Unknown_File_Format) & 255)))
		{
			error1 = (int)(FT_Stream_Seek(stream, (int)(pos)));
			if ((error1) != 0)
				return (int)(error1);
		}
		return (int)(error);
	}

}

public static int Mac_Read_POST_Resource(FT_LibraryRec_ library, FT_StreamRec_ stream, int* offsets, int resource_cnt, int face_index, FT_FaceRec_ aface)
{
	int error = (int)(FT_Err_Cannot_Open_Resource);
	FT_MemoryRec_ memory = library.memory;
	byte* pfb_data = null;
	int i = 0;
	int type = 0;
	int flags = 0;
	int len = 0;
	int pfb_len = 0;
	int pfb_pos = 0;
	int pfb_lenpos = 0;
	int rlen = 0;
	int temp = 0;
	if ((face_index) == (-1))
		face_index = (int)(0);
	if (face_index != 0)
		return (int)(error);
	pfb_len = (int)(0);
	for (i = (int)(0); (i) < (resource_cnt); i++)
	{
		error = (int)(FT_Stream_Seek(stream, (int)(offsets[i])));
		if ((error) != 0)
			goto Exit;
		if ((temp = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok))
			goto Exit;
		do
		{
		}
		while ((0) != 0);
		if (((16777215) < (temp)) || ((16777215 - temp) < (pfb_len + 6)))
		{
			do
			{
			}
			while ((0) != 0);
			error = (int)(FT_Err_Invalid_Offset);
			goto Exit;
		}
		pfb_len += (int)(temp + 6);
	}
	do
	{
	}
	while ((0) != 0);
	if ((pfb_len + 2) < (6))
	{
		do
		{
		}
		while ((0) != 0);
		error = (int)(FT_Err_Array_Too_Large);
		goto Exit;
	}

	if ((((pfb_data) = (ft_mem_alloc(memory, (int)(pfb_len + 2), &error))), error != 0))
		goto Exit;
	pfb_data[0] = (byte)(0x80);
	pfb_data[1] = (byte)(1);
	pfb_data[2] = (byte)(0);
	pfb_data[3] = (byte)(0);
	pfb_data[4] = (byte)(0);
	pfb_data[5] = (byte)(0);
	pfb_pos = (int)(6);
	pfb_lenpos = (int)(2);
	len = (int)(0);
	type = (int)(1);
	for (i = (int)(0); (i) < (resource_cnt); i++)
	{
		error = (int)(FT_Stream_Seek(stream, (int)(offsets[i])));
		if ((error) != 0)
			goto Exit2;
		if ((rlen = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok))
			goto Exit2;
		if ((0x7FFFFFFFU) < (rlen))
		{
			error = (int)(FT_Err_Invalid_Offset);
			goto Exit2;
		}
		if ((flags = (int)(FT_Stream_ReadUShort(stream, &error)), error != FT_Err_Ok))
			goto Exit2;
		do
		{
		}
		while ((0) != 0);
		error = (int)(FT_Err_Array_Too_Large);
		if ((flags >> 8) == (0))
		{
			do
			{
			}
			while ((0) != 0);
			continue;
		}
		if ((rlen) > (2))
			rlen -= (int)(2);
		else
			rlen = (int)(0);
		if ((flags >> 8) == (type))
			len += (int)(rlen);
		else
		{
			do
			{
			}
			while ((0) != 0);
			if ((pfb_lenpos + 3) > (pfb_len + 2))
				goto Exit2;
			pfb_data[pfb_lenpos] = ((byte)(len));
			pfb_data[pfb_lenpos + 1] = ((byte)(len >> 8));
			pfb_data[pfb_lenpos + 2] = ((byte)(len >> 16));
			pfb_data[pfb_lenpos + 3] = ((byte)(len >> 24));
			if ((flags >> 8) == (5))
				break;
			do
			{
			}
			while ((0) != 0);
			if ((pfb_pos + 6) > (pfb_len + 2))
				goto Exit2;
			pfb_data[pfb_pos++] = (byte)(0x80);
			type = (int)(flags >> 8);
			len = (int)(rlen);
			pfb_data[pfb_pos++] = ((byte)(type));
			pfb_lenpos = (int)(pfb_pos);
			pfb_data[pfb_pos++] = (byte)(0);
			pfb_data[pfb_pos++] = (byte)(0);
			pfb_data[pfb_pos++] = (byte)(0);
			pfb_data[pfb_pos++] = (byte)(0);
		}
		if (((pfb_pos) > (pfb_len)) || ((pfb_pos + rlen) > (pfb_len)))
			goto Exit2;
		do
		{
		}
		while ((0) != 0);
		error = (int)(FT_Stream_Read(stream, pfb_data + pfb_pos, (int)(rlen)));
		if ((error) != 0)
			goto Exit2;
		pfb_pos += (int)(rlen);
	}
	error = (int)(FT_Err_Array_Too_Large);
	if ((pfb_pos + 2) > (pfb_len + 2))
		goto Exit2;
	pfb_data[pfb_pos++] = (byte)(0x80);
	pfb_data[pfb_pos++] = (byte)(3);
	if ((pfb_lenpos + 3) > (pfb_len + 2))
		goto Exit2;
	pfb_data[pfb_lenpos] = ((byte)(len));
	pfb_data[pfb_lenpos + 1] = ((byte)(len >> 8));
	pfb_data[pfb_lenpos + 2] = ((byte)(len >> 16));
	pfb_data[pfb_lenpos + 3] = ((byte)(len >> 24));
	return (int)(open_face_from_buffer(library, pfb_data, (int)(pfb_pos), (int)(face_index), "type1", aface));
Exit2:
	;
	if ((((error) & 255) == ((FT_Err_Array_Too_Large) & 255)))
		do
		{
		}
		while ((0) != 0);
	else if ((((error) & 255) == ((FT_Err_Invalid_Offset) & 255)))
		do
		{
		}
		while ((0) != 0);
	if ((error) != 0)
		error = (int)(FT_Err_Cannot_Open_Resource);
	do
	{
		(ft_mem_free(memory, (pfb_data)));
		(pfb_data) = null;
	}
	while ((0) != 0);
Exit:
	;
	return (int)(error);
}

public static int Mac_Read_sfnt_Resource(FT_LibraryRec_ library, FT_StreamRec_ stream, int* offsets, int resource_cnt, int face_index, FT_FaceRec_ aface)
{
	FT_MemoryRec_ memory = library.memory;
	byte* sfnt_data = null;
	int error = 0;
	int flag_offset = 0;
	int rlen = 0;
	int is_cff = 0;
	int face_index_in_resource = (int)(0);
	if ((face_index) < (0))
		face_index = (int)(-face_index - 1);
	if ((face_index) >= (resource_cnt))
		return (int)(FT_Err_Cannot_Open_Resource);
	flag_offset = (int)(offsets[face_index]);
	error = (int)(FT_Stream_Seek(stream, (int)(flag_offset)));
	if ((error) != 0)
		goto Exit;
	if ((rlen = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok))
		goto Exit;
	if ((rlen) < (1))
		return (int)(FT_Err_Cannot_Open_Resource);
	if ((rlen) > (16777215))
		return (int)(FT_Err_Invalid_Offset);
	error = (int)(open_face_PS_from_sfnt_stream(library, stream, (int)(face_index), (int)(0), null, aface));
	if (error == 0)
		goto Exit;
	error = (int)(FT_Stream_Seek(stream, (int)(flag_offset + 4)));
	if ((error) != 0)
		goto Exit;
	if ((((sfnt_data) = (ft_mem_alloc(memory, (int)(rlen), &error))), error != 0))
		return (int)(error);
	error = (int)(FT_Stream_Read(stream, sfnt_data, (int)(rlen)));
	if ((error) != 0)
	{
		do
		{
			(ft_mem_free(memory, (sfnt_data)));
			(sfnt_data) = null;
		}
		while ((0) != 0);
		goto Exit;
	}

	is_cff = (int)(((rlen) > (4)) && (CRuntime.memcmp(sfnt_data, "OTTO", (ulong)(4)) == 0) ? 1 : 0);
	error = (int)(open_face_from_buffer(library, sfnt_data, (int)(rlen), (int)(face_index_in_resource), (is_cff) != 0 ? "cff" : "truetype", aface));
Exit:
	;
	return (int)(error);
}

public static int IsMacResource(FT_LibraryRec_ library, FT_StreamRec_ stream, int resource_offset, int face_index, FT_FaceRec_ aface)
{
	FT_MemoryRec_ memory = library.memory;
	int error = 0;
	int map_offset = 0;
	int rdata_pos = 0;
	int* data_offsets;
	int count = 0;
	error = (int)(FT_Raccess_Get_HeaderInfo(library, stream, (int)(resource_offset), &map_offset, &rdata_pos));
	if ((error) != 0)
		return (int)(error);
	error = (int)(FT_Raccess_Get_DataOffsets(library, stream, (int)(map_offset), (int)(rdata_pos), (int)((uint)(('P' << 24) | ('O' << 16) | ('S' << 8) | 'T')), (byte)(1), &data_offsets, &count));
	if (error == 0)
	{
		error = (int)(Mac_Read_POST_Resource(library, stream, data_offsets, (int)(count), (int)(face_index), aface));
		do
		{
			(ft_mem_free(memory, (data_offsets)));
			(data_offsets) = null;
		}
		while ((0) != 0);
		if (error == 0)
			(aface).num_faces = (int)(1);
		return (int)(error);
	}

	error = (int)(FT_Raccess_Get_DataOffsets(library, stream, (int)(map_offset), (int)(rdata_pos), (int)((uint)(('s' << 24) | ('f' << 16) | ('n' << 8) | 't')), (byte)(0), &data_offsets, &count));
	if (error == 0)
	{
		int face_index_internal = (int)(face_index % count);
		error = (int)(Mac_Read_sfnt_Resource(library, stream, data_offsets, (int)(count), (int)(face_index_internal), aface));
		do
		{
			(ft_mem_free(memory, (data_offsets)));
			(data_offsets) = null;
		}
		while ((0) != 0);
		if (error == 0)
			(aface).num_faces = (int)(count);
	}

	return (int)(error);
}

public static int IsMacBinary(FT_LibraryRec_ library, FT_StreamRec_ stream, int face_index, FT_FaceRec_ aface)
{
	byte* header = stackalloc byte[128];
	int error = 0;
	int dlen = 0;
	int offset = 0;
	if (stream == null)
		return (int)(FT_Err_Invalid_Stream_Operation);
	error = (int)(FT_Stream_Seek(stream, (int)(0)));
	if ((error) != 0)
		goto Exit;
	error = (int)(FT_Stream_Read(stream, header, (int)(128)));
	if ((error) != 0)
		goto Exit;
	if ((((((((header[0] != 0) || (header[74] != 0)) || (header[82] != 0)) || ((header[1]) == (0))) || ((header[1]) > (33))) || (header[63] != 0)) || (header[2 + header[1]] != 0)) || ((header[0x53]) > (0x7F)))
		return (int)(FT_Err_Unknown_File_Format);
	dlen = (int)((header[0x53] << 24) | (header[0x54] << 16) | (header[0x55] << 8) | header[0x56]);
	offset = (int)(128 + ((dlen + 127) & ~127));
	return (int)(IsMacResource(library, stream, (int)(offset), (int)(face_index), aface));
Exit:
	;
	return (int)(error);
}

public static int load_face_in_embedded_rfork(FT_LibraryRec_ library, FT_StreamRec_ stream, int face_index, FT_FaceRec_ aface, FT_Open_Args_* args)
{
	FT_MemoryRec_ memory = library.memory;
	int error = (int)(FT_Err_Unknown_File_Format);
	uint i = 0;
	sbyte** file_names = stackalloc sbyte[9];
	int* offsets = stackalloc int[9];
	int* errors = stackalloc int[9];
	byte is_darwin_vfs = 0;
	byte vfs_rfork_has_no_font = (byte)(0);
	FT_Open_Args_ args2 = new FT_Open_Args_();
	FT_StreamRec_ stream2 = null;
	FT_Raccess_Guess(library, stream, args->pathname, file_names, offsets, errors);
	for (i = (uint)(0); (i) < (9); i++)
	{
		is_darwin_vfs = (byte)(ft_raccess_rule_by_darwin_vfs(library, (uint)(i)));
		if (((is_darwin_vfs) != 0) && ((vfs_rfork_has_no_font) != 0))
		{
			do
			{
			}
			while ((0) != 0);
			continue;
		}
		if ((errors[i]) != 0)
		{
			do
			{
			}
			while ((0) != 0);
			continue;
		}
		args2.flags = (uint)(4);
		args2.pathname = file_names[i] ? file_names[i] : args->pathname;
		do
		{
		}
		while ((0) != 0);
		error = (int)(FT_Stream_New(library, &args2, stream2));
		if (((is_darwin_vfs) != 0) && (((error) & 255) == ((FT_Err_Cannot_Open_Stream) & 255)))
			vfs_rfork_has_no_font = (byte)(1);
		if ((error) != 0)
		{
			do
			{
			}
			while ((0) != 0);
			continue;
		}
		error = (int)(IsMacResource(library, stream2, (int)(offsets[i]), (int)(face_index), aface));
		FT_Stream_Free(stream2, (int)(0));
		do
		{
		}
		while ((0) != 0);
		if (error == 0)
			break;
		else if ((is_darwin_vfs) != 0)
			vfs_rfork_has_no_font = (byte)(1);
	}
	for (i = (uint)(0); (i) < (9); i++)
	{
		if ((file_names[i]) != null)
			do
			{
				(ft_mem_free(memory, (file_names[i])));
				(file_names[i]) = null;
			}
			while ((0) != 0);
	}
	if ((error) != 0)
		error = (int)(FT_Err_Unknown_File_Format);
	return (int)(error);
}

public static int load_mac_face(FT_LibraryRec_ library, FT_StreamRec_ stream, int face_index, FT_FaceRec_ aface, FT_Open_Args_* args)
{
	int error = 0;
	((args) = (args));
	error = (int)(IsMacBinary(library, stream, (int)(face_index), aface));
	if ((((error) & 255) == ((FT_Err_Unknown_File_Format) & 255)))
	{
		error = (int)(IsMacResource(library, stream, (int)(0), (int)(face_index), aface));
		do
		{
		}
		while ((0) != 0);
	}

	if (((((error) & 255) == ((FT_Err_Unknown_File_Format) & 255)) || (((error) & 255) == ((FT_Err_Invalid_Stream_Operation) & 255))) && ((args->flags & 4) != 0))
		error = (int)(load_face_in_embedded_rfork(library, stream, (int)(face_index), aface, args));
	return (int)(error);
}

public static int FT_Open_Face(FT_LibraryRec_ library, FT_Open_Args_* args, int face_index, FT_FaceRec_ aface)
{
	return (int)(ft_open_face_internal(library, args, (int)(face_index), aface, (byte)(1)));
}

public static int ft_open_face_internal(FT_LibraryRec_ library, FT_Open_Args_* args, int face_index, FT_FaceRec_ aface, byte test_mac_fonts)
{
	int error = 0;
	FT_DriverRec_* driver = null;
	FT_MemoryRec_ memory = null;
	FT_StreamRec_ stream = null;
	FT_FaceRec_ face = null;
	FT_ListNodeRec_* node = null;
	byte external_stream = 0;
	FT_ModuleRec_ cur;
	FT_ModuleRec_ limit;
	if (((aface == null) && ((face_index) >= (0))) || (args == null))
		return (int)(FT_Err_Invalid_Argument);
	external_stream = ((byte)((((args->flags & 0x2) != 0) && ((args->stream) != null)) != 0));
	error = (int)(FT_Stream_New(library, args, stream));
	if ((error) != 0)
		goto Fail3;
	memory = library.memory;
	if (((args->flags & 8) != 0) && ((args->driver) != null))
	{
		driver = ((FT_DriverRec_*)(args->driver));
		if ((((FT_ModuleRec_)(driver)).clazz.module_flags & 1) != 0)
		{
			int num_params = (int)(0);
			FT_Parameter_ * params = null;
			if ((args->flags & 16) != 0)
			{
				num_params = (int)(args->num_params);params = args->params;
			}
			error = (int)(open_face(driver, stream, (byte)(external_stream), (int)(face_index), (int)(num_params), params, face));
			if (error == 0)
				goto Success;
		}
		else
			error = (int)(FT_Err_Invalid_Handle);
		FT_Stream_Free(stream, (int)(external_stream));
		goto Fail;
	}
	else
	{
		error = (int)(FT_Err_Missing_Module);
		cur = library.modules;
		limit = cur[library.num_modules];
		for (; (cur) < (limit); cur++)
		{
			if (((cur[0]).clazz.module_flags & 1) != 0)
			{
				int num_params = (int)(0);
				FT_Parameter_ * params = null;
				driver = ((FT_DriverRec_*)(cur[0]));
				if ((args->flags & 16) != 0)
				{
					num_params = (int)(args->num_params);params = args->params;
				}
				error = (int)(open_face(driver, stream, (byte)(external_stream), (int)(face_index), (int)(num_params), params, face));
				if (error == 0)
					goto Success;
				if ((((test_mac_fonts) != 0) && ((strcmp(cur[0].clazz.module_name, "truetype")) == (0))) && (((error) & 255) == ((FT_Err_Table_Missing) & 255)))
				{
					error = (int)(FT_Stream_Seek(stream, (int)(0)));
					if ((error) != 0)
						break;
					error = (int)(open_face_PS_from_sfnt_stream(library, stream, (int)(face_index), (int)(num_params), params, aface));
					if (error == 0)
					{
						FT_Stream_Free(stream, (int)(external_stream));
						return (int)(error);
					}
				}
				if ((((error) & 255) != ((FT_Err_Unknown_File_Format) & 255)))
					goto Fail3;
			}
		}
	Fail3:
		;
		if (((((error) & 255) != ((FT_Err_Cannot_Open_Stream) & 255)) && (((error) & 255) != ((FT_Err_Unknown_File_Format) & 255))) && (((error) & 255) != ((FT_Err_Invalid_Stream_Operation) & 255)))
			goto Fail2;
		if ((test_mac_fonts) != 0)
		{
			error = (int)(load_mac_face(library, stream, (int)(face_index), aface, args));
			if (error == 0)
			{
				FT_Stream_Free(stream, (int)(external_stream));
				return (int)(error);
			}
		}
		if ((((error) & 255) != ((FT_Err_Unknown_File_Format) & 255)))
			goto Fail2;
		error = (int)(FT_Err_Unknown_File_Format);
	Fail2:
		;
		FT_Stream_Free(stream, (int)(external_stream));
		goto Fail;
	}

Success:
	;
	do
	{
	}
	while ((0) != 0);
	if ((((node) = (ft_mem_alloc(memory, (int)(sizeof((*(node)))), &error))) , error != 0)) goto Fail;
node->data = face;
FT_List_Add(&face.driver->faces_list, node);
do
{
}
while ((0) != 0);
if ((face_index) >= (0))
{
	error = (int)(FT_New_GlyphSlot(face, null));
	if ((error) != 0)
		goto Fail;
	{
		FT_SizeRec_* size;
		do
		{
		}
		while ((0) != 0);
		error = (int)(FT_New_Size(face, &size));
		if ((error) != 0)
			goto Fail;
		face.size = size;
	}
}

if ((!!((face).face_flags & (1 << 0))))
{
	if ((face.height) < (0))
		face.height = ((short)(-face.height));
	if (!(!!((face).face_flags & (1 << 5))))
		face.max_advance_height = (short)(face.height);
}

if ((!!((face).face_flags & (1 << 1))))
{
	int i = 0;
	for (i = (int)(0); (i) < (face.num_fixed_sizes); i++)
	{
		FT_Bitmap_Size_* bsize = face.available_sizes + i;
		if ((bsize->height) < (0))
			bsize->height = (short)(-bsize->height);
		if ((bsize->x_ppem) < (0))
			bsize->x_ppem = (int)(-bsize->x_ppem);
		if ((bsize->y_ppem) < (0))
			bsize->y_ppem = (int)(-bsize->y_ppem);
		if ((((bsize->height) < (0)) || ((bsize->x_ppem) < (0))) || ((bsize->y_ppem) < (0)))
		{
			do
			{
			}
			while ((0) != 0);
			bsize->width = (short)(0);
			bsize->height = (short)(0);
			bsize->size = (int)(0);
			bsize->x_ppem = (int)(0);
			bsize->y_ppem = (int)(0);
		}
	}
}

{
	FT_Face_InternalRec_ * internal = face.internal;
internal->transform_matrix.xx = (int)(0x10000);
internal->transform_matrix.xy = (int)(0);
internal->transform_matrix.yx = (int)(0);
internal->transform_matrix.yy = (int)(0x10000);
internal->transform_delta.x = (int)(0);
internal->transform_delta.y = (int)(0);
internal->refcount = (int)(1);
internal->no_stem_darkening = (sbyte)(-1);}

			if ((aface) != null) aface = face; else FT_Done_Face(face);
goto Exit;
Fail:;
if ((node) != null) FT_Done_Face(face); else if ((face) != null) destroy_face(memory, face, driver);
Exit:;
do
{
}
while ((0) != 0);
return (int)(error);
		}

		public static int FT_Attach_File(FT_FaceRec_ face, sbyte* filepathname)
{
	FT_Open_Args_ open = new FT_Open_Args_();
	if (filepathname == null)
		return (int)(FT_Err_Invalid_Argument);
	open.stream = null;
	open.flags = (uint)(4);
	open.pathname = filepathname;
	return (int)(FT_Attach_Stream(face, &open));
}

public static int FT_Attach_Stream(FT_FaceRec_ face, FT_Open_Args_* parameters)
{
	FT_StreamRec_ stream;
	int error = 0;
	FT_DriverRec_* driver;
	FT_Driver_ClassRec_* clazz;
	if (face == null)
		return (int)(FT_Err_Invalid_Face_Handle);
	driver = face.driver;
	if (driver == null)
		return (int)(FT_Err_Invalid_Driver_Handle);
	error = (int)(FT_Stream_New(driver->root.library, parameters, stream));
	if ((error) != 0)
		goto Exit;
	error = (int)(FT_Err_Unimplemented_Feature);
	clazz = driver->clazz;
	if ((clazz->attach_file) != null)
		error = (int)(clazz->attach_file(face, stream));
	FT_Stream_Free(stream, (int)((byte)((((parameters->stream) != null) && ((parameters->flags & 0x2) != 0)) != 0)));
Exit:
	;
	return (int)(error);
}

public static int FT_Reference_Face(FT_FaceRec_ face)
{
	if (face == null)
		return (int)(FT_Err_Invalid_Face_Handle);
	face.internal->refcount++;
return (int)(FT_Err_Ok);
		}

		public static int FT_Done_Face(FT_FaceRec_ face)
{
	int error = 0;
	FT_DriverRec_* driver;
	FT_MemoryRec_ memory;
	FT_ListNodeRec_* node;
	error = (int)(FT_Err_Invalid_Face_Handle);
	if (((face) != null) && ((face.driver) != null))
	{
		face.internal->refcount--;
if ((face.internal->refcount) > (0)) error = (int)(FT_Err_Ok); else
{
	driver = face.driver;
	memory = driver->root.memory;
	node = FT_List_Find(&driver->faces_list, face);
	if ((node) != null)
	{
		FT_List_Remove(&driver->faces_list, node);
		do
		{
			(ft_mem_free(memory, (node)));
			(node) = null;
		}
		while ((0) != 0);
		destroy_face(memory, face, driver);
		error = (int)(FT_Err_Ok);
	}
}
}

			return (int)(error);
		}

		public static int FT_New_Size(FT_FaceRec_ face, FT_SizeRec_** asize)
{
	int error = 0;
	FT_MemoryRec_ memory;
	FT_DriverRec_* driver;
	FT_Driver_ClassRec_* clazz;
	FT_SizeRec_* size = null;
	FT_ListNodeRec_* node = null;
	FT_Size_InternalRec_ * internal = null;
if (face == null) return (int)(FT_Err_Invalid_Face_Handle);
if (asize == null) return (int)(FT_Err_Invalid_Argument);
if (face.driver == null) return (int)(FT_Err_Invalid_Driver_Handle);
*asize = null;
driver = face.driver;
clazz = driver->clazz;
memory = face.memory;
if ((((size) = (ft_mem_alloc(memory, (int)(clazz->size_object_size), &error))), error != 0) || (((node) = (ft_mem_alloc(memory, (int)(sizeof((*(node)))), &error))) , error != 0)) goto Exit;
size->face = face;
if ((((internal) = (ft_mem_alloc(memory, (int)(sizeof((*(internal)))), &error))) , error != 0)) goto Exit;
size->internal = internal;
if ((clazz->init_size) != null) error = (int)(clazz->init_size(size));
if (error == 0)
{
	*asize = size;
	node->data = size;
	FT_List_Add(&face.sizes_list, node);
}

Exit:;
if ((error) != 0)
{
	do
	{
		(ft_mem_free(memory, (node)));
		(node) = null;
	}
	while ((0) != 0);
	if ((size) != null)
		do
		{
			(ft_mem_free(memory, (size->internal)));
(size->internal) = null;}
 while ((0) != 0) ;
do
{
	(ft_mem_free(memory, (size)));
	(size) = null;
}
while ((0) != 0);}

			return (int)(error);
		}

		public static int FT_Done_Size(FT_SizeRec_* size)
{
	int error = 0;
	FT_DriverRec_* driver;
	FT_MemoryRec_ memory;
	FT_FaceRec_ face;
	FT_ListNodeRec_* node;
	if (size == null)
		return (int)(FT_Err_Invalid_Size_Handle);
	face = size->face;
	if (face == null)
		return (int)(FT_Err_Invalid_Face_Handle);
	driver = face.driver;
	if (driver == null)
		return (int)(FT_Err_Invalid_Driver_Handle);
	memory = driver->root.memory;
	error = (int)(FT_Err_Ok);
	node = FT_List_Find(&face.sizes_list, size);
	if ((node) != null)
	{
		FT_List_Remove(&face.sizes_list, node);
		do
		{
			(ft_mem_free(memory, (node)));
			(node) = null;
		}
		while ((0) != 0);
		if ((face.size) == (size))
		{
			face.size = null;
			if ((face.sizes_list.head) != null)
				face.size = (FT_SizeRec_*)(face.sizes_list.head->data);
		}
		destroy_size(memory, size, driver);
	}
	else
		error = (int)(FT_Err_Invalid_Size_Handle);
	return (int)(error);
}

public static int FT_Match_Size(FT_FaceRec_ face, FT_Size_RequestRec_* req, byte ignore_width, int* size_index)
{
	int i = 0;
	int w = 0;
	int h = 0;
	if (!(!!((face).face_flags & (1 << 1))))
		return (int)(FT_Err_Invalid_Face_Handle);
	if (req->type != FT_SIZE_REQUEST_TYPE_NOMINAL)
		return (int)(FT_Err_Unimplemented_Feature);
	w = (int)(((req)->horiResolution) != 0 ? ((req)->width * (int)((req)->horiResolution) + 36) / 72 : (req)->width);
	h = (int)(((req)->vertResolution) != 0 ? ((req)->height * (int)((req)->vertResolution) + 36) / 72 : (req)->height);
	if (((req->width) != 0) && (req->height == 0))
		h = (int)(w);
	else if ((req->width == 0) && ((req->height) != 0))
		w = (int)(h);
	w = (int)(((w) + 32) & ~63);
	h = (int)(((h) + 32) & ~63);
	if ((w == 0) || (h == 0))
		return (int)(FT_Err_Invalid_Pixel_Size);
	for (i = (int)(0); (i) < (face.num_fixed_sizes); i++)
	{
		FT_Bitmap_Size_* bsize = face.available_sizes + i;
		if (h != (((bsize->y_ppem) + 32) & ~63))
			continue;
		if (((w) == (((bsize->x_ppem) + 32) & ~63)) || ((ignore_width) != 0))
		{
			do
			{
			}
			while ((0) != 0);
			if ((size_index) != null)
				*size_index = (int)(i);
			return (int)(FT_Err_Ok);
		}
	}
	do
	{
	}
	while ((0) != 0);
	return (int)(FT_Err_Invalid_Pixel_Size);
}

public static void ft_synthesize_vertical_metrics(FT_Glyph_Metrics_* metrics, int advance)
{
	int height = (int)(metrics->height);
	if ((metrics->horiBearingY) < (0))
	{
		if ((height) < (metrics->horiBearingY))
			height = (int)(metrics->horiBearingY);
	}
	else if ((metrics->horiBearingY) > (0))
		height -= (int)(metrics->horiBearingY);
	if (advance == 0)
		advance = (int)(height * 12 / 10);
	metrics->vertBearingX = (int)(metrics->horiBearingX - metrics->horiAdvance / 2);
	metrics->vertBearingY = (int)((advance - height) / 2);
	metrics->vertAdvance = (int)(advance);
}

public static void ft_recompute_scaled_metrics(FT_FaceRec_ face, FT_Size_Metrics_* metrics)
{
	metrics->ascender = (int)(((FT_MulFix((int)(face.ascender), (int)(metrics->y_scale))) + 63) & ~63);
	metrics->descender = (int)((FT_MulFix((int)(face.descender), (int)(metrics->y_scale))) & ~63);
	metrics->height = (int)(((FT_MulFix((int)(face.height), (int)(metrics->y_scale))) + 32) & ~63);
	metrics->max_advance = (int)(((FT_MulFix((int)(face.max_advance_width), (int)(metrics->x_scale))) + 32) & ~63);
}

public static void FT_Select_Metrics(FT_FaceRec_ face, int strike_index)
{
	FT_Size_Metrics_* metrics;
	FT_Bitmap_Size_* bsize;
	metrics = &face.size->metrics;
	bsize = face.available_sizes + strike_index;
	metrics->x_ppem = ((ushort)((bsize->x_ppem + 32) >> 6));
	metrics->y_ppem = ((ushort)((bsize->y_ppem + 32) >> 6));
	if ((!!((face).face_flags & (1 << 0))))
	{
		metrics->x_scale = (int)(FT_DivFix((int)(bsize->x_ppem), (int)(face.units_per_EM)));
		metrics->y_scale = (int)(FT_DivFix((int)(bsize->y_ppem), (int)(face.units_per_EM)));
		ft_recompute_scaled_metrics(face, metrics);
	}
	else
	{
		metrics->x_scale = (int)(1 << 16);
		metrics->y_scale = (int)(1 << 16);
		metrics->ascender = (int)(bsize->y_ppem);
		metrics->descender = (int)(0);
		metrics->height = (int)(bsize->height << 6);
		metrics->max_advance = (int)(bsize->x_ppem);
	}

}

public static void FT_Request_Metrics(FT_FaceRec_ face, FT_Size_RequestRec_* req)
{
	FT_Size_Metrics_* metrics;
	metrics = &face.size->metrics;
	if ((!!((face).face_flags & (1 << 0))))
	{
		int w = (int)(0);
		int h = (int)(0);
		int scaled_w = (int)(0);
		int scaled_h = (int)(0);
		switch (req->type)
		{
			case FT_SIZE_REQUEST_TYPE_NOMINAL:
				w = (int)(h = (int)(face.units_per_EM));
				break;
			case FT_SIZE_REQUEST_TYPE_REAL_DIM:
				w = (int)(h = (int)(face.ascender - face.descender));
				break;
			case FT_SIZE_REQUEST_TYPE_BBOX:
				w = (int)(face.bbox.xMax - face.bbox.xMin);
				h = (int)(face.bbox.yMax - face.bbox.yMin);
				break;
			case FT_SIZE_REQUEST_TYPE_CELL:
				w = (int)(face.max_advance_width);
				h = (int)(face.ascender - face.descender);
				break;
			case FT_SIZE_REQUEST_TYPE_SCALES:
				metrics->x_scale = (int)(req->width);
				metrics->y_scale = (int)(req->height);
				if (metrics->x_scale == 0)
					metrics->x_scale = (int)(metrics->y_scale);
				else if (metrics->y_scale == 0)
					metrics->y_scale = (int)(metrics->x_scale);
				goto Calculate_Ppem;
			case FT_SIZE_REQUEST_TYPE_MAX:
				break;
		}
		if ((w) < (0))
			w = (int)(-w);
		if ((h) < (0))
			h = (int)(-h);
		scaled_w = (int)(((req)->horiResolution) != 0 ? ((req)->width * (int)((req)->horiResolution) + 36) / 72 : (req)->width);
		scaled_h = (int)(((req)->vertResolution) != 0 ? ((req)->height * (int)((req)->vertResolution) + 36) / 72 : (req)->height);
		if ((req->width) != 0)
		{
			metrics->x_scale = (int)(FT_DivFix((int)(scaled_w), (int)(w)));
			if ((req->height) != 0)
			{
				metrics->y_scale = (int)(FT_DivFix((int)(scaled_h), (int)(h)));
				if ((req->type) == (FT_SIZE_REQUEST_TYPE_CELL))
				{
					if ((metrics->y_scale) > (metrics->x_scale))
						metrics->y_scale = (int)(metrics->x_scale);
					else
						metrics->x_scale = (int)(metrics->y_scale);
				}
			}
			else
			{
				metrics->y_scale = (int)(metrics->x_scale);
				scaled_h = (int)(FT_MulDiv((int)(scaled_w), (int)(h), (int)(w)));
			}
		}
		else
		{
			metrics->x_scale = (int)(metrics->y_scale = (int)(FT_DivFix((int)(scaled_h), (int)(h))));
			scaled_w = (int)(FT_MulDiv((int)(scaled_h), (int)(w), (int)(h)));
		}
	Calculate_Ppem:
		;
		if (req->type != FT_SIZE_REQUEST_TYPE_NOMINAL)
		{
			scaled_w = (int)(FT_MulFix((int)(face.units_per_EM), (int)(metrics->x_scale)));
			scaled_h = (int)(FT_MulFix((int)(face.units_per_EM), (int)(metrics->y_scale)));
		}
		metrics->x_ppem = ((ushort)((scaled_w + 32) >> 6));
		metrics->y_ppem = ((ushort)((scaled_h + 32) >> 6));
		ft_recompute_scaled_metrics(face, metrics);
	}
	else
	{
		CRuntime.memset(metrics, (int)(0), (ulong)(sizeof((*(metrics)))));
metrics->x_scale = (int)(1 << 16);
metrics->y_scale = (int)(1 << 16);}

		}

		public static int FT_Select_Size(FT_FaceRec_ face, int strike_index)
{
	int error = (int)(FT_Err_Ok);
	FT_Driver_ClassRec_* clazz;
	if ((face == null) || (!(!!((face).face_flags & (1 << 1)))))
		return (int)(FT_Err_Invalid_Face_Handle);
	if (((strike_index) < (0)) || ((strike_index) >= (face.num_fixed_sizes)))
		return (int)(FT_Err_Invalid_Argument);
	clazz = face.driver->clazz;
	if ((clazz->select_size) != null)
	{
		error = (int)(clazz->select_size(face.size, (int)(strike_index)));
		do
		{
		}
		while ((0) != 0);
	}
	else
	{
		FT_Select_Metrics(face, (int)(strike_index));
		do
		{
		}
		while ((0) != 0);
	}

	return (int)(error);
}

public static int FT_Request_Size(FT_FaceRec_ face, FT_Size_RequestRec_* req)
{
	int error = (int)(FT_Err_Ok);
	FT_Driver_ClassRec_* clazz;
	int strike_index = 0;
	if (face == null)
		return (int)(FT_Err_Invalid_Face_Handle);
	if ((((req == null) || ((req->width) < (0))) || ((req->height) < (0))) || ((req->type) >= (FT_SIZE_REQUEST_TYPE_MAX)))
		return (int)(FT_Err_Invalid_Argument);
	face.size->internal->autohint_metrics.x_scale = (int)(0);
clazz = face.driver->clazz;
if ((clazz->request_size) != null)
{
	error = (int)(clazz->request_size(face.size, req));
	do
	{
	}
	while ((0) != 0);
}
else if ((!(!!((face).face_flags & (1 << 0)))) && (!!((face).face_flags & (1 << 1))))
{
	error = (int)(FT_Match_Size(face, req, (byte)(0), &strike_index));
	if ((error) != 0)
		return (int)(error);
	return (int)(FT_Select_Size(face, (int)(strike_index)));
}
else
{
	FT_Request_Metrics(face, req);
	do
	{
	}
	while ((0) != 0);
}

return (int)(error);
		}

		public static int FT_Set_Char_Size(FT_FaceRec_ face, int char_width, int char_height, uint horz_resolution, uint vert_resolution)
{
	FT_Size_RequestRec_ req = new FT_Size_RequestRec_();
	if (char_width == 0)
		char_width = (int)(char_height);
	else if (char_height == 0)
		char_height = (int)(char_width);
	if (horz_resolution == 0)
		horz_resolution = (uint)(vert_resolution);
	else if (vert_resolution == 0)
		vert_resolution = (uint)(horz_resolution);
	if ((char_width) < (1 * 64))
		char_width = (int)(1 * 64);
	if ((char_height) < (1 * 64))
		char_height = (int)(1 * 64);
	if (horz_resolution == 0)
		horz_resolution = (uint)(vert_resolution = (uint)(72));
	req.type = (int)(FT_SIZE_REQUEST_TYPE_NOMINAL);
	req.width = (int)(char_width);
	req.height = (int)(char_height);
	req.horiResolution = (uint)(horz_resolution);
	req.vertResolution = (uint)(vert_resolution);
	return (int)(FT_Request_Size(face, &req));
}

public static int FT_Set_Pixel_Sizes(FT_FaceRec_ face, uint pixel_width, uint pixel_height)
{
	FT_Size_RequestRec_ req = new FT_Size_RequestRec_();
	if ((pixel_width) == (0))
		pixel_width = (uint)(pixel_height);
	else if ((pixel_height) == (0))
		pixel_height = (uint)(pixel_width);
	if ((pixel_width) < (1))
		pixel_width = (uint)(1);
	if ((pixel_height) < (1))
		pixel_height = (uint)(1);
	if ((pixel_width) >= (0xFFFFU))
		pixel_width = (uint)(0xFFFFU);
	if ((pixel_height) >= (0xFFFFU))
		pixel_height = (uint)(0xFFFFU);
	req.type = (int)(FT_SIZE_REQUEST_TYPE_NOMINAL);
	req.width = ((int)(pixel_width << 6));
	req.height = ((int)(pixel_height << 6));
	req.horiResolution = (uint)(0);
	req.vertResolution = (uint)(0);
	return (int)(FT_Request_Size(face, &req));
}

public static int FT_Get_Kerning(FT_FaceRec_ face, uint left_glyph, uint right_glyph, uint kern_mode, FT_Vector_* akerning)
{
	int error = (int)(FT_Err_Ok);
	FT_DriverRec_* driver;
	if (face == null)
		return (int)(FT_Err_Invalid_Face_Handle);
	if (akerning == null)
		return (int)(FT_Err_Invalid_Argument);
	driver = face.driver;
	akerning->x = (int)(0);
	akerning->y = (int)(0);
	if ((driver->clazz->get_kerning) != null)
	{
		error = (int)(driver->clazz->get_kerning(face, (uint)(left_glyph), (uint)(right_glyph), akerning));
		if (error == 0)
		{
			if (kern_mode != FT_KERNING_UNSCALED)
			{
				akerning->x = (int)(FT_MulFix((int)(akerning->x), (int)(face.size->metrics.x_scale)));
				akerning->y = (int)(FT_MulFix((int)(akerning->y), (int)(face.size->metrics.y_scale)));
				if (kern_mode != FT_KERNING_UNFITTED)
				{
					int orig_x = (int)(akerning->x);
					int orig_y = (int)(akerning->y);
					if ((face.size->metrics.x_ppem) < (25))
						akerning->x = (int)(FT_MulDiv((int)(orig_x), (int)(face.size->metrics.x_ppem), (int)(25)));
					if ((face.size->metrics.y_ppem) < (25))
						akerning->y = (int)(FT_MulDiv((int)(orig_y), (int)(face.size->metrics.y_ppem), (int)(25)));
					akerning->x = (int)(((akerning->x) + 32) & ~63);
					akerning->y = (int)(((akerning->y) + 32) & ~63);
				}
			}
		}
	}

	return (int)(error);
}

public static int FT_Get_Track_Kerning(FT_FaceRec_ face, int point_size, int degree, int* akerning)
{
	FT_Service_KerningRec_* service;
	int error = (int)(FT_Err_Ok);
	if (face == null)
		return (int)(FT_Err_Invalid_Face_Handle);
	if (akerning == null)
		return (int)(FT_Err_Invalid_Argument);
	do
	{
		FT_ModuleRec_ module = ((FT_ModuleRec_)((face).driver));
		void* _tmp_ = null;
		if ((module.clazz.get_interface) != null)
			_tmp_ = module.clazz.get_interface(module, "kerning");
		service = _tmp_;
	}
	while ((0) != 0);
	if (service == null)
		return (int)(FT_Err_Unimplemented_Feature);
	error = (int)(service->get_track(face, (int)(point_size), (int)(degree), akerning));
	return (int)(error);
}

public static int FT_Select_Charmap(FT_FaceRec_ face, int encoding)
{
	FT_CharMapRec_ cur;
	FT_CharMapRec_ limit;
	if (face == null)
		return (int)(FT_Err_Invalid_Face_Handle);
	if (((encoding) == (FT_ENCODING_NONE)) && (face.num_charmaps == 0))
		return (int)(FT_Err_Invalid_Argument);
	if ((encoding) == (FT_ENCODING_UNICODE))
		return (int)(find_unicode_charmap(face));
	cur = face.charmaps;
	if (cur == null)
		return (int)(FT_Err_Invalid_CharMap_Handle);
	limit = cur[face.num_charmaps];
	for (; (cur) < (limit); cur++)
	{
		if ((cur[0].encoding) == (encoding))
		{
			face.charmap = cur[0];
			return (int)(FT_Err_Ok);
		}
	}
	return (int)(FT_Err_Invalid_Argument);
}

public static int FT_Set_Charmap(FT_FaceRec_ face, FT_CharMapRec_ charmap)
{
	FT_CharMapRec_ cur;
	FT_CharMapRec_ limit;
	if (face == null)
		return (int)(FT_Err_Invalid_Face_Handle);
	cur = face.charmaps;
	if ((cur == null) || (charmap == null))
		return (int)(FT_Err_Invalid_CharMap_Handle);
	limit = cur[face.num_charmaps];
	for (; (cur) < (limit); cur++)
	{
		if (((cur[0]) == (charmap)) && (FT_Get_CMap_Format(charmap) != 14))
		{
			face.charmap = cur[0];
			return (int)(FT_Err_Ok);
		}
	}
	return (int)(FT_Err_Invalid_Argument);
}

public static int FT_Get_Charmap_Index(FT_CharMapRec_ charmap)
{
	int i = 0;
	if ((charmap == null) || (charmap.face == null))
		return (int)(-1);
	for (i = (int)(0); (i) < (charmap.face.num_charmaps); i++)
	{ if ((charmap.face.charmaps[i]) == (charmap)) break; }
	do
	{
	}
	while ((0) != 0);
	return (int)(i);
}

public static void ft_cmap_done_internal(FT_CMapRec_* cmap)
{
	FT_CMap_ClassRec_* clazz = cmap->clazz;
	FT_FaceRec_ face = cmap->charmap.face;
	FT_MemoryRec_ memory = (face).memory;
	if ((clazz->done) != null)
		clazz->done(cmap);
	do
	{
		(ft_mem_free(memory, (cmap)));
		(cmap) = null;
	}
	while ((0) != 0);
}

public static void FT_CMap_Done(FT_CMapRec_* cmap)
{
	if ((cmap) != null)
	{
		FT_FaceRec_ face = cmap->charmap.face;
		FT_MemoryRec_ memory = (face).memory;
		int error = 0;
		int i = 0;
		int j = 0;
		for (i = (int)(0); (i) < (face.num_charmaps); i++)
		{
			if (((FT_CMapRec_*)(face.charmaps[i])) == (cmap))
			{
				FT_CharMapRec_ last_charmap = face.charmaps[face.num_charmaps - 1];
				if ((((face.charmaps) = (ft_mem_realloc(memory, (int)(sizeof((face.charmaps))), (int)(face.num_charmaps), (int)(face.num_charmaps - 1), (face.charmaps), &error))), error != 0))
					return;
				for (j = (int)(i + 1); (j) < (face.num_charmaps); j++)
				{
					if ((j) == (face.num_charmaps - 1))
						face.charmaps[j - 1] = last_charmap;
					else
						face.charmaps[j - 1] = face.charmaps[j];
				}
				face.num_charmaps--;
				if (((FT_CMapRec_*)(face.charmap)) == (cmap))
					face.charmap = null;
				ft_cmap_done_internal(cmap);
				break;
			}
		}
	}

}

public static int FT_CMap_New(FT_CMap_ClassRec_* clazz, void* init_data, FT_CharMapRec_ charmap, FT_CMapRec_** acmap)
{
	int error = (int)(FT_Err_Ok);
	FT_FaceRec_ face;
	FT_MemoryRec_ memory;
	FT_CMapRec_* cmap = null;
	if (((clazz == null) || (charmap == null)) || (charmap.face == null))
		return (int)(FT_Err_Invalid_Argument);
	face = charmap.face;
	memory = (face).memory;
	if (!(((cmap) = (ft_mem_alloc(memory, (int)(clazz->size), &error))), error != 0))
	{
		cmap->charmap = (FT_CharMapRec_)(charmap);
		cmap->clazz = clazz;
		if ((clazz->init) != null)
		{
			error = (int)(clazz->init(cmap, init_data));
			if ((error) != 0)
				goto Fail;
		}
		if ((((face.charmaps) = (ft_mem_realloc(memory, (int)(sizeof((face.charmaps))), (int)(face.num_charmaps), (int)(face.num_charmaps + 1), (face.charmaps), &error))), error != 0))
			goto Fail;
		face.charmaps[face.num_charmaps++] = (FT_CharMapRec_)(cmap);
	}

Exit:
	;
	if ((acmap) != null)
		*acmap = cmap;
	return (int)(error);
Fail:
	;
	ft_cmap_done_internal(cmap);
	cmap = null;
	goto Exit;
}

public static uint FT_Get_Char_Index(FT_FaceRec_ face, int charcode)
{
	uint result = (uint)(0);
	if (((face) != null) && ((face.charmap) != null))
	{
		FT_CMapRec_* cmap = ((FT_CMapRec_*)(face.charmap));
		if ((charcode) > (0xFFFFFFFFU))
		{
			do
			{
			}
			while ((0) != 0);
			do
			{
			}
			while ((0) != 0);
		}
		result = (uint)(cmap->clazz->char_index(cmap, (uint)(charcode)));
		if ((result) >= ((uint)(face.num_glyphs)))
			result = (uint)(0);
	}

	return (uint)(result);
}

public static int FT_Get_First_Char(FT_FaceRec_ face, uint* agindex)
{
	int result = (int)(0);
	uint gindex = (uint)(0);
	if ((((face) != null) && ((face.charmap) != null)) && ((face.num_glyphs) != 0))
	{
		gindex = (uint)(FT_Get_Char_Index(face, (int)(0)));
		if ((gindex) == (0))
			result = (int)(FT_Get_Next_Char(face, (int)(0), &gindex));
	}

	if ((agindex) != null)
		*agindex = (uint)(gindex);
	return (int)(result);
}

public static int FT_Get_Next_Char(FT_FaceRec_ face, int charcode, uint* agindex)
{
	int result = (int)(0);
	uint gindex = (uint)(0);
	if ((((face) != null) && ((face.charmap) != null)) && ((face.num_glyphs) != 0))
	{
		uint code = (uint)(charcode);
		FT_CMapRec_* cmap = ((FT_CMapRec_*)(face.charmap));
		do
		{
			gindex = (uint)(cmap->clazz->char_next(cmap, &code));
		}
		while ((gindex) >= ((uint)(face.num_glyphs)));
		result = (int)(((gindex) == (0)) ? 0 : code);
	}

	if ((agindex) != null)
		*agindex = (uint)(gindex);
	return (int)(result);
}

public static int FT_Face_Properties(FT_FaceRec_ face, uint num_properties, FT_Parameter_* properties)
{
	int error = (int)(FT_Err_Ok);
	if (((num_properties) > (0)) && (properties == null))
	{
		error = (int)(FT_Err_Invalid_Argument);
		goto Exit;
	}

	for (; (num_properties) > (0); num_properties--)
	{
		if ((properties->tag) == ((uint)(('d' << 24) | ('a' << 16) | ('r' << 8) | 'k')))
		{
			if ((properties->data) != null)
			{
				if ((*((byte*)(properties->data))) == (1))
					face.internal->no_stem_darkening = (sbyte)(0); else face.internal->no_stem_darkening = (sbyte)(1);}
 else
{
	face.internal->no_stem_darkening = (sbyte)(-1);}
}
 else if ((properties->tag) == ((uint)(('l' << 24) | ('c' << 16) | ('d' << 8) | 'f')))
{
	error = (int)(FT_Err_Unimplemented_Feature);
	goto Exit;
}
else if ((properties->tag) == ((uint)(('s' << 24) | ('e' << 16) | ('e' << 8) | 'd')))
{
	if ((properties->data) != null)
	{
		face.internal->random_seed = (int)(*((int*)(properties->data)));
if ((face.internal->random_seed) < (0)) face.internal->random_seed = (int)(0);}
 else
{
	face.internal->random_seed = (int)(-1);}
}
 else
{
	error = (int)(FT_Err_Invalid_Argument);
	goto Exit;
}
if ((error) != 0) break;
properties++;}
			Exit:;
return (int)(error);
		}

		public static uint FT_Face_GetCharVariantIndex(FT_FaceRec_ face, int charcode, int variantSelector)
{
	uint result = (uint)(0);
	if ((((face) != null) && ((face.charmap) != null)) && ((face.charmap.encoding) == (FT_ENCODING_UNICODE)))
	{
		FT_CharMapRec_ charmap = find_variant_selector_charmap(face);
		FT_CMapRec_* ucmap = ((FT_CMapRec_*)(face.charmap));
		if ((charmap) != null)
		{
			FT_CMapRec_* vcmap = ((FT_CMapRec_*)(charmap));
			if ((charcode) > (0xFFFFFFFFU))
			{
				do
				{
				}
				while ((0) != 0);
				do
				{
				}
				while ((0) != 0);
			}
			if ((variantSelector) > (0xFFFFFFFFU))
			{
				do
				{
				}
				while ((0) != 0);
				do
				{
				}
				while ((0) != 0);
			}
			result = (uint)(vcmap->clazz->char_var_index(vcmap, ucmap, (uint)(charcode), (uint)(variantSelector)));
		}
	}

	return (uint)(result);
}

public static int FT_Face_GetCharVariantIsDefault(FT_FaceRec_ face, int charcode, int variantSelector)
{
	int result = (int)(-1);
	if ((face) != null)
	{
		FT_CharMapRec_ charmap = find_variant_selector_charmap(face);
		if ((charmap) != null)
		{
			FT_CMapRec_* vcmap = ((FT_CMapRec_*)(charmap));
			if ((charcode) > (0xFFFFFFFFU))
			{
				do
				{
				}
				while ((0) != 0);
				do
				{
				}
				while ((0) != 0);
			}
			if ((variantSelector) > (0xFFFFFFFFU))
			{
				do
				{
				}
				while ((0) != 0);
				do
				{
				}
				while ((0) != 0);
			}
			result = (int)(vcmap->clazz->char_var_default(vcmap, (uint)(charcode), (uint)(variantSelector)));
		}
	}

	return (int)(result);
}

public static uint* FT_Face_GetVariantSelectors(FT_FaceRec_ face)
{
	uint* result = null;
	if ((face) != null)
	{
		FT_CharMapRec_ charmap = find_variant_selector_charmap(face);
		if ((charmap) != null)
		{
			FT_CMapRec_* vcmap = ((FT_CMapRec_*)(charmap));
			FT_MemoryRec_ memory = (face).memory;
			result = vcmap->clazz->variant_list(vcmap, memory);
		}
	}

	return result;
}

public static uint* FT_Face_GetVariantsOfChar(FT_FaceRec_ face, int charcode)
{
	uint* result = null;
	if ((face) != null)
	{
		FT_CharMapRec_ charmap = find_variant_selector_charmap(face);
		if ((charmap) != null)
		{
			FT_CMapRec_* vcmap = ((FT_CMapRec_*)(charmap));
			FT_MemoryRec_ memory = (face).memory;
			if ((charcode) > (0xFFFFFFFFU))
			{
				do
				{
				}
				while ((0) != 0);
				do
				{
				}
				while ((0) != 0);
			}
			result = vcmap->clazz->charvariant_list(vcmap, memory, (uint)(charcode));
		}
	}

	return result;
}

public static uint* FT_Face_GetCharsOfVariant(FT_FaceRec_ face, int variantSelector)
{
	uint* result = null;
	if ((face) != null)
	{
		FT_CharMapRec_ charmap = find_variant_selector_charmap(face);
		if ((charmap) != null)
		{
			FT_CMapRec_* vcmap = ((FT_CMapRec_*)(charmap));
			FT_MemoryRec_ memory = (face).memory;
			if ((variantSelector) > (0xFFFFFFFFU))
			{
				do
				{
				}
				while ((0) != 0);
				do
				{
				}
				while ((0) != 0);
			}
			result = vcmap->clazz->variantchar_list(vcmap, memory, (uint)(variantSelector));
		}
	}

	return result;
}

public static uint FT_Get_Name_Index(FT_FaceRec_ face, sbyte* glyph_name)
{
	uint result = (uint)(0);
	if ((((face) != null) && (!!((face).face_flags & (1 << 9)))) && ((glyph_name) != null))
	{
		FT_Service_GlyphDictRec_* service;
		do
		{
			void* svc;
			svc = (face).internal->services.service_GLYPH_DICT;
if ((svc) == ((void*)(~(long)(1))))
	svc = null;
else if ((svc) == null)
{
	do
	{
		FT_ModuleRec_ module = ((FT_ModuleRec_)((face).driver));
		void* _tmp_ = null;
		if ((module.clazz.get_interface) != null)
			_tmp_ = module.clazz.get_interface(module, "glyph-dict");
		svc = _tmp_;
	}
	while ((0) != 0);
	(face).internal->services.service_GLYPH_DICT = (svc != null ? svc : ((void*)(~(long)(1))));}
service = svc;}
 while ((0) != 0) ;
if (((service) != null) && ((service->name_index) != null)) result = (uint)(service->name_index(face, glyph_name));}

			return (uint)(result);
		}

		public static int FT_Get_Glyph_Name(FT_FaceRec_ face, uint glyph_index, void* buffer, uint buffer_max)
{
	int error = 0;
	FT_Service_GlyphDictRec_* service;
	if (face == null)
		return (int)(FT_Err_Invalid_Face_Handle);
	if ((buffer == null) || ((buffer_max) == (0)))
		return (int)(FT_Err_Invalid_Argument);
	((byte*)(buffer))[0] = (byte)('\0');
	if (((int)(glyph_index)) >= (face.num_glyphs))
		return (int)(FT_Err_Invalid_Glyph_Index);
	if (!(!!((face).face_flags & (1 << 9))))
		return (int)(FT_Err_Invalid_Argument);
	do
	{
		void* svc;
		svc = (face).internal->services.service_GLYPH_DICT;
if ((svc) == ((void*)(~(long)(1))))
	svc = null;
else if ((svc) == null)
{
	do
	{
		FT_ModuleRec_ module = ((FT_ModuleRec_)((face).driver));
		void* _tmp_ = null;
		if ((module.clazz.get_interface) != null)
			_tmp_ = module.clazz.get_interface(module, "glyph-dict");
		svc = _tmp_;
	}
	while ((0) != 0);
	(face).internal->services.service_GLYPH_DICT = (svc != null ? svc : ((void*)(~(long)(1))));}
service = svc;}
 while ((0) != 0) ;
if (((service) != null) && ((service->get_name) != null)) error = (int)(service->get_name(face, (uint)(glyph_index), buffer, (uint)(buffer_max))); else error = (int)(FT_Err_Invalid_Argument);
return (int)(error);
		}

		public static sbyte* FT_Get_Postscript_Name(FT_FaceRec_ face)
{
	sbyte* result = null;
	if (face == null)
		goto Exit;
	if (result == null)
	{
		FT_Service_PsFontNameRec_* service;
		do
		{
			void* svc;
			svc = (face).internal->services.service_POSTSCRIPT_FONT_NAME;
if ((svc) == ((void*)(~(long)(1))))
	svc = null;
else if ((svc) == null)
{
	do
	{
		FT_ModuleRec_ module = ((FT_ModuleRec_)((face).driver));
		void* _tmp_ = null;
		if ((module.clazz.get_interface) != null)
			_tmp_ = module.clazz.get_interface(module, "postscript-font-name");
		svc = _tmp_;
	}
	while ((0) != 0);
	(face).internal->services.service_POSTSCRIPT_FONT_NAME = (svc != null ? svc : ((void*)(~(long)(1))));}
service = svc;}
 while ((0) != 0) ;
if (((service) != null) && ((service->get_ps_font_name) != null)) result = service->get_ps_font_name(face);}

			Exit:;
return result;
		}

		public static void* FT_Get_Sfnt_Table(FT_FaceRec_ face, int tag)
{
	void* table = null;
	FT_Service_SFNT_TableRec_* service;
	if (((face) != null) && (!!((face).face_flags & (1 << 3))))
	{
		do
		{
			FT_ModuleRec_ module = ((FT_ModuleRec_)((face).driver));
			void* _tmp_ = null;
			if ((module.clazz.get_interface) != null)
				_tmp_ = module.clazz.get_interface(module, "sfnt-table");
			service = _tmp_;
		}
		while ((0) != 0);
		if ((service) != null)
			table = service->get_table(face, (int)(tag));
	}

	return table;
}

public static int FT_Load_Sfnt_Table(FT_FaceRec_ face, int tag, int offset, byte* buffer, int* length)
{
	FT_Service_SFNT_TableRec_* service;
	if ((face == null) || (!(!!((face).face_flags & (1 << 3)))))
		return (int)(FT_Err_Invalid_Face_Handle);
	do
	{
		FT_ModuleRec_ module = ((FT_ModuleRec_)((face).driver));
		void* _tmp_ = null;
		if ((module.clazz.get_interface) != null)
			_tmp_ = module.clazz.get_interface(module, "sfnt-table");
		service = _tmp_;
	}
	while ((0) != 0);
	if (service == null)
		return (int)(FT_Err_Unimplemented_Feature);
	return (int)(service->load_table(face, (int)(tag), (int)(offset), buffer, length));
}

public static int FT_Sfnt_Table_Info(FT_FaceRec_ face, uint table_index, int* tag, int* length)
{
	FT_Service_SFNT_TableRec_* service;
	int offset = 0;
	if ((face == null) || (!(!!((face).face_flags & (1 << 3)))))
		return (int)(FT_Err_Invalid_Face_Handle);
	do
	{
		FT_ModuleRec_ module = ((FT_ModuleRec_)((face).driver));
		void* _tmp_ = null;
		if ((module.clazz.get_interface) != null)
			_tmp_ = module.clazz.get_interface(module, "sfnt-table");
		service = _tmp_;
	}
	while ((0) != 0);
	if (service == null)
		return (int)(FT_Err_Unimplemented_Feature);
	return (int)(service->table_info(face, (uint)(table_index), tag, &offset, length));
}

public static int FT_Get_CMap_Language_ID(FT_CharMapRec_ charmap)
{
	FT_Service_TTCMapsRec_* service;
	FT_FaceRec_ face;
	TT_CMapInfo_ cmap_info = new TT_CMapInfo_();
	if ((charmap == null) || (charmap.face == null))
		return (int)(0);
	face = charmap.face;
	do
	{
		FT_ModuleRec_ module = ((FT_ModuleRec_)((face).driver));
		void* _tmp_ = null;
		if ((module.clazz.get_interface) != null)
			_tmp_ = module.clazz.get_interface(module, "tt-cmaps");
		service = _tmp_;
	}
	while ((0) != 0);
	if (service == null)
		return (int)(0);
	if ((service->get_cmap_info(charmap, &cmap_info)) != 0)
		return (int)(0);
	return (int)(cmap_info.language);
}

public static int FT_Get_CMap_Format(FT_CharMapRec_ charmap)
{
	FT_Service_TTCMapsRec_* service;
	FT_FaceRec_ face;
	TT_CMapInfo_ cmap_info = new TT_CMapInfo_();
	if ((charmap == null) || (charmap.face == null))
		return (int)(-1);
	face = charmap.face;
	do
	{
		FT_ModuleRec_ module = ((FT_ModuleRec_)((face).driver));
		void* _tmp_ = null;
		if ((module.clazz.get_interface) != null)
			_tmp_ = module.clazz.get_interface(module, "tt-cmaps");
		service = _tmp_;
	}
	while ((0) != 0);
	if (service == null)
		return (int)(-1);
	if ((service->get_cmap_info(charmap, &cmap_info)) != 0)
		return (int)(-1);
	return (int)(cmap_info.format);
}

public static int FT_Activate_Size(FT_SizeRec_* size)
{
	FT_FaceRec_ face;
	if (size == null)
		return (int)(FT_Err_Invalid_Size_Handle);
	face = size->face;
	if ((face == null) || (face.driver == null))
		return (int)(FT_Err_Invalid_Face_Handle);
	face.size = size;
	return (int)(FT_Err_Ok);
}

public static FT_RendererRec_ FT_Lookup_Renderer(FT_LibraryRec_ library, int format, FT_ListNodeRec_** node)
{
	FT_ListNodeRec_* cur;
	FT_RendererRec_ result = null;
	if (library == null)
		goto Exit;
	cur = library.renderers.head;
	if ((node) != null)
	{
		if ((*node) != null)
			cur = (*node)->next;
		*node = null;
	}

	while ((cur) != null)
	{
		FT_RendererRec_ renderer = ((FT_RendererRec_)(cur->data));
		if ((renderer.glyph_format) == (format))
		{
			if ((node) != null)
				*node = cur;
			result = renderer;
			break;
		}
		cur = cur->next;
	}
Exit:
	;
	return result;
}

public static FT_RendererRec_ ft_lookup_glyph_renderer(FT_GlyphSlotRec_* slot)
{
	FT_FaceRec_ face = slot->face;
	FT_LibraryRec_ library = (face).driver->root.library;
	FT_RendererRec_ result = library.cur_renderer;
	if ((result == null) || (result.glyph_format != slot->format))
		result = FT_Lookup_Renderer(library, (int)(slot->format), null);
	return result;
}

public static void ft_set_current_renderer(FT_LibraryRec_ library)
{
	FT_RendererRec_ renderer;
	renderer = FT_Lookup_Renderer(library, (int)(FT_GLYPH_FORMAT_OUTLINE), null);
	library.cur_renderer = renderer;
}

public static int ft_add_renderer(FT_ModuleRec_ module)
{
	FT_LibraryRec_ library = module.library;
	FT_MemoryRec_ memory = library.memory;
	int error = 0;
	FT_ListNodeRec_* node = null;
	if ((((node) = (ft_mem_alloc(memory, (int)(sizeof((*(node)))), &error))) , error != 0)) goto Exit;
{
	FT_RendererRec_ render = ((FT_RendererRec_)(module));
	FT_Renderer_Class_ clazz = (FT_Renderer_Class_)(module.clazz);
	render.clazz = clazz;
	render.glyph_format = (int)(clazz.glyph_format);
	if (((clazz.glyph_format) == (FT_GLYPH_FORMAT_OUTLINE)) && ((clazz.raster_class->raster_new) != null))
	{
		error = (int)(clazz.raster_class->raster_new(memory, &render.raster));
		if ((error) != 0)
			goto Fail;
		render.raster_render = clazz.raster_class->raster_render;
		render.render = clazz.render_glyph;
	}
	node->data = module;
	FT_List_Add(&library.renderers, node);
	ft_set_current_renderer(library);
}

Fail:;
if ((error) != 0)
	do
	{
		(ft_mem_free(memory, (node)));
		(node) = null;
	}
	while ((0) != 0);
Exit:;
return (int)(error);
		}

		public static void ft_remove_renderer(FT_ModuleRec_ module)
{
	FT_LibraryRec_ library;
	FT_MemoryRec_ memory;
	FT_ListNodeRec_* node;
	library = module.library;
	if (library == null)
		return;
	memory = library.memory;
	node = FT_List_Find(&library.renderers, module);
	if ((node) != null)
	{
		FT_RendererRec_ render = ((FT_RendererRec_)(module));
		if (((render.clazz.glyph_format) == (FT_GLYPH_FORMAT_OUTLINE)) && ((render.raster) != null))
			render.clazz.raster_class->raster_done(render.raster);
		FT_List_Remove(&library.renderers, node);
		do
		{
			(ft_mem_free(memory, (node)));
			(node) = null;
		}
		while ((0) != 0);
		ft_set_current_renderer(library);
	}

}

public static FT_RendererRec_ FT_Get_Renderer(FT_LibraryRec_ library, int format)
{
	return FT_Lookup_Renderer(library, (int)(format), null);
}

public static int FT_Set_Renderer(FT_LibraryRec_ library, FT_RendererRec_ renderer, uint num_params, FT_Parameter_* parameters)
{
	FT_ListNodeRec_* node;
	int error = (int)(FT_Err_Ok);
	int(FT_RendererRec_ *, unsigned long, void *) * set_mode;
	if (library == null)
	{
		error = (int)(FT_Err_Invalid_Library_Handle);
		goto Exit;
	}

	if (renderer == null)
	{
		error = (int)(FT_Err_Invalid_Argument);
		goto Exit;
	}

	if (((num_params) > (0)) && (parameters == null))
	{
		error = (int)(FT_Err_Invalid_Argument);
		goto Exit;
	}

	node = FT_List_Find(&library.renderers, renderer);
	if (node == null)
	{
		error = (int)(FT_Err_Invalid_Argument);
		goto Exit;
	}

	FT_List_Up(&library.renderers, node);
	if ((renderer.glyph_format) == (FT_GLYPH_FORMAT_OUTLINE))
		library.cur_renderer = renderer;
	set_mode = renderer.clazz.set_mode;
	for (; (num_params) > (0); num_params--)
	{
		error = (int)(set_mode(renderer, (int)(parameters->tag), parameters->data));
		if ((error) != 0)
			break;
		parameters++;
	}
Exit:
	;
	return (int)(error);
}

public static int FT_Render_Glyph_Internal(FT_LibraryRec_ library, FT_GlyphSlotRec_* slot, int render_mode)
{
	int error = (int)(FT_Err_Ok);
	FT_FaceRec_ face = slot->face;
	FT_RendererRec_ renderer;
	switch (slot->format)
	{
		case FT_GLYPH_FORMAT_BITMAP:
			break;
		default:
			if ((slot->internal->load_flags & (1 << 20)) != 0) {
	FT_LayerIterator_ iterator = new FT_LayerIterator_();
	uint base_glyph = (uint)(slot->glyph_index);
	byte have_layers = 0;
	uint glyph_index = 0;
	uint color_index = 0;
	iterator.p = null;
	have_layers = (byte)(FT_Get_Color_Glyph_Layer(face, (uint)(base_glyph), &glyph_index, &color_index, &iterator));
	if ((have_layers) != 0)
	{
		error = (int)(FT_New_GlyphSlot(face, null));
		if (error == 0)
		{
			TT_FaceRec_* ttface = (TT_FaceRec_*)(face);
			SFNT_Interface_* sfnt = (SFNT_Interface_*)(ttface->sfnt);
			do
			{
				int load_flags = (int)(slot->internal->load_flags);
load_flags &= (int)(~(1 << 20));
load_flags |= (int)(1 << 2);
error = (int)(FT_Load_Glyph(face, (uint)(glyph_index), (int)(load_flags)));
if ((error) != 0) break;
error = (int)(sfnt->colr_blend(ttface, (uint)(color_index), slot, face.glyph));
if ((error) != 0) break;}
 while ((FT_Get_Color_Glyph_Layer(face, (uint)(base_glyph), &glyph_index, &color_index, &iterator)) != 0) ;
if (error == 0) slot->format = (int)(FT_GLYPH_FORMAT_BITMAP);
FT_Done_GlyphSlot(face.glyph);}
if (error == 0) return (int)(error);
slot->format = (int)(FT_GLYPH_FORMAT_OUTLINE);}
}
{
	FT_ListNodeRec_* node = null;
	if ((slot->format) == (FT_GLYPH_FORMAT_OUTLINE))
	{
		renderer = library.cur_renderer;
		node = library.renderers.head;
	}
	else
		renderer = FT_Lookup_Renderer(library, (int)(slot->format), &node);
	error = (int)(FT_Err_Unimplemented_Feature);
	while ((renderer) != null)
	{
		error = (int)(renderer.render(renderer, slot, (int)(render_mode), null));
		if ((error == 0) || (((error) & 255) != ((FT_Err_Cannot_Render_Glyph) & 255)))
			break;
		renderer = FT_Lookup_Renderer(library, (int)(slot->format), &node);
	}
}
}

			return (int)(error);
		}

		public static int FT_Render_Glyph(FT_GlyphSlotRec_* slot, int render_mode)
{
	FT_LibraryRec_ library;
	if ((slot == null) || (slot->face == null))
		return (int)(FT_Err_Invalid_Argument);
	library = (slot->face).driver->root.library;
	return (int)(FT_Render_Glyph_Internal(library, slot, (int)(render_mode)));
}

public static void Destroy_Module(FT_ModuleRec_ module)
{
	FT_MemoryRec_ memory = module.memory;
	FT_Module_Class_ clazz = module.clazz;
	FT_LibraryRec_ library = module.library;
	if (((library) != null) && ((library.auto_hinter) == (module)))
		library.auto_hinter = null;
	if (((module).clazz.module_flags & 2) != 0)
		ft_remove_renderer(module);
	if (((module).clazz.module_flags & 1) != 0)
		Destroy_Driver(((FT_DriverRec_*)(module)));
	if ((clazz.module_done) != null)
		clazz.module_done(module);
	do
	{
		(ft_mem_free(memory, (module)));
		(module) = null;
	}
	while ((0) != 0);
}

public static int FT_Add_Module(FT_LibraryRec_ library, FT_Module_Class_ clazz)
{
	int error = 0;
	FT_MemoryRec_ memory;
	FT_ModuleRec_ module = null;
	uint nn = 0;
	if (library == null)
		return (int)(FT_Err_Invalid_Library_Handle);
	if (clazz == null)
		return (int)(FT_Err_Invalid_Argument);
	if ((clazz.module_requires) > ((2 << 16) | 10))
		return (int)(FT_Err_Invalid_Version);
	for (nn = (uint)(0); (nn) < (library.num_modules); nn++)
	{
		module = library.modules[nn];
		if ((strcmp(module.clazz.module_name, clazz.module_name)) == (0))
		{
			if (clazz.module_version <= module.clazz.module_version)
				return (int)(FT_Err_Lower_Module_Version);
			FT_Remove_Module(library, module);
			break;
		}
	}
	memory = library.memory;
	error = (int)(FT_Err_Ok);
	if ((library.num_modules) >= (32))
	{
		error = (int)(FT_Err_Too_Many_Drivers);
		goto Exit;
	}

	if ((((module) = (ft_mem_alloc(memory, (int)(clazz.module_size), &error))), error != 0))
		goto Exit;
	module.library = library;
	module.memory = memory;
	module.clazz = clazz;
	if (((module).clazz.module_flags & 2) != 0)
	{
		error = (int)(ft_add_renderer(module));
		if ((error) != 0)
			goto Fail;
	}

	if (((module).clazz.module_flags & 4) != 0)
		library.auto_hinter = module;
	if (((module).clazz.module_flags & 1) != 0)
	{
		FT_DriverRec_* driver = ((FT_DriverRec_*)(module));
		driver->clazz = (FT_Driver_ClassRec_*)(module.clazz);
	}

	if ((clazz.module_init) != null)
	{
		error = (int)(clazz.module_init(module));
		if ((error) != 0)
			goto Fail;
	}

	library.modules[library.num_modules++] = module;
Exit:
	;
	return (int)(error);
Fail:
	;
	if (((module).clazz.module_flags & 2) != 0)
	{
		FT_RendererRec_ renderer = ((FT_RendererRec_)(module));
		if ((((renderer.clazz) != null) && ((renderer.clazz.glyph_format) == (FT_GLYPH_FORMAT_OUTLINE))) && ((renderer.raster) != null))
			renderer.clazz.raster_class->raster_done(renderer.raster);
	}

	do
	{
		(ft_mem_free(memory, (module)));
		(module) = null;
	}
	while ((0) != 0);
	goto Exit;
}

public static FT_ModuleRec_ FT_Get_Module(FT_LibraryRec_ library, sbyte* module_name)
{
	FT_ModuleRec_ result = null;
	FT_ModuleRec_ cur;
	FT_ModuleRec_ limit;
	if ((library == null) || (module_name == null))
		return result;
	cur = library.modules;
	limit = cur[library.num_modules];
	for (; (cur) < (limit); cur++)
	{
		if ((strcmp(cur[0].clazz.module_name, module_name)) == (0))
		{
			result = cur[0];
			break;
		}
	}
	return result;
}

public static void* FT_Get_Module_Interface(FT_LibraryRec_ library, sbyte* mod_name)
{
	FT_ModuleRec_ module;
	module = FT_Get_Module(library, mod_name);
	return module ? module.clazz.module_interface : null;
}

public static void* ft_module_get_service(FT_ModuleRec_ module, sbyte* service_id, byte global)
{
	void* result = null;
	if ((module) != null)
	{
		do
		{
		}
		while ((0) != 0);
		if ((module.clazz.get_interface) != null)
			result = module.clazz.get_interface(module, service_id);
		if (((global) != 0) && (result == null))
		{
			FT_LibraryRec_ library = module.library;
			FT_ModuleRec_ cur = library.modules;
			FT_ModuleRec_ limit = cur[library.num_modules];
			for (; (cur) < (limit); cur++)
			{
				if (cur[0] != module)
				{
					do
					{
					}
					while ((0) != 0);
					if ((cur[0].clazz.get_interface) != null)
					{
						result = cur[0].clazz.get_interface(cur[0], service_id);
						if ((result) != null)
							break;
					}
				}
			}
		}
	}

	return result;
}

public static int FT_Remove_Module(FT_LibraryRec_ library, FT_ModuleRec_ module)
{
	if (library == null)
		return (int)(FT_Err_Invalid_Library_Handle);
	if ((module) != null)
	{
		FT_ModuleRec_ cur = library.modules;
		FT_ModuleRec_ limit = cur[library.num_modules];
		for (; (cur) < (limit); cur++)
		{
			if ((cur[0]) == (module))
			{
				library.num_modules--;
				limit--;
				while ((cur) < (limit))
				{
					cur[0] = cur[1];
					cur++;
				}
				limit[0] = null;
				Destroy_Module(module);
				return (int)(FT_Err_Ok);
			}
		}
	}

	return (int)(FT_Err_Invalid_Driver_Handle);
}

public static int ft_property_do(FT_LibraryRec_ library, sbyte* module_name, sbyte* property_name, void* value, byte set, byte value_is_string)
{
	FT_ModuleRec_ cur;
	FT_ModuleRec_ limit;
	void* interface;
FT_Service_PropertiesRec_* service;
byte missing_func = 0;
if (library == null) return (int)(FT_Err_Invalid_Library_Handle);
if (((module_name == null) || (property_name == null)) || (value == null)) return (int)(FT_Err_Invalid_Argument);
cur = library.modules;
limit = cur[library.num_modules];
for (; (cur) < (limit); cur++) { if (strcmp(cur[0].clazz.module_name, module_name) == 0) break; }
if ((cur) == (limit))
{
	do
	{
	}
	while ((0) != 0);
	return (int)(FT_Err_Missing_Module);
}

if (cur[0].clazz.get_interface == null)
{
	do
	{
	}
	while ((0) != 0);
	return (int)(FT_Err_Unimplemented_Feature);
}

interface = cur[0].clazz.get_interface(cur[0], "properties");
if (interface== null) {
	do
	{
	}
	while ((0) != 0);
	return (int)(FT_Err_Unimplemented_Feature);
}

service = (FT_Service_PropertiesRec_*)(interface);
if ((set) != 0) missing_func = ((byte)((!service->set_property) != 0)); else missing_func = ((byte)((!service->get_property) != 0));
if ((missing_func) != 0)
{
	do
	{
	}
	while ((0) != 0);
	return (int)(FT_Err_Unimplemented_Feature);
}

return (int)((set) != 0 ? service->set_property(cur[0], property_name, value, (byte)(value_is_string)) : service->get_property(cur[0], property_name, value));
		}

		public static int FT_Property_Set(FT_LibraryRec_ library, sbyte* module_name, sbyte* property_name, void* value)
{
	return (int)(ft_property_do(library, module_name, property_name, value, (byte)(1), (byte)(0)));
}

public static int FT_Property_Get(FT_LibraryRec_ library, sbyte* module_name, sbyte* property_name, void* value)
{
	return (int)(ft_property_do(library, module_name, property_name, value, (byte)(0), (byte)(0)));
}

public static int ft_property_string_set(FT_LibraryRec_ library, sbyte* module_name, sbyte* property_name, sbyte* value)
{
	return (int)(ft_property_do(library, module_name, property_name, (void*)(value), (byte)(1), (byte)(1)));
}

public static int FT_Reference_Library(FT_LibraryRec_ library)
{
	if (library == null)
		return (int)(FT_Err_Invalid_Library_Handle);
	library.refcount++;
	return (int)(FT_Err_Ok);
}

public static int FT_New_Library(FT_MemoryRec_ memory, FT_LibraryRec_ alibrary)
{
	FT_LibraryRec_ library = null;
	int error = 0;
	if ((memory == null) || (alibrary == null))
		return (int)(FT_Err_Invalid_Argument);
	if ((((library) = (ft_mem_alloc(memory, (int)(sizeof((library))), &error))), error != 0))
		return (int)(error);
	library.memory = memory;
	library.version_major = (int)(2);
	library.version_minor = (int)(10);
	library.version_patch = (int)(4);
	library.refcount = (int)(1);
	alibrary = library;
	return (int)(FT_Err_Ok);
}

public static void FT_Library_Version(FT_LibraryRec_ library, int* amajor, int* aminor, int* apatch)
{
	int major = (int)(0);
	int minor = (int)(0);
	int patch = (int)(0);
	if ((library) != null)
	{
		major = (int)(library.version_major);
		minor = (int)(library.version_minor);
		patch = (int)(library.version_patch);
	}

	if ((amajor) != null)
		*amajor = (int)(major);
	if ((aminor) != null)
		*aminor = (int)(minor);
	if ((apatch) != null)
		*apatch = (int)(patch);
}

public static int FT_Done_Library(FT_LibraryRec_ library)
{
	FT_MemoryRec_ memory;
	if (library == null)
		return (int)(FT_Err_Invalid_Library_Handle);
	library.refcount--;
	if ((library.refcount) > (0))
		goto Exit;
	memory = library.memory;
	{
		uint m = 0;
		uint n = 0;
		sbyte** driver_name = stackalloc sbyte[2];
		driver_name[0] = "type42";
		driver_name[1] = null;
		for (m = (uint)(0); (m) < (sizeof((driver_name)) / sizeof((driver_name[0]))); m++)
		{
			for (n = (uint)(0); (n) < (library.num_modules); n++)
			{
				FT_ModuleRec_ module = library.modules[n];
				sbyte* module_name = module.clazz.module_name;
				FT_ListRec_* faces;
				if (((driver_name[m]) != null) && (strcmp(module_name, driver_name[m]) != 0))
					continue;
				if ((module.clazz.module_flags & 1) == (0))
					continue;
				do
				{
				}
				while ((0) != 0);
				faces = &((FT_DriverRec_*)(module))->faces_list;
				while ((faces->head) != null)
				{
					FT_Done_Face(((FT_FaceRec_)(faces->head->data)));
					if ((faces->head) != null)
						do
						{
						}
						while ((0) != 0);
				}
			}
		}
	}

	while ((library.num_modules) > (0))
	{ FT_Remove_Module(library, library.modules[library.num_modules - 1]); }
	do
	{
		(ft_mem_free(memory, (library)));
		(library) = null;
	}
	while ((0) != 0);
Exit:
	;
	return (int)(FT_Err_Ok);
}

public static void FT_Set_Debug_Hook(FT_LibraryRec_ library, uint hook_index, int (void*) * debug_hook)
{
	if ((((library) != null) && ((debug_hook) != null)) && ((hook_index) < (sizeof((library.debug_hooks)) / sizeof(void*))))
		library.debug_hooks[hook_index] = debug_hook;
}

public static int FT_Get_TrueType_Engine_Type(FT_LibraryRec_ library)
{
	int result = (int)(FT_TRUETYPE_ENGINE_TYPE_NONE);
	if ((library) != null)
	{
		FT_ModuleRec_ module = FT_Get_Module(library, "truetype");
		if ((module) != null)
		{
			FT_Service_TrueTypeEngineRec_* service;
			service = (FT_Service_TrueTypeEngineRec_*)(ft_module_get_service(module, "truetype-engine", (byte)(0)));
			if ((service) != null)
				result = (int)(service->engine_type);
		}
	}

	return (int)(result);
}

public static int FT_Get_SubGlyph_Info(FT_GlyphSlotRec_* glyph, uint sub_index, int* p_index, uint* p_flags, int* p_arg1, int* p_arg2, FT_Matrix_* p_transform)
{
	int error = (int)(FT_Err_Invalid_Argument);
	if (((((glyph) != null) && ((glyph->subglyphs) != null)) && ((glyph->format) == (FT_GLYPH_FORMAT_COMPOSITE))) && ((sub_index) < (glyph->num_subglyphs)))
	{
		FT_SubGlyphRec_* subg = glyph->subglyphs + sub_index;
		*p_index = (int)(subg->index);
		*p_flags = (uint)(subg->flags);
		*p_arg1 = (int)(subg->arg1);
		*p_arg2 = (int)(subg->arg2);
		*p_transform = (FT_Matrix_)(subg->transform);
		error = (int)(FT_Err_Ok);
	}

	return (int)(error);
}

public static byte FT_Get_Color_Glyph_Layer(FT_FaceRec_ face, uint base_glyph, uint* aglyph_index, uint* acolor_index, FT_LayerIterator_* iterator)
{
	TT_FaceRec_* ttface;
	SFNT_Interface_* sfnt;
	if (((((face == null) || (aglyph_index == null)) || (acolor_index == null)) || (iterator == null)) || ((base_glyph) >= ((uint)(face.num_glyphs))))
		return (byte)(0);
	if (!(!!((face).face_flags & (1 << 3))))
		return (byte)(0);
	ttface = (TT_FaceRec_*)(face);
	sfnt = (SFNT_Interface_*)(ttface->sfnt);
	if ((sfnt->get_colr_layer) != null)
		return (byte)(sfnt->get_colr_layer(ttface, (uint)(base_glyph), aglyph_index, acolor_index, iterator));
	else
		return (byte)(0);
}

public static int FT_Outline_Decompose(FT_Outline_* outline, FT_Outline_Funcs_ func_interface, void* user)
{
	FT_Vector_ v_last = new FT_Vector_();
	FT_Vector_ v_control = new FT_Vector_();
	FT_Vector_ v_start = new FT_Vector_();
	FT_Vector_* point;
	FT_Vector_* limit;
	sbyte* tags;
	int error = 0;
	int n = 0;
	uint first = 0;
	int tag = 0;
	int shift = 0;
	int delta = 0;
	if (outline == null)
		return (int)(FT_Err_Invalid_Outline);
	if (func_interface == null)
		return (int)(FT_Err_Invalid_Argument);
	shift = (int)(func_interface.shift);
	delta = (int)(func_interface.delta);
	first = (uint)(0);
	for (n = (int)(0); (n) < (outline->n_contours); n++)
	{
		int last = 0;
		do
		{
		}
		while ((0) != 0);
		last = (int)(outline->contours[n]);
		if ((last) < (0))
			goto Invalid_Outline;
		limit = outline->points + last;
		v_start = (FT_Vector_)(outline->points[first]);
		v_start.x = (int)((v_start.x) * (1 << shift) - delta);
		v_start.y = (int)((v_start.y) * (1 << shift) - delta);
		v_last = (FT_Vector_)(outline->points[last]);
		v_last.x = (int)((v_last.x) * (1 << shift) - delta);
		v_last.y = (int)((v_last.y) * (1 << shift) - delta);
		v_control = (FT_Vector_)(v_start);
		point = outline->points + first;
		tags = outline->tags + first;
		tag = (int)(tags[0] & 3);
		if ((tag) == (2))
			goto Invalid_Outline;
		if ((tag) == (0))
		{
			if ((outline->tags[last] & 3) == (1))
			{
				v_start = (FT_Vector_)(v_last);
				limit--;
			}
			else
			{
				v_start.x = (int)((v_start.x + v_last.x) / 2);
				v_start.y = (int)((v_start.y + v_last.y) / 2);
			}
			point--;
			tags--;
		}
		do
		{
		}
		while ((0) != 0);
		error = (int)(func_interface.move_to(&v_start, user));
		if ((error) != 0)
			goto Exit;
		while ((point) < (limit))
		{
			point++;
			tags++;
			tag = (int)(tags[0] & 3);
			switch (tag)
			{
				case 1:
				{
					FT_Vector_ vec = new FT_Vector_();
					vec.x = (int)((point->x) * (1 << shift) - delta);
					vec.y = (int)((point->y) * (1 << shift) - delta);
					do
					{
					}
					while ((0) != 0);
					error = (int)(func_interface.line_to(&vec, user));
					if ((error) != 0)
						goto Exit;
					continue;
				}
				case 0:
					v_control.x = (int)((point->x) * (1 << shift) - delta);
					v_control.y = (int)((point->y) * (1 << shift) - delta);
				Do_Conic:
					;
					if ((point) < (limit))
					{
						FT_Vector_ vec = new FT_Vector_();
						FT_Vector_ v_middle = new FT_Vector_();
						point++;
						tags++;
						tag = (int)(tags[0] & 3);
						vec.x = (int)((point->x) * (1 << shift) - delta);
						vec.y = (int)((point->y) * (1 << shift) - delta);
						if ((tag) == (1))
						{
							do
							{
							}
							while ((0) != 0);
							error = (int)(func_interface.conic_to(&v_control, &vec, user));
							if ((error) != 0)
								goto Exit;
							continue;
						}
						if (tag != 0)
							goto Invalid_Outline;
						v_middle.x = (int)((v_control.x + vec.x) / 2);
						v_middle.y = (int)((v_control.y + vec.y) / 2);
						do
						{
						}
						while ((0) != 0);
						error = (int)(func_interface.conic_to(&v_control, &v_middle, user));
						if ((error) != 0)
							goto Exit;
						v_control = (FT_Vector_)(vec);
						goto Do_Conic;
					}
					do
					{
					}
					while ((0) != 0);
					error = (int)(func_interface.conic_to(&v_control, &v_start, user));
					goto Close;
				default:
				{
					FT_Vector_ vec1 = new FT_Vector_();
					FT_Vector_ vec2 = new FT_Vector_();
					if (((point + 1) > (limit)) || ((tags[1] & 3) != 2))
						goto Invalid_Outline;
					point += 2;
					tags += 2;
					vec1.x = (int)((point[-2].x) * (1 << shift) - delta);
					vec1.y = (int)((point[-2].y) * (1 << shift) - delta);
					vec2.x = (int)((point[-1].x) * (1 << shift) - delta);
					vec2.y = (int)((point[-1].y) * (1 << shift) - delta);
					if (point <= limit)
					{
						FT_Vector_ vec = new FT_Vector_();
						vec.x = (int)((point->x) * (1 << shift) - delta);
						vec.y = (int)((point->y) * (1 << shift) - delta);
						do
						{
						}
						while ((0) != 0);
						error = (int)(func_interface.cubic_to(&vec1, &vec2, &vec, user));
						if ((error) != 0)
							goto Exit;
						continue;
					}
					do
					{
					}
					while ((0) != 0);
					error = (int)(func_interface.cubic_to(&vec1, &vec2, &v_start, user));
					goto Close;
				}
			}
		}
		do
		{
		}
		while ((0) != 0);
		error = (int)(func_interface.line_to(&v_start, user));
	Close:
		;
		if ((error) != 0)
			goto Exit;
		first = (uint)((uint)(last) + 1);
	}
	do
	{
	}
	while ((0) != 0);
	return (int)(FT_Err_Ok);
Invalid_Outline:
	;
	error = (int)(FT_Err_Invalid_Outline);
Exit:
	;
	do
	{
	}
	while ((0) != 0);
	return (int)(error);
}

public static int FT_Outline_New(FT_LibraryRec_ library, uint numPoints, int numContours, FT_Outline_* anoutline)
{
	int error = 0;
	FT_MemoryRec_ memory;
	if (library == null)
		return (int)(FT_Err_Invalid_Library_Handle);
	memory = library.memory;
	if ((anoutline == null) || (memory == null))
		return (int)(FT_Err_Invalid_Argument);
	*anoutline = (FT_Outline_)(null_outline);
	if (((numContours) < (0)) || (((uint)(numContours)) > (numPoints)))
		return (int)(FT_Err_Invalid_Argument);
	if ((numPoints) > (32767))
		return (int)(FT_Err_Array_Too_Large);
	if (((((anoutline->points) = (ft_mem_realloc(memory, (int)(sizeof((*(anoutline->points)))), (int)(0), (int)(numPoints), null, &error))) , error != 0) || (((anoutline->tags) = (ft_mem_realloc(memory, (int)(sizeof((*(anoutline->tags)))), (int)(0), (int)(numPoints), null, &error))) , error != 0)) || (((anoutline->contours) = (ft_mem_realloc(memory, (int)(sizeof((*(anoutline->contours)))), (int)(0), (int)(numContours), null, &error))) , error != 0)) goto Fail;
anoutline->n_points = ((short)(numPoints));
anoutline->n_contours = ((short)(numContours));
anoutline->flags |= (int)(1);
return (int)(FT_Err_Ok);
Fail:;
anoutline->flags |= (int)(1);
FT_Outline_Done(library, anoutline);
return (int)(error);
		}

		public static int FT_Outline_Check(FT_Outline_* outline)
{
	if ((outline) != null)
	{
		int n_points = (int)(outline->n_points);
		int n_contours = (int)(outline->n_contours);
		int end0 = 0;
		int end = 0;
		int n = 0;
		if (((n_points) == (0)) && ((n_contours) == (0)))
			return (int)(FT_Err_Ok);
		if ((n_points <= 0) || (n_contours <= 0))
			goto Bad;
		end0 = (int)(end = (int)(-1));
		for (n = (int)(0); (n) < (n_contours); n++)
		{
			end = (int)(outline->contours[n]);
			if ((end <= end0) || ((end) >= (n_points)))
				goto Bad;
			end0 = (int)(end);
		}
		if (end != n_points - 1)
			goto Bad;
		return (int)(FT_Err_Ok);
	}

Bad:
	;
	return (int)(FT_Err_Invalid_Argument);
}

public static int FT_Outline_Copy(FT_Outline_* source, FT_Outline_* target)
{
	int is_owner = 0;
	if ((source == null) || (target == null))
		return (int)(FT_Err_Invalid_Outline);
	if ((source->n_points != target->n_points) || (source->n_contours != target->n_contours))
		return (int)(FT_Err_Invalid_Argument);
	if ((source) == (target))
		return (int)(FT_Err_Ok);
	if ((source->n_points) != 0)
	{
		CRuntime.memcpy(target->points, source->points, (ulong)((ulong)(source->n_points) * sizeof((*(target->points)))));
CRuntime.memcpy(target->tags, source->tags, (ulong)((ulong)(source->n_points) * sizeof((*(target->tags)))));}

			if ((source->n_contours) != 0) CRuntime.memcpy(target->contours, source->contours, (ulong)((ulong)(source->n_contours) * sizeof((*(target->contours)))));
is_owner = (int)(target->flags & 1);
target->flags = (int)(source->flags);
target->flags &= (int)(~1);
target->flags |= (int)(is_owner);
return (int)(FT_Err_Ok);
		}

		public static int FT_Outline_Done(FT_LibraryRec_ library, FT_Outline_* outline)
{
	FT_MemoryRec_ memory;
	if (library == null)
		return (int)(FT_Err_Invalid_Library_Handle);
	if (outline == null)
		return (int)(FT_Err_Invalid_Outline);
	memory = library.memory;
	if (memory == null)
		return (int)(FT_Err_Invalid_Argument);
	if ((outline->flags & 1) != 0)
	{
		do
		{
			(ft_mem_free(memory, (outline->points)));
			(outline->points) = null;
		}
		while ((0) != 0);
		do
		{
			(ft_mem_free(memory, (outline->tags)));
			(outline->tags) = null;
		}
		while ((0) != 0);
		do
		{
			(ft_mem_free(memory, (outline->contours)));
			(outline->contours) = null;
		}
		while ((0) != 0);
	}

	*outline = (FT_Outline_)(null_outline);
	return (int)(FT_Err_Ok);
}

public static void FT_Outline_Get_CBox(FT_Outline_* outline, FT_BBox_* acbox)
{
	int xMin = 0;
	int yMin = 0;
	int xMax = 0;
	int yMax = 0;
	if (((outline) != null) && ((acbox) != null))
	{
		if ((outline->n_points) == (0))
		{
			xMin = (int)(0);
			yMin = (int)(0);
			xMax = (int)(0);
			yMax = (int)(0);
		}
		else
		{
			FT_Vector_* vec = outline->points;
			FT_Vector_* limit = vec + outline->n_points;
			xMin = (int)(xMax = (int)(vec->x));
			yMin = (int)(yMax = (int)(vec->y));
			vec++;
			for (; (vec) < (limit); vec++)
			{
				int x = 0;
				int y = 0;
				x = (int)(vec->x);
				if ((x) < (xMin))
					xMin = (int)(x);
				if ((x) > (xMax))
					xMax = (int)(x);
				y = (int)(vec->y);
				if ((y) < (yMin))
					yMin = (int)(y);
				if ((y) > (yMax))
					yMax = (int)(y);
			}
		}
		acbox->xMin = (int)(xMin);
		acbox->xMax = (int)(xMax);
		acbox->yMin = (int)(yMin);
		acbox->yMax = (int)(yMax);
	}

}

public static void FT_Outline_Translate(FT_Outline_* outline, int xOffset, int yOffset)
{
	ushort n = 0;
	FT_Vector_* vec;
	if (outline == null)
		return;
	vec = outline->points;
	for (n = (ushort)(0); (n) < (outline->n_points); n++)
	{
		vec->x = (int)((vec->x) + (xOffset));
		vec->y = (int)((vec->y) + (yOffset));
		vec++;
	}
}

public static void FT_Outline_Reverse(FT_Outline_* outline)
{
	ushort n = 0;
	int first = 0;
	int last = 0;
	if (outline == null)
		return;
	first = (int)(0);
	for (n = (ushort)(0); (n) < (outline->n_contours); n++)
	{
		last = (int)(outline->contours[n]);
		{
			FT_Vector_* p = outline->points + first;
			FT_Vector_* q = outline->points + last;
			FT_Vector_ swap = new FT_Vector_();
			while ((p) < (q))
			{
				swap = (FT_Vector_)(*p);
				*p = (FT_Vector_)(*q);
				*q = (FT_Vector_)(swap);
				p++;
				q--;
			}
		}
		{
			sbyte* p = outline->tags + first;
			sbyte* q = outline->tags + last;
			while ((p) < (q))
			{
				sbyte swap = 0;
				swap = (sbyte)(*p);
				*p = (sbyte)(*q);
				*q = (sbyte)(swap);
				p++;
				q--;
			}
		}
		first = (int)(last + 1);
	}
	outline->flags ^= (int)(4);
}

public static int FT_Outline_Render(FT_LibraryRec_ library, FT_Outline_* outline, FT_Raster_Params_* params)
{
	int error = 0;
	FT_RendererRec_ renderer;
	FT_ListNodeRec_* node;
	FT_BBox_ cbox = new FT_BBox_();
	if (library == null)
		return (int)(FT_Err_Invalid_Library_Handle);
	if (outline == null)
		return (int)(FT_Err_Invalid_Outline);
	if (params== null) return (int)(FT_Err_Invalid_Argument);
FT_Outline_Get_CBox(outline, &cbox);
if (((((cbox.xMin) < (-0x1000000)) || ((cbox.yMin) < (-0x1000000))) || ((cbox.xMax) > (0x1000000))) || ((cbox.yMax) > (0x1000000))) return (int)(FT_Err_Invalid_Outline);
renderer = library.cur_renderer;
node = library.renderers.head;
			params->source = (void*)(outline);
if (((params->flags &2) != 0) && ((params->flags &4) == 0)) {
params->clip_box.xMin = (int)(cbox.xMin >> 6);params->clip_box.yMin = (int)(cbox.yMin >> 6);params->clip_box.xMax = (int)((cbox.xMax + 63) >> 6);params->clip_box.yMax = (int)((cbox.yMax + 63) >> 6);
}

error = (int)(FT_Err_Cannot_Render_Glyph);
while ((renderer) != null)
{
	error = (int)(renderer.raster_render(renderer.raster, params));
	if ((error == 0) || (((error) & 255) != ((FT_Err_Cannot_Render_Glyph) & 255)))
		break;
	renderer = FT_Lookup_Renderer(library, (int)(FT_GLYPH_FORMAT_OUTLINE), &node);
}
return (int)(error);
		}

		public static int FT_Outline_Get_Bitmap(FT_LibraryRec_ library, FT_Outline_* outline, FT_Bitmap_* abitmap)
{
	FT_Raster_Params_ params = new FT_Raster_Params_();
	if (abitmap == null)
		return (int)(FT_Err_Invalid_Argument);
			params.target = abitmap;
			params.flags = (int)(0);
	if ((((abitmap->pixel_mode) == (FT_PIXEL_MODE_GRAY)) || ((abitmap->pixel_mode) == (FT_PIXEL_MODE_LCD))) || ((abitmap->pixel_mode) == (FT_PIXEL_MODE_LCD_V))) params.flags |= (int)(1);
	return (int)(FT_Outline_Render(library, outline, &params));
}

public static void FT_Vector_Transform(FT_Vector_* vector, FT_Matrix_* matrix)
{
	int xz = 0;
	int yz = 0;
	if ((vector == null) || (matrix == null))
		return;
	xz = (int)(FT_MulFix((int)(vector->x), (int)(matrix->xx)) + FT_MulFix((int)(vector->y), (int)(matrix->xy)));
	yz = (int)(FT_MulFix((int)(vector->x), (int)(matrix->yx)) + FT_MulFix((int)(vector->y), (int)(matrix->yy)));
	vector->x = (int)(xz);
	vector->y = (int)(yz);
}

public static void FT_Outline_Transform(FT_Outline_* outline, FT_Matrix_* matrix)
{
	FT_Vector_* vec;
	FT_Vector_* limit;
	if (((outline == null) || (matrix == null)) || (outline->points == null))
		return;
	vec = outline->points;
	limit = vec + outline->n_points;
	for (; (vec) < (limit); vec++)
	{ FT_Vector_Transform(vec, matrix); }
}

public static int FT_Outline_Embolden(FT_Outline_* outline, int strength)
{
	return (int)(FT_Outline_EmboldenXY(outline, (int)(strength), (int)(strength)));
}

public static int FT_Outline_EmboldenXY(FT_Outline_* outline, int xstrength, int ystrength)
{
	FT_Vector_* points;
	int c = 0;
	int first = 0;
	int last = 0;
	int orientation = 0;
	if (outline == null)
		return (int)(FT_Err_Invalid_Outline);
	xstrength /= (int)(2);
	ystrength /= (int)(2);
	if (((xstrength) == (0)) && ((ystrength) == (0)))
		return (int)(FT_Err_Ok);
	orientation = (int)(FT_Outline_Get_Orientation(outline));
	if ((orientation) == (FT_ORIENTATION_NONE))
	{
		if ((outline->n_contours) != 0)
			return (int)(FT_Err_Invalid_Argument);
		else
			return (int)(FT_Err_Ok);
	}

	points = outline->points;
	first = (int)(0);
	for (c = (int)(0); (c) < (outline->n_contours); c++)
	{
		FT_Vector_ _in_ = new FT_Vector_();
		FT_Vector_ _out_ = new FT_Vector_();
		FT_Vector_ anchor = new FT_Vector_();
		FT_Vector_ shift = new FT_Vector_();
		int l_in = 0;
		int l_out = 0;
		int l_anchor = (int)(0);
		int l = 0;
		int q = 0;
		int d = 0;
		int i = 0;
		int j = 0;
		int k = 0;
		l_in = (int)(0);
		last = (int)(outline->contours[c]);
		_in_.x = (int)(_in_.y = (int)(anchor.x = (int)(anchor.y = (int)(0))));
		for (i = (int)(last), j = (int)(first), k = (int)(-1); (j != i) && (i != k); j = (int)((j) < (last) ? j + 1 : first))
		{
			if (j != k)
			{
				_out_.x = (int)(points[j].x - points[i].x);
				_out_.y = (int)(points[j].y - points[i].y);
				l_out = ((int)(FT_Vector_NormLen(&_out_)));
				if ((l_out) == (0))
					continue;
			}
			else
			{
				_out_ = (FT_Vector_)(anchor);
				l_out = (int)(l_anchor);
			}
			if (l_in != 0)
			{
				if ((k) < (0))
				{
					k = (int)(i);
					anchor = (FT_Vector_)(_in_);
					l_anchor = (int)(l_in);
				}
				d = (int)(FT_MulFix((int)(_in_.x), (int)(_out_.x)) + FT_MulFix((int)(_in_.y), (int)(_out_.y)));
				if ((d) > (-0xF000))
				{
					d = (int)(d + 0x10000);
					shift.x = (int)(_in_.y + _out_.y);
					shift.y = (int)(_in_.x + _out_.x);
					if ((orientation) == (FT_ORIENTATION_TRUETYPE))
						shift.x = (int)(-shift.x);
					else
						shift.y = (int)(-shift.y);
					q = (int)(FT_MulFix((int)(_out_.x), (int)(_in_.y)) - FT_MulFix((int)(_out_.y), (int)(_in_.x)));
					if ((orientation) == (FT_ORIENTATION_TRUETYPE))
						q = (int)(-q);
					l = (int)((l_in) < (l_out) ? (l_in) : (l_out));
					if (FT_MulFix((int)(xstrength), (int)(q)) <= FT_MulFix((int)(l), (int)(d)))
						shift.x = (int)(FT_MulDiv((int)(shift.x), (int)(xstrength), (int)(d)));
					else
						shift.x = (int)(FT_MulDiv((int)(shift.x), (int)(l), (int)(q)));
					if (FT_MulFix((int)(ystrength), (int)(q)) <= FT_MulFix((int)(l), (int)(d)))
						shift.y = (int)(FT_MulDiv((int)(shift.y), (int)(ystrength), (int)(d)));
					else
						shift.y = (int)(FT_MulDiv((int)(shift.y), (int)(l), (int)(q)));
				}
				else
					shift.x = (int)(shift.y = (int)(0));
				for (; i != j; i = (int)((i) < (last) ? i + 1 : first))
				{
					points[i].x += (int)(xstrength + shift.x);
					points[i].y += (int)(ystrength + shift.y);
				}
			}
			else
				i = (int)(j);
			_in_ = (FT_Vector_)(_out_);
			l_in = (int)(l_out);
		}
		first = (int)(last + 1);
	}
	return (int)(FT_Err_Ok);
}

public static int FT_Outline_Get_Orientation(FT_Outline_* outline)
{
	FT_BBox_ cbox = (FT_BBox_)(new FT_BBox_ { xMin = 0, yMin = 0, xMax = 0, yMax = 0 });
	int xshift = 0;
	int yshift = 0;
	FT_Vector_* points;
	FT_Vector_ v_prev = new FT_Vector_();
	FT_Vector_ v_cur = new FT_Vector_();
	int c = 0;
	int n = 0;
	int first = 0;
	int area = (int)(0);
	if ((outline == null) || (outline->n_points <= 0))
		return (int)(FT_ORIENTATION_TRUETYPE);
	FT_Outline_Get_CBox(outline, &cbox);
	if (((cbox.xMin) == (cbox.xMax)) || ((cbox.yMin) == (cbox.yMax)))
		return (int)(FT_ORIENTATION_NONE);
	if (((((cbox.xMin) < (-0x1000000)) || ((cbox.yMin) < (-0x1000000))) || ((cbox.xMax) > (0x1000000))) || ((cbox.yMax) > (0x1000000)))
		return (int)(FT_ORIENTATION_NONE);
	xshift = (int)((FT_MSB_i386((uint)(((cbox.xMax) < (0) ? -(cbox.xMax) : (cbox.xMax)) | ((cbox.xMin) < (0) ? -(cbox.xMin) : (cbox.xMin))))) - 14);
	xshift = (int)((xshift) > (0) ? (xshift) : (0));
	yshift = (int)((FT_MSB_i386((uint)(cbox.yMax - cbox.yMin))) - 14);
	yshift = (int)((yshift) > (0) ? (yshift) : (0));
	points = outline->points;
	first = (int)(0);
	for (c = (int)(0); (c) < (outline->n_contours); c++)
	{
		int last = (int)(outline->contours[c]);
		v_prev.x = (int)(points[last].x >> xshift);
		v_prev.y = (int)(points[last].y >> yshift);
		for (n = (int)(first); n <= last; n++)
		{
			v_cur.x = (int)(points[n].x >> xshift);
			v_cur.y = (int)(points[n].y >> yshift);
			area = (int)((area) + ((v_cur.y - v_prev.y) * (v_cur.x + v_prev.x)));
			v_prev = (FT_Vector_)(v_cur);
		}
		first = (int)(last + 1);
	}
	if ((area) > (0))
		return (int)(FT_ORIENTATION_POSTSCRIPT);
	else if ((area) < (0))
		return (int)(FT_ORIENTATION_TRUETYPE);
	else
		return (int)(FT_ORIENTATION_NONE);
}

public static int ps_property_set(FT_ModuleRec_ module, sbyte* property_name, void* value, byte value_is_string)
{
	int error = (int)(FT_Err_Ok);
	PS_DriverRec_* driver = (PS_DriverRec_*)(module);
	if (strcmp(property_name, "darkening-parameters") == 0)
	{
		int* darken_params;
		int x1 = 0;
		int y1 = 0;
		int x2 = 0;
		int y2 = 0;
		int x3 = 0;
		int y3 = 0;
		int x4 = 0;
		int y4 = 0;
		int* dp = stackalloc int[8];
		if ((value_is_string) != 0)
		{
			sbyte* s = (sbyte*)(value);
			sbyte* ep;
			int i = 0;
			for (i = (int)(0); (i) < (7); i++)
			{
				dp[i] = (int)(strtol(s, &ep, (int)(10)));
				if ((*ep != ',') || ((s) == (ep)))
					return (int)(FT_Err_Invalid_Argument);
				s = ep + 1;
			}
			dp[7] = (int)(strtol(s, &ep, (int)(10)));
			if ((!(((*ep) == ('\0')) || ((*ep) == (' ')))) || ((s) == (ep)))
				return (int)(FT_Err_Invalid_Argument);
			darken_params = dp;
		}
		else
			darken_params = (int*)(value);
		x1 = (int)(darken_params[0]);
		y1 = (int)(darken_params[1]);
		x2 = (int)(darken_params[2]);
		y2 = (int)(darken_params[3]);
		x3 = (int)(darken_params[4]);
		y3 = (int)(darken_params[5]);
		x4 = (int)(darken_params[6]);
		y4 = (int)(darken_params[7]);
		if ((((((((((((((((x1) < (0)) || ((x2) < (0))) || ((x3) < (0))) || ((x4) < (0))) || ((y1) < (0))) || ((y2) < (0))) || ((y3) < (0))) || ((y4) < (0))) || ((x1) > (x2))) || ((x2) > (x3))) || ((x3) > (x4))) || ((y1) > (500))) || ((y2) > (500))) || ((y3) > (500))) || ((y4) > (500)))
			return (int)(FT_Err_Invalid_Argument);
		driver->darken_params[0] = (int)(x1);
		driver->darken_params[1] = (int)(y1);
		driver->darken_params[2] = (int)(x2);
		driver->darken_params[3] = (int)(y2);
		driver->darken_params[4] = (int)(x3);
		driver->darken_params[5] = (int)(y3);
		driver->darken_params[6] = (int)(x4);
		driver->darken_params[7] = (int)(y4);
		return (int)(error);
	}
	else if (strcmp(property_name, "hinting-engine") == 0)
	{
		if ((value_is_string) != 0)
		{
			sbyte* s = (sbyte*)(value);
			if (strcmp(s, "adobe") == 0)
				driver->hinting_engine = (uint)(1);
			else
				return (int)(FT_Err_Invalid_Argument);
		}
		else
		{
			uint* hinting_engine = (uint*)(value);
			if ((*hinting_engine) == (1))
				driver->hinting_engine = (uint)(*hinting_engine);
			else
				error = (int)(FT_Err_Unimplemented_Feature);
		}
		return (int)(error);
	}
	else if (strcmp(property_name, "no-stem-darkening") == 0)
	{
		if ((value_is_string) != 0)
		{
			sbyte* s = (sbyte*)(value);
			int nsd = (int)(strtol(s, null, (int)(10)));
			if (nsd == 0)
				driver->no_stem_darkening = (byte)(0);
			else
				driver->no_stem_darkening = (byte)(1);
		}
		else
		{
			byte* no_stem_darkening = (byte*)(value);
			driver->no_stem_darkening = (byte)(*no_stem_darkening);
		}
		return (int)(error);
	}
	else if (strcmp(property_name, "random-seed") == 0)
	{
		int random_seed = 0;
		if ((value_is_string) != 0)
		{
			sbyte* s = (sbyte*)(value);
			random_seed = (int)(strtol(s, null, (int)(10)));
		}
		else
			random_seed = (int)(*(int*)(value));
		if ((random_seed) < (0))
			random_seed = (int)(0);
		driver->random_seed = (int)(random_seed);
		return (int)(error);
	}

	do
	{
	}
	while ((0) != 0);
	return (int)(FT_Err_Missing_Property);
}

public static int ps_property_get(FT_ModuleRec_ module, sbyte* property_name, void* value)
{
	int error = (int)(FT_Err_Ok);
	PS_DriverRec_* driver = (PS_DriverRec_*)(module);
	if (strcmp(property_name, "darkening-parameters") == 0)
	{
		int* darken_params = driver->darken_params;
		int* val = (int*)(value);
		val[0] = (int)(darken_params[0]);
		val[1] = (int)(darken_params[1]);
		val[2] = (int)(darken_params[2]);
		val[3] = (int)(darken_params[3]);
		val[4] = (int)(darken_params[4]);
		val[5] = (int)(darken_params[5]);
		val[6] = (int)(darken_params[6]);
		val[7] = (int)(darken_params[7]);
		return (int)(error);
	}
	else if (strcmp(property_name, "hinting-engine") == 0)
	{
		uint hinting_engine = (uint)(driver->hinting_engine);
		uint* val = (uint*)(value);
		*val = (uint)(hinting_engine);
		return (int)(error);
	}
	else if (strcmp(property_name, "no-stem-darkening") == 0)
	{
		byte no_stem_darkening = (byte)(driver->no_stem_darkening);
		byte* val = (byte*)(value);
		*val = (byte)(no_stem_darkening);
		return (int)(error);
	}

	do
	{
	}
	while ((0) != 0);
	return (int)(FT_Err_Missing_Property);
}

public static int FT_Raccess_Get_HeaderInfo(FT_LibraryRec_ library, FT_StreamRec_ stream, int rfork_offset, int* map_offset, int* rdata_pos)
{
	int error = 0;
	byte* head = stackalloc byte[16];
	byte* head2 = stackalloc byte[16];
	int map_pos = 0;
	int map_len = 0;
	int rdata_len = 0;
	int allzeros = 0;
	int allmatch = 0;
	int i = 0;
	int type_list = 0;
	((library) = (library));
	error = (int)(FT_Stream_Seek(stream, (int)(rfork_offset)));
	if ((error) != 0)
		return (int)(error);
	error = (int)(FT_Stream_Read(stream, head, (int)(16)));
	if ((error) != 0)
		return (int)(error);
	if (((((head[0]) >= (0x80)) || ((head[4]) >= (0x80))) || ((head[8]) >= (0x80))) || ((head[12]) >= (0x80)))
		return (int)(FT_Err_Unknown_File_Format);
	*rdata_pos = (int)((head[0] << 24) | (head[1] << 16) | (head[2] << 8) | head[3]);
	map_pos = (int)((head[4] << 24) | (head[5] << 16) | (head[6] << 8) | head[7]);
	rdata_len = (int)((head[8] << 24) | (head[9] << 16) | (head[10] << 8) | head[11]);
	map_len = (int)((head[12] << 24) | (head[13] << 16) | (head[14] << 8) | head[15]);
	if (map_pos == 0)
		return (int)(FT_Err_Unknown_File_Format);
	if ((*rdata_pos) < (map_pos))
	{
		if ((*rdata_pos) > (map_pos - rdata_len))
			return (int)(FT_Err_Unknown_File_Format);
	}
	else
	{
		if ((map_pos) > (*rdata_pos - map_len))
			return (int)(FT_Err_Unknown_File_Format);
	}

	if (((((((2147483647 - rdata_len) < (*rdata_pos)) || ((2147483647 - map_len) < (map_pos))) || ((2147483647 - (*rdata_pos + rdata_len)) < (rfork_offset))) || ((2147483647 - (map_pos + map_len)) < (rfork_offset))) || ((rfork_offset + *rdata_pos + rdata_len) > (stream.size))) || ((rfork_offset + map_pos + map_len) > (stream.size)))
		return (int)(FT_Err_Unknown_File_Format);
	*rdata_pos += (int)(rfork_offset);
	map_pos += (int)(rfork_offset);
	error = (int)(FT_Stream_Seek(stream, (int)(map_pos)));
	if ((error) != 0)
		return (int)(error);
	head2[15] = ((byte)(head[15] + 1));
	error = (int)(FT_Stream_Read(stream, head2, (int)(16)));
	if ((error) != 0)
		return (int)(error);
	allzeros = (int)(1);
	allmatch = (int)(1);
	for (i = (int)(0); (i) < (16); i++)
	{
		if (head2[i] != 0)
			allzeros = (int)(0);
		if (head2[i] != head[i])
			allmatch = (int)(0);
	}
	if ((allzeros == 0) && (allmatch == 0))
		return (int)(FT_Err_Unknown_File_Format);
	(void)((error = (int)(FT_Stream_Skip(stream, (int)(4 + 2 + 2)))) != 0);
	if ((type_list = (int)((short)(FT_Stream_ReadUShort(stream, &error))), error != FT_Err_Ok))
		return (int)(error);
	if ((type_list) < (0))
		return (int)(FT_Err_Unknown_File_Format);
	error = (int)(FT_Stream_Seek(stream, (int)(map_pos + type_list)));
	if ((error) != 0)
		return (int)(error);
	*map_offset = (int)(map_pos + type_list);
	return (int)(FT_Err_Ok);
}

public static int ft_raccess_sort_ref_by_id(FT_RFork_Ref_* a, FT_RFork_Ref_* b)
{
	if ((a->res_id) < (b->res_id))
		return (int)(-1);
	else if ((a->res_id) > (b->res_id))
		return (int)(1);
	else
		return (int)(0);
}

public static int FT_Raccess_Get_DataOffsets(FT_LibraryRec_ library, FT_StreamRec_ stream, int map_offset, int rdata_pos, int tag, byte sort_by_res_id, int** offsets, int* count)
{
	int error = 0;
	int i = 0;
	int j = 0;
	int cnt = 0;
	int subcnt = 0;
	int tag_internal = 0;
	int rpos = 0;
	FT_MemoryRec_ memory = library.memory;
	int temp = 0;
	int* offsets_internal = null;
	FT_RFork_Ref_ * ref = null;
	do
	{
	}
	while ((0) != 0);
	error = (int)(FT_Stream_Seek(stream, (int)(map_offset)));
	if ((error) != 0)
		return (int)(error);
	if ((cnt = (int)((short)(FT_Stream_ReadUShort(stream, &error))), error != FT_Err_Ok))
		return (int)(error);
	cnt++;
	if ((cnt) > (4079))
		return (int)(FT_Err_Invalid_Table);
	for (i = (int)(0); (i) < (cnt); i++)
	{
		if (((tag_internal = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok) || (subcnt = (int)((short)(FT_Stream_ReadUShort(stream, &error))), error != FT_Err_Ok)) || (rpos = (int)((short)(FT_Stream_ReadUShort(stream, &error))), error != FT_Err_Ok))
			return (int)(error);
		do
		{
		}
		while ((0) != 0);
		do
		{
		}
		while ((0) != 0);
		if ((tag_internal) == (tag))
		{
			*count = (int)(subcnt + 1);
			rpos += (int)(map_offset);
			if (((*count) < (1)) || ((*count) > (2727)))
				return (int)(FT_Err_Invalid_Table);
			error = (int)(FT_Stream_Seek(stream, (int)(rpos)));
			if ((error) != 0)
				return (int)(error);
			if ((((ref) = (ft_mem_realloc(memory, (int)(sizeof((*(ref)))), (int)(0), (int)(*count), null, &error))) , error != 0)) return (int)(error);
for (j = (int)(0); (j) < (*count); j++)
{
	if ((ref[j].res_id = ((short)(FT_Stream_ReadUShort(stream, &error))), error != FT_Err_Ok))
		goto Exit;
	if (((error = (int)(FT_Stream_Skip(stream, (int)(2)))) != 0))
		goto Exit;
	if ((temp = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok))
		goto Exit;
	if (((error = (int)(FT_Stream_Skip(stream, (int)(4)))) != 0))
		goto Exit;
	if ((temp) < (0))
	{
		error = (int)(FT_Err_Invalid_Table);
		goto Exit;
	}
	ref[j].offset = (int)(temp & 0xFFFFFF);
	do
	{
	}
	while ((0) != 0);
}
if ((sort_by_res_id) != 0)
{
	CRuntime.qsort(ref, (ulong)(*count), (ulong)(sizeof(FT_RFork_Ref_)), (int(const void*, const void*)*)(ft_raccess_sort_ref_by_id));
	do
	{
	}
	while ((0) != 0);
	for (j = (int)(0); (j) < (*count); j++)
	{
		do
		{
		}
		while ((0) != 0);
	}
}
if ((((offsets_internal) = (ft_mem_realloc(memory, (int)(sizeof((*(offsets_internal)))), (int)(0), (int)(*count), null, &error))) , error != 0)) goto Exit;
for (j = (int)(0); (j) < (*count); j++) { offsets_internal[j] = (int)(rdata_pos + ref[j].offset); }
*offsets = offsets_internal;
error = (int)(FT_Err_Ok);
Exit:;
do
{
	(ft_mem_free(memory, (ref)));
	(ref) = null;
}
while ((0) != 0);
return (int)(error);}
}
			return (int)(FT_Err_Cannot_Open_Resource);
		}

		public static void FT_Raccess_Guess(FT_LibraryRec_ library, FT_StreamRec_ stream, sbyte* base_name, sbyte** new_names, int* offsets, int* errors)
{
	int i = 0;
	for (i = (int)(0); (i) < (9); i++)
	{
		new_names[i] = null;
		if (null != stream)
			errors[i] = (int)(FT_Stream_Seek(stream, (int)(0)));
		else
			errors[i] = (int)(FT_Err_Ok);
		if ((errors[i]) != 0)
			continue;
		errors[i] = (int)(ft_raccess_guess_table[i].func(library, stream, base_name, &(new_names[i]), &(offsets[i])));
	}
	return;
}

public static int raccess_get_rule_type_from_rule_index(FT_LibraryRec_ library, uint rule_index)
{
	((library) = (library));
	if ((rule_index) >= (9))
		return (int)(FT_RFork_Rule_invalid);
	return (int)(ft_raccess_guess_table[rule_index].type);
}

public static byte ft_raccess_rule_by_darwin_vfs(FT_LibraryRec_ library, uint rule_index)
{
	switch (raccess_get_rule_type_from_rule_index(library, (uint)(rule_index)))
	{
		case FT_RFork_Rule_darwin_newvfs:
		case FT_RFork_Rule_darwin_hfsplus:
			return (byte)(1);
		default:
			return (byte)(0);
	}

}

public static int raccess_guess_apple_double(FT_LibraryRec_ library, FT_StreamRec_ stream, sbyte* base_file_name, sbyte** result_file_name, int* result_offset)
{
	int magic = (int)((0x00 << 24) | (0x05 << 16) | (0x16 << 8) | 0x07);
	*result_file_name = null;
	if (null == (stream))
		return (int)(FT_Err_Cannot_Open_Stream);
	return (int)(raccess_guess_apple_generic(library, stream, base_file_name, (int)(magic), result_offset));
}

public static int raccess_guess_apple_single(FT_LibraryRec_ library, FT_StreamRec_ stream, sbyte* base_file_name, sbyte** result_file_name, int* result_offset)
{
	int magic = (int)((0x00 << 24) | (0x05 << 16) | (0x16 << 8) | 0x00);
	*result_file_name = null;
	if (null == (stream))
		return (int)(FT_Err_Cannot_Open_Stream);
	return (int)(raccess_guess_apple_generic(library, stream, base_file_name, (int)(magic), result_offset));
}

public static int raccess_guess_darwin_ufs_export(FT_LibraryRec_ library, FT_StreamRec_ stream, sbyte* base_file_name, sbyte** result_file_name, int* result_offset)
{
	sbyte* newpath;
	int error = 0;
	FT_MemoryRec_ memory;
	((stream) = (stream));
	memory = library.memory;
	newpath = raccess_make_file_name(memory, base_file_name, "._");
	if (newpath == null)
		return (int)(FT_Err_Out_Of_Memory);
	error = (int)(raccess_guess_linux_double_from_file_name(library, newpath, result_offset));
	if (error == 0)
		*result_file_name = newpath;
	else
		do
		{
			(ft_mem_free(memory, (newpath)));
			(newpath) = null;
		}
		while ((0) != 0);
	return (int)(error);
}

public static int raccess_guess_darwin_hfsplus(FT_LibraryRec_ library, FT_StreamRec_ stream, sbyte* base_file_name, sbyte** result_file_name, int* result_offset)
{
	int error = 0;
	sbyte* newpath = null;
	FT_MemoryRec_ memory;
	int base_file_len = (int)(CRuntime.strlen(base_file_name));
	((stream) = (stream));
	memory = library.memory;
	if ((base_file_len + 6) > (2147483647))
		return (int)(FT_Err_Array_Too_Large);
	if ((((newpath) = (ft_mem_alloc(memory, (int)(base_file_len + 6), &error))), error != 0))
		return (int)(error);
	CRuntime.memcpy(newpath, base_file_name, (ulong)(base_file_len));
	CRuntime.memcpy(newpath + base_file_len, "/rsrc", (ulong)(6));
	*result_file_name = newpath;
	*result_offset = (int)(0);
	return (int)(FT_Err_Ok);
}

public static int raccess_guess_darwin_newvfs(FT_LibraryRec_ library, FT_StreamRec_ stream, sbyte* base_file_name, sbyte** result_file_name, int* result_offset)
{
	int error = 0;
	sbyte* newpath = null;
	FT_MemoryRec_ memory;
	int base_file_len = (int)(CRuntime.strlen(base_file_name));
	((stream) = (stream));
	memory = library.memory;
	if ((base_file_len + 18) > (2147483647))
		return (int)(FT_Err_Array_Too_Large);
	if ((((newpath) = (ft_mem_alloc(memory, (int)(base_file_len + 18), &error))), error != 0))
		return (int)(error);
	CRuntime.memcpy(newpath, base_file_name, (ulong)(base_file_len));
	CRuntime.memcpy(newpath + base_file_len, "/..namedfork/rsrc", (ulong)(18));
	*result_file_name = newpath;
	*result_offset = (int)(0);
	return (int)(FT_Err_Ok);
}

public static int raccess_guess_vfat(FT_LibraryRec_ library, FT_StreamRec_ stream, sbyte* base_file_name, sbyte** result_file_name, int* result_offset)
{
	sbyte* newpath;
	FT_MemoryRec_ memory;
	((stream) = (stream));
	memory = library.memory;
	newpath = raccess_make_file_name(memory, base_file_name, "resource.frk/");
	if (newpath == null)
		return (int)(FT_Err_Out_Of_Memory);
	*result_file_name = newpath;
	*result_offset = (int)(0);
	return (int)(FT_Err_Ok);
}

public static int raccess_guess_linux_cap(FT_LibraryRec_ library, FT_StreamRec_ stream, sbyte* base_file_name, sbyte** result_file_name, int* result_offset)
{
	sbyte* newpath;
	FT_MemoryRec_ memory;
	((stream) = (stream));
	memory = library.memory;
	newpath = raccess_make_file_name(memory, base_file_name, ".resource/");
	if (newpath == null)
		return (int)(FT_Err_Out_Of_Memory);
	*result_file_name = newpath;
	*result_offset = (int)(0);
	return (int)(FT_Err_Ok);
}

public static int raccess_guess_linux_double(FT_LibraryRec_ library, FT_StreamRec_ stream, sbyte* base_file_name, sbyte** result_file_name, int* result_offset)
{
	sbyte* newpath;
	int error = 0;
	FT_MemoryRec_ memory;
	((stream) = (stream));
	memory = library.memory;
	newpath = raccess_make_file_name(memory, base_file_name, "%");
	if (newpath == null)
		return (int)(FT_Err_Out_Of_Memory);
	error = (int)(raccess_guess_linux_double_from_file_name(library, newpath, result_offset));
	if (error == 0)
		*result_file_name = newpath;
	else
		do
		{
			(ft_mem_free(memory, (newpath)));
			(newpath) = null;
		}
		while ((0) != 0);
	return (int)(error);
}

public static int raccess_guess_linux_netatalk(FT_LibraryRec_ library, FT_StreamRec_ stream, sbyte* base_file_name, sbyte** result_file_name, int* result_offset)
{
	sbyte* newpath;
	int error = 0;
	FT_MemoryRec_ memory;
	((stream) = (stream));
	memory = library.memory;
	newpath = raccess_make_file_name(memory, base_file_name, ".AppleDouble/");
	if (newpath == null)
		return (int)(FT_Err_Out_Of_Memory);
	error = (int)(raccess_guess_linux_double_from_file_name(library, newpath, result_offset));
	if (error == 0)
		*result_file_name = newpath;
	else
		do
		{
			(ft_mem_free(memory, (newpath)));
			(newpath) = null;
		}
		while ((0) != 0);
	return (int)(error);
}

public static int raccess_guess_apple_generic(FT_LibraryRec_ library, FT_StreamRec_ stream, sbyte* base_file_name, int magic, int* result_offset)
{
	int magic_from_stream = 0;
	int error = 0;
	int version_number = (int)(0);
	ushort n_of_entries = 0;
	int i = 0;
	int entry_id = 0;
	int entry_offset = 0;
	int entry_length = (int)(0);
	int resource_fork_entry_id = (int)(0x2);
	((library) = (library));
	((base_file_name) = (base_file_name));
	((version_number) = (int)(version_number));
	((entry_length) = (int)(entry_length));
	if ((magic_from_stream = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok))
		return (int)(error);
	if (magic_from_stream != magic)
		return (int)(FT_Err_Unknown_File_Format);
	if ((version_number = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok))
		return (int)(error);
	error = (int)(FT_Stream_Skip(stream, (int)(16)));
	if ((error) != 0)
		return (int)(error);
	if ((n_of_entries = (ushort)(FT_Stream_ReadUShort(stream, &error)), error != FT_Err_Ok))
		return (int)(error);
	if ((n_of_entries) == (0))
		return (int)(FT_Err_Unknown_File_Format);
	for (i = (int)(0); (i) < (n_of_entries); i++)
	{
		if ((entry_id = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok))
			return (int)(error);
		if ((entry_id) == (resource_fork_entry_id))
		{
			if ((entry_offset = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok) || (entry_length = (int)(FT_Stream_ReadULong(stream, &error)), error != FT_Err_Ok))
				continue;
			*result_offset = (int)(entry_offset);
			return (int)(FT_Err_Ok);
		}
		else
		{
			error = (int)(FT_Stream_Skip(stream, (int)(4 + 4)));
			if ((error) != 0)
				return (int)(error);
		}
	}
	return (int)(FT_Err_Unknown_File_Format);
}

public static int raccess_guess_linux_double_from_file_name(FT_LibraryRec_ library, sbyte* file_name, int* result_offset)
{
	FT_Open_Args_ args2 = new FT_Open_Args_();
	FT_StreamRec_ stream2;
	sbyte* nouse = null;
	int error = 0;
	args2.flags = (uint)(4);
	args2.pathname = file_name;
	error = (int)(FT_Stream_New(library, &args2, stream2));
	if ((error) != 0)
		return (int)(error);
	error = (int)(raccess_guess_apple_double(library, stream2, file_name, &nouse, result_offset));
	FT_Stream_Free(stream2, (int)(0));
	return (int)(error);
}

public static sbyte* raccess_make_file_name(FT_MemoryRec_ memory, sbyte* original_name, sbyte* insertion)
{
	sbyte* new_name = null;
	sbyte* tmp;
	sbyte* slash;
	ulong new_length = 0;
	int error = (int)(FT_Err_Ok);
	((error) = (int)(error));
	new_length = (ulong)(CRuntime.strlen(original_name) + CRuntime.strlen(insertion));
	if ((((new_name) = (ft_mem_alloc(memory, (int)(new_length + 1), &error))), error != 0))
		return null;
	tmp = strrchr(original_name, (int)('/'));
	if ((tmp) != null)
	{
		strncpy(new_name, original_name, (ulong)(tmp - original_name + 1));
		new_name[tmp - original_name + 1] = (sbyte)('\0');
		slash = tmp + 1;
	}
	else
	{
		slash = original_name;
		new_name[0] = (sbyte)('\0');
	}

	strcat(new_name, insertion);
	strcat(new_name, slash);
	return new_name;
}

public static uint FT_Get_Sfnt_Name_Count(FT_FaceRec_ face)
{
	return (uint)((((face) != null) && (!!((face).face_flags & (1 << 3)))) ? ((TT_FaceRec_*)(face))->num_names : 0);
}

public static int FT_Get_Sfnt_Name(FT_FaceRec_ face, uint idx, FT_SfntName_* aname)
{
	int error = (int)(FT_Err_Invalid_Argument);
	if ((((aname) != null) && ((face) != null)) && (!!((face).face_flags & (1 << 3))))
	{
		TT_FaceRec_* ttface = (TT_FaceRec_*)(face);
		if ((idx) < ((uint)(ttface->num_names)))
		{
			TT_NameRec_* entry = ttface->name_table.names + idx;
			if (((entry->stringLength) > (0)) && (entry->_string_ == null))
			{
				FT_MemoryRec_ memory = face.memory;
				FT_StreamRec_ stream = face.stream;
				if (((((entry->_string_) = (ft_mem_realloc(memory, (int)(sizeof((*(entry->_string_)))), (int)(0), (int)(entry->stringLength), null, &error))) , error != 0) || ((error = (int)(FT_Stream_Seek(stream, (int)(entry->stringOffset)))) != 0)) || ((error = (int)(FT_Stream_Read(stream, (entry->_string_), (int)(entry->stringLength)))) != 0)) {
	do
	{
		(ft_mem_free(memory, (entry->_string_)));
		(entry->_string_) = null;
	}
	while ((0) != 0);
	entry->stringLength = (ushort)(0);
}
}
aname->platform_id = (ushort)(entry->platformID);
aname->encoding_id = (ushort)(entry->encodingID);
aname->language_id = (ushort)(entry->languageID);
aname->name_id = (ushort)(entry->nameID);
aname->_string_ = entry->_string_;
aname->string_len = (uint)(entry->stringLength);
error = (int)(FT_Err_Ok);}
}

			return (int)(error);
		}

		public static int FT_Get_Sfnt_LangTag(FT_FaceRec_ face, uint langID, FT_SfntLangTag_* alangTag)
{
	int error = (int)(FT_Err_Invalid_Argument);
	if ((((alangTag) != null) && ((face) != null)) && (!!((face).face_flags & (1 << 3))))
	{
		TT_FaceRec_* ttface = (TT_FaceRec_*)(face);
		if (ttface->name_table.format != 1)
			return (int)(FT_Err_Invalid_Table);
		if (((langID) > (0x8000U)) && ((langID - 0x8000U) < (ttface->name_table.numLangTagRecords)))
		{
			TT_LangTagRec_* entry = ttface->name_table.langTags + (langID - 0x8000U);
			if (((entry->stringLength) > (0)) && (entry->_string_ == null))
			{
				FT_MemoryRec_ memory = face.memory;
				FT_StreamRec_ stream = face.stream;
				if (((((entry->_string_) = (ft_mem_realloc(memory, (int)(sizeof((*(entry->_string_)))), (int)(0), (int)(entry->stringLength), null, &error))) , error != 0) || ((error = (int)(FT_Stream_Seek(stream, (int)(entry->stringOffset)))) != 0)) || ((error = (int)(FT_Stream_Read(stream, (entry->_string_), (int)(entry->stringLength)))) != 0)) {
	do
	{
		(ft_mem_free(memory, (entry->_string_)));
		(entry->_string_) = null;
	}
	while ((0) != 0);
	entry->stringLength = (ushort)(0);
}
}
alangTag->_string_ = entry->_string_;
alangTag->string_len = (uint)(entry->stringLength);
error = (int)(FT_Err_Ok);}
}

			return (int)(error);
		}

		public static void FT_Stream_OpenMemory(FT_StreamRec_ stream, byte* _base_, int size)
{
	stream._base_ = _base_;
	stream.size = (int)(size);
	stream.pos = (int)(0);
	stream.cursor = null;
	stream.read = null;
	stream.close = null;
}

public static void FT_Stream_Close(FT_StreamRec_ stream)
{
	if (((stream) != null) && ((stream.close) != null))
		stream.close(stream);
}

public static int FT_Stream_Seek(FT_StreamRec_ stream, int pos)
{
	int error = (int)(FT_Err_Ok);
	if ((stream.read) != null)
	{
		if ((stream.read(stream, (int)(pos), null, (int)(0))) != 0)
		{
			do
			{
			}
			while ((0) != 0);
			error = (int)(FT_Err_Invalid_Stream_Operation);
		}
	}
	else if ((pos) > (stream.size))
	{
		do
		{
		}
		while ((0) != 0);
		error = (int)(FT_Err_Invalid_Stream_Operation);
	}

	if (error == 0)
		stream.pos = (int)(pos);
	return (int)(error);
}

public static int FT_Stream_Skip(FT_StreamRec_ stream, int distance)
{
	if ((distance) < (0))
		return (int)(FT_Err_Invalid_Stream_Operation);
	return (int)(FT_Stream_Seek(stream, (int)(stream.pos + distance)));
}

public static int FT_Stream_Pos(FT_StreamRec_ stream)
{
	return (int)(stream.pos);
}

public static int FT_Stream_Read(FT_StreamRec_ stream, byte* buffer, int count)
{
	return (int)(FT_Stream_ReadAt(stream, (int)(stream.pos), buffer, (int)(count)));
}

public static int FT_Stream_ReadAt(FT_StreamRec_ stream, int pos, byte* buffer, int count)
{
	int error = (int)(FT_Err_Ok);
	int read_bytes = 0;
	if ((pos) >= (stream.size))
	{
		do
		{
		}
		while ((0) != 0);
		return (int)(FT_Err_Invalid_Stream_Operation);
	}

	if ((stream.read) != null)
		read_bytes = (int)(stream.read(stream, (int)(pos), buffer, (int)(count)));
	else
	{
		read_bytes = (int)(stream.size - pos);
		if ((read_bytes) > (count))
			read_bytes = (int)(count);
		CRuntime.memcpy(buffer, stream._base_ + pos, (ulong)(read_bytes));
	}

	stream.pos = (int)(pos + read_bytes);
	if ((read_bytes) < (count))
	{
		do
		{
		}
		while ((0) != 0);
		error = (int)(FT_Err_Invalid_Stream_Operation);
	}

	return (int)(error);
}

public static int FT_Stream_TryRead(FT_StreamRec_ stream, byte* buffer, int count)
{
	int read_bytes = (int)(0);
	if ((stream.pos) >= (stream.size))
		goto Exit;
	if ((stream.read) != null)
		read_bytes = (int)(stream.read(stream, (int)(stream.pos), buffer, (int)(count)));
	else
	{
		read_bytes = (int)(stream.size - stream.pos);
		if ((read_bytes) > (count))
			read_bytes = (int)(count);
		CRuntime.memcpy(buffer, stream._base_ + stream.pos, (ulong)(read_bytes));
	}

	stream.pos += (int)(read_bytes);
Exit:
	;
	return (int)(read_bytes);
}

public static int FT_Stream_ExtractFrame(FT_StreamRec_ stream, int count, byte** pbytes)
{
	int error = 0;
	error = (int)(FT_Stream_EnterFrame(stream, (int)(count)));
	if (error == 0)
	{
		*pbytes = stream.cursor;
		stream.cursor = null;
		stream.limit = null;
	}

	return (int)(error);
}

public static void FT_Stream_ReleaseFrame(FT_StreamRec_ stream, byte** pbytes)
{
	if (((stream) != null) && ((stream.read) != null))
	{
		FT_MemoryRec_ memory = stream.memory;
		do
		{
			(ft_mem_free(memory, (*pbytes)));
			(*pbytes) = null;
		}
		while ((0) != 0);
	}

	*pbytes = null;
}

public static int FT_Stream_EnterFrame(FT_StreamRec_ stream, int count)
{
	int error = (int)(FT_Err_Ok);
	int read_bytes = 0;
	do
	{
	}
	while ((0) != 0);
	do
	{
	}
	while ((0) != 0);
	if ((stream.read) != null)
	{
		FT_MemoryRec_ memory = stream.memory;
		if ((count) > (stream.size))
		{
			do
			{
			}
			while ((0) != 0);
			error = (int)(FT_Err_Invalid_Stream_Operation);
			goto Exit;
		}
		if ((((stream._base_) = (ft_mem_qalloc(memory, (int)(count), &error))), error != 0))
			goto Exit;
		read_bytes = (int)(stream.read(stream, (int)(stream.pos), stream._base_, (int)(count)));
		if ((read_bytes) < (count))
		{
			do
			{
			}
			while ((0) != 0);
			do
			{
				(ft_mem_free(memory, (stream._base_)));
				(stream._base_) = null;
			}
			while ((0) != 0);
			error = (int)(FT_Err_Invalid_Stream_Operation);
		}
		stream.cursor = stream._base_;
		stream.limit = ((stream.cursor) ? (stream.cursor) + (count) : null);
		stream.pos += (int)(read_bytes);
	}
	else
	{
		if (((stream.pos) >= (stream.size)) || ((stream.size - stream.pos) < (count)))
		{
			do
			{
			}
			while ((0) != 0);
			error = (int)(FT_Err_Invalid_Stream_Operation);
			goto Exit;
		}
		stream.cursor = stream._base_ + stream.pos;
		stream.limit = stream.cursor + count;
		stream.pos += (int)(count);
	}

Exit:
	;
	return (int)(error);
}

public static void FT_Stream_ExitFrame(FT_StreamRec_ stream)
{
	do
	{
	}
	while ((0) != 0);
	do
	{
	}
	while ((0) != 0);
	if ((stream.read) != null)
	{
		FT_MemoryRec_ memory = stream.memory;
		do
		{
			(ft_mem_free(memory, (stream._base_)));
			(stream._base_) = null;
		}
		while ((0) != 0);
	}

	stream.cursor = null;
	stream.limit = null;
}

public static sbyte FT_Stream_GetChar(FT_StreamRec_ stream)
{
	sbyte result = 0;
	do
	{
	}
	while ((0) != 0);
	result = (sbyte)(0);
	if ((stream.cursor) < (stream.limit))
		result = ((sbyte)(*stream.cursor++));
	return (sbyte)(result);
}

public static ushort FT_Stream_GetUShort(FT_StreamRec_ stream)
{
	byte* p;
	ushort result = 0;
	do
	{
	}
	while ((0) != 0);
	result = (ushort)(0);
	p = stream.cursor;
	if ((p + 1) < (stream.limit))
		result = (ushort)(p += 2, ((ushort)((((ushort)((p - 2)[(0)])) << (8)) | (((ushort)((p - 2)[(1)])) << (0)))));
	stream.cursor = p;
	return (ushort)(result);
}

public static ushort FT_Stream_GetUShortLE(FT_StreamRec_ stream)
{
	byte* p;
	ushort result = 0;
	do
	{
	}
	while ((0) != 0);
	result = (ushort)(0);
	p = stream.cursor;
	if ((p + 1) < (stream.limit))
		result = (ushort)(p += 2, ((ushort)((((ushort)((p - 2)[(1)])) << (8)) | (((ushort)((p - 2)[(0)])) << (0)))));
	stream.cursor = p;
	return (ushort)(result);
}

public static int FT_Stream_GetUOffset(FT_StreamRec_ stream)
{
	byte* p;
	int result = 0;
	do
	{
	}
	while ((0) != 0);
	result = (int)(0);
	p = stream.cursor;
	if ((p + 2) < (stream.limit))
		result = ((int)(p += 3, ((((uint)((p - 3)[(0)])) << (16)) | (((uint)((p - 3)[(1)])) << (8)) | (((uint)((p - 3)[(2)])) << (0)))));
	stream.cursor = p;
	return (int)(result);
}

public static int FT_Stream_GetULong(FT_StreamRec_ stream)
{
	byte* p;
	int result = 0;
	do
	{
	}
	while ((0) != 0);
	result = (int)(0);
	p = stream.cursor;
	if ((p + 3) < (stream.limit))
		result = ((int)(p += 4, ((((uint)((p - 4)[(0)])) << (24)) | (((uint)((p - 4)[(1)])) << (16)) | (((uint)((p - 4)[(2)])) << (8)) | (((uint)((p - 4)[(3)])) << (0)))));
	stream.cursor = p;
	return (int)(result);
}

public static int FT_Stream_GetULongLE(FT_StreamRec_ stream)
{
	byte* p;
	int result = 0;
	do
	{
	}
	while ((0) != 0);
	result = (int)(0);
	p = stream.cursor;
	if ((p + 3) < (stream.limit))
		result = ((int)(p += 4, ((((uint)((p - 4)[(3)])) << (24)) | (((uint)((p - 4)[(2)])) << (16)) | (((uint)((p - 4)[(1)])) << (8)) | (((uint)((p - 4)[(0)])) << (0)))));
	stream.cursor = p;
	return (int)(result);
}

public static sbyte FT_Stream_ReadChar(FT_StreamRec_ stream, int* error)
{
	byte result = (byte)(0);
	do
	{
	}
	while ((0) != 0);
	*error = (int)(FT_Err_Ok);
	if ((stream.read) != null)
	{
		if (stream.read(stream, (int)(stream.pos), &result, (int)(1)) != 1)
			goto Fail;
	}
	else
	{
		if ((stream.pos) < (stream.size))
			result = (byte)(stream._base_[stream.pos]);
		else
			goto Fail;
	}

	stream.pos++;
	return (sbyte)(result);
Fail:
	;
	*error = (int)(FT_Err_Invalid_Stream_Operation);
	do
	{
	}
	while ((0) != 0);
	return (sbyte)(0);
}

public static ushort FT_Stream_ReadUShort(FT_StreamRec_ stream, int* error)
{
	byte* reads = stackalloc byte[2];
	byte* p = null;
	ushort result = (ushort)(0);
	do
	{
	}
	while ((0) != 0);
	*error = (int)(FT_Err_Ok);
	if ((stream.pos + 1) < (stream.size))
	{
		if ((stream.read) != null)
		{
			if (stream.read(stream, (int)(stream.pos), reads, (int)(2)) != 2)
				goto Fail;
			p = reads;
		}
		else
			p = stream._base_ + stream.pos;
		if ((p) != null)
			result = (ushort)(p += 2, ((ushort)((((ushort)((p - 2)[(0)])) << (8)) | (((ushort)((p - 2)[(1)])) << (0)))));
	}
	else
		goto Fail;
	stream.pos += (int)(2);
	return (ushort)(result);
Fail:
	;
	*error = (int)(FT_Err_Invalid_Stream_Operation);
	do
	{
	}
	while ((0) != 0);
	return (ushort)(0);
}

public static ushort FT_Stream_ReadUShortLE(FT_StreamRec_ stream, int* error)
{
	byte* reads = stackalloc byte[2];
	byte* p = null;
	ushort result = (ushort)(0);
	do
	{
	}
	while ((0) != 0);
	*error = (int)(FT_Err_Ok);
	if ((stream.pos + 1) < (stream.size))
	{
		if ((stream.read) != null)
		{
			if (stream.read(stream, (int)(stream.pos), reads, (int)(2)) != 2)
				goto Fail;
			p = reads;
		}
		else
			p = stream._base_ + stream.pos;
		if ((p) != null)
			result = (ushort)(p += 2, ((ushort)((((ushort)((p - 2)[(1)])) << (8)) | (((ushort)((p - 2)[(0)])) << (0)))));
	}
	else
		goto Fail;
	stream.pos += (int)(2);
	return (ushort)(result);
Fail:
	;
	*error = (int)(FT_Err_Invalid_Stream_Operation);
	do
	{
	}
	while ((0) != 0);
	return (ushort)(0);
}

public static int FT_Stream_ReadUOffset(FT_StreamRec_ stream, int* error)
{
	byte* reads = stackalloc byte[3];
	byte* p = null;
	int result = (int)(0);
	do
	{
	}
	while ((0) != 0);
	*error = (int)(FT_Err_Ok);
	if ((stream.pos + 2) < (stream.size))
	{
		if ((stream.read) != null)
		{
			if (stream.read(stream, (int)(stream.pos), reads, (int)(3)) != 3)
				goto Fail;
			p = reads;
		}
		else
			p = stream._base_ + stream.pos;
		if ((p) != null)
			result = ((int)(p += 3, ((((uint)((p - 3)[(0)])) << (16)) | (((uint)((p - 3)[(1)])) << (8)) | (((uint)((p - 3)[(2)])) << (0)))));
	}
	else
		goto Fail;
	stream.pos += (int)(3);
	return (int)(result);
Fail:
	;
	*error = (int)(FT_Err_Invalid_Stream_Operation);
	do
	{
	}
	while ((0) != 0);
	return (int)(0);
}

public static int FT_Stream_ReadULong(FT_StreamRec_ stream, int* error)
{
	byte* reads = stackalloc byte[4];
	byte* p = null;
	int result = (int)(0);
	do
	{
	}
	while ((0) != 0);
	*error = (int)(FT_Err_Ok);
	if ((stream.pos + 3) < (stream.size))
	{
		if ((stream.read) != null)
		{
			if (stream.read(stream, (int)(stream.pos), reads, (int)(4)) != 4)
				goto Fail;
			p = reads;
		}
		else
			p = stream._base_ + stream.pos;
		if ((p) != null)
			result = ((int)(p += 4, ((((uint)((p - 4)[(0)])) << (24)) | (((uint)((p - 4)[(1)])) << (16)) | (((uint)((p - 4)[(2)])) << (8)) | (((uint)((p - 4)[(3)])) << (0)))));
	}
	else
		goto Fail;
	stream.pos += (int)(4);
	return (int)(result);
Fail:
	;
	*error = (int)(FT_Err_Invalid_Stream_Operation);
	do
	{
	}
	while ((0) != 0);
	return (int)(0);
}

public static int FT_Stream_ReadULongLE(FT_StreamRec_ stream, int* error)
{
	byte* reads = stackalloc byte[4];
	byte* p = null;
	int result = (int)(0);
	do
	{
	}
	while ((0) != 0);
	*error = (int)(FT_Err_Ok);
	if ((stream.pos + 3) < (stream.size))
	{
		if ((stream.read) != null)
		{
			if (stream.read(stream, (int)(stream.pos), reads, (int)(4)) != 4)
				goto Fail;
			p = reads;
		}
		else
			p = stream._base_ + stream.pos;
		if ((p) != null)
			result = ((int)(p += 4, ((((uint)((p - 4)[(3)])) << (24)) | (((uint)((p - 4)[(2)])) << (16)) | (((uint)((p - 4)[(1)])) << (8)) | (((uint)((p - 4)[(0)])) << (0)))));
	}
	else
		goto Fail;
	stream.pos += (int)(4);
	return (int)(result);
Fail:
	;
	*error = (int)(FT_Err_Invalid_Stream_Operation);
	do
	{
	}
	while ((0) != 0);
	return (int)(0);
}

public static int FT_Stream_ReadFields(FT_StreamRec_ stream, FT_Frame_Field_* fields, void* structure)
{
	int error = 0;
	byte frame_accessed = (byte)(0);
	byte* cursor;
	if (fields == null)
		return (int)(FT_Err_Invalid_Argument);
	if (stream == null)
		return (int)(FT_Err_Invalid_Stream_Handle);
	cursor = stream.cursor;
	error = (int)(FT_Err_Ok);
	do
	{
		int value = 0;
		int sign_shift = 0;
		byte* p;
		switch (fields->value)
		{
			case ft_frame_start:
				error = (int)(FT_Stream_EnterFrame(stream, (int)(fields->offset)));
				if ((error) != 0)
					goto Exit;
				frame_accessed = (byte)(1);
				cursor = stream.cursor;
				fields++;
				continue;
			case ft_frame_bytes:
			case ft_frame_skip:
			{
				uint len = (uint)(fields->size);
				if ((cursor + len) > (stream.limit))
				{
					error = (int)(FT_Err_Invalid_Stream_Operation);
					goto Exit;
				}
				if ((fields->value) == (ft_frame_bytes))
				{
					p = (byte*)(structure) + fields->offset;
					CRuntime.memcpy(p, cursor, (ulong)(len));
				}
				cursor += len;
				fields++;
				continue;
			}
			case ft_frame_byte:
			case ft_frame_schar:
				value = (int)(*cursor++);
				sign_shift = (int)(24);
				break;
			case ft_frame_short_be:
			case ft_frame_ushort_be:
				value = (int)(cursor += 2, ((ushort)((((ushort)((cursor - 2)[(0)])) << (8)) | (((ushort)((cursor - 2)[(1)])) << (0)))));
				sign_shift = (int)(16);
				break;
			case ft_frame_short_le:
			case ft_frame_ushort_le:
				value = (int)(cursor += 2, ((ushort)((((ushort)((cursor - 2)[(1)])) << (8)) | (((ushort)((cursor - 2)[(0)])) << (0)))));
				sign_shift = (int)(16);
				break;
			case ft_frame_long_be:
			case ft_frame_ulong_be:
				value = ((int)(cursor += 4, ((((uint)((cursor - 4)[(0)])) << (24)) | (((uint)((cursor - 4)[(1)])) << (16)) | (((uint)((cursor - 4)[(2)])) << (8)) | (((uint)((cursor - 4)[(3)])) << (0)))));
				sign_shift = (int)(0);
				break;
			case ft_frame_long_le:
			case ft_frame_ulong_le:
				value = ((int)(cursor += 4, ((((uint)((cursor - 4)[(3)])) << (24)) | (((uint)((cursor - 4)[(2)])) << (16)) | (((uint)((cursor - 4)[(1)])) << (8)) | (((uint)((cursor - 4)[(0)])) << (0)))));
				sign_shift = (int)(0);
				break;
			case ft_frame_off3_be:
			case ft_frame_uoff3_be:
				value = ((int)(cursor += 3, ((((uint)((cursor - 3)[(0)])) << (16)) | (((uint)((cursor - 3)[(1)])) << (8)) | (((uint)((cursor - 3)[(2)])) << (0)))));
				sign_shift = (int)(8);
				break;
			case ft_frame_off3_le:
			case ft_frame_uoff3_le:
				value = ((int)(cursor += 3, ((((uint)((cursor - 3)[(2)])) << (16)) | (((uint)((cursor - 3)[(1)])) << (8)) | (((uint)((cursor - 3)[(0)])) << (0)))));
				sign_shift = (int)(8);
				break;
			default:
				stream.cursor = cursor;
				goto Exit;
		}
		if ((fields->value & 1) != 0)
			value = (int)((value << sign_shift) >> sign_shift);
		p = (byte*)(structure) + fields->offset;
		switch (fields->size)
		{
			case (8 / 8):
				*p = ((byte)(value));
				break;
			case (16 / 8):
				*(ushort*)(p) = ((ushort)(value));
				break;
			case (32 / 8):
				*(uint*)(p) = ((uint)(value));
				break;
			default:
				*(int*)(p) = (int)(value);
		}
		fields++;
	}
	while ((1) != 0);
Exit:
	;
	if ((frame_accessed) != 0)
		FT_Stream_ExitFrame(stream);
	return (int)(error);
}

public static int ft_trig_downscale(int val)
{
	int s = (int)(1);
	if ((val) < (0))
	{
		val = (int)(-val);
		s = (int)(-1);
	}

	val = ((int)(((ulong)(val) * 0xDBD95B16U + 0x40000000U) >> 32));
	return (int)((s) < (0) ? -val : val);
}

public static int ft_trig_prenorm(FT_Vector_* vec)
{
	int x = 0;
	int y = 0;
	int shift = 0;
	x = (int)(vec->x);
	y = (int)(vec->y);
	shift = (int)(FT_MSB_i386((uint)(((x) < (0) ? -(x) : (x)) | ((y) < (0) ? -(y) : (y)))));
	if (shift <= 29)
	{
		shift = (int)(29 - shift);
		vec->x = (int)(x << shift);
		vec->y = (int)(y << shift);
	}
	else
	{
		shift -= (int)(29);
		vec->x = (int)(x >> shift);
		vec->y = (int)(y >> shift);
		shift = (int)(-shift);
	}

	return (int)(shift);
}

public static void ft_trig_pseudo_rotate(FT_Vector_* vec, int theta)
{
	int i = 0;
	int x = 0;
	int y = 0;
	int xtemp = 0;
	int b = 0;
	int* arctanptr;
	x = (int)(vec->x);
	y = (int)(vec->y);
	while ((theta) < (-((180 << 16) / 4)))
	{
		xtemp = (int)(y);
		y = (int)(-x);
		x = (int)(xtemp);
		theta += (int)((180 << 16) / 2);
	}
	while ((theta) > ((180 << 16) / 4))
	{
		xtemp = (int)(-y);
		y = (int)(x);
		x = (int)(xtemp);
		theta -= (int)((180 << 16) / 2);
	}
	arctanptr = ft_trig_arctan_table;
	for (i = (int)(1), b = (int)(1); (i) < (23); b <<= 1, i++)
	{
		if ((theta) < (0))
		{
			xtemp = (int)(x + ((y + b) >> i));
			y = (int)(y - ((x + b) >> i));
			x = (int)(xtemp);
			theta += (int)(*arctanptr++);
		}
		else
		{
			xtemp = (int)(x - ((y + b) >> i));
			y = (int)(y + ((x + b) >> i));
			x = (int)(xtemp);
			theta -= (int)(*arctanptr++);
		}
	}
	vec->x = (int)(x);
	vec->y = (int)(y);
}

public static void ft_trig_pseudo_polarize(FT_Vector_* vec)
{
	int theta = 0;
	int i = 0;
	int x = 0;
	int y = 0;
	int xtemp = 0;
	int b = 0;
	int* arctanptr;
	x = (int)(vec->x);
	y = (int)(vec->y);
	if ((y) > (x))
	{
		if ((y) > (-x))
		{
			theta = (int)((180 << 16) / 2);
			xtemp = (int)(y);
			y = (int)(-x);
			x = (int)(xtemp);
		}
		else
		{
			theta = (int)((y) > (0) ? (180 << 16) : -(180 << 16));
			x = (int)(-x);
			y = (int)(-y);
		}
	}
	else
	{
		if ((y) < (-x))
		{
			theta = (int)(-((180 << 16) / 2));
			xtemp = (int)(-y);
			y = (int)(x);
			x = (int)(xtemp);
		}
		else
		{
			theta = (int)(0);
		}
	}

	arctanptr = ft_trig_arctan_table;
	for (i = (int)(1), b = (int)(1); (i) < (23); b <<= 1, i++)
	{
		if ((y) > (0))
		{
			xtemp = (int)(x + ((y + b) >> i));
			y = (int)(y - ((x + b) >> i));
			x = (int)(xtemp);
			theta += (int)(*arctanptr++);
		}
		else
		{
			xtemp = (int)(x - ((y + b) >> i));
			y = (int)(y + ((x + b) >> i));
			x = (int)(xtemp);
			theta -= (int)(*arctanptr++);
		}
	}
	if ((theta) >= (0))
		theta = (int)(((theta) + (16) / 2) & ~((16) - 1));
	else
		theta = (int)(-(((-theta) + (16) / 2) & ~((16) - 1)));
	vec->x = (int)(x);
	vec->y = (int)(theta);
}

public static int FT_Cos(int angle)
{
	FT_Vector_ v = new FT_Vector_();
	FT_Vector_Unit(&v, (int)(angle));
	return (int)(v.x);
}

public static int FT_Sin(int angle)
{
	FT_Vector_ v = new FT_Vector_();
	FT_Vector_Unit(&v, (int)(angle));
	return (int)(v.y);
}

public static int FT_Tan(int angle)
{
	FT_Vector_ v = (FT_Vector_)(new FT_Vector_ { x = 1 << 24, y = 0 });
	ft_trig_pseudo_rotate(&v, (int)(angle));
	return (int)(FT_DivFix((int)(v.y), (int)(v.x)));
}

public static int FT_Atan2(int dx, int dy)
{
	FT_Vector_ v = new FT_Vector_();
	if (((dx) == (0)) && ((dy) == (0)))
		return (int)(0);
	v.x = (int)(dx);
	v.y = (int)(dy);
	ft_trig_prenorm(&v);
	ft_trig_pseudo_polarize(&v);
	return (int)(v.y);
}

public static void FT_Vector_Unit(FT_Vector_* vec, int angle)
{
	if (vec == null)
		return;
	vec->x = (int)(0xDBD95B16U >> 8);
	vec->y = (int)(0);
	ft_trig_pseudo_rotate(vec, (int)(angle));
	vec->x = (int)((vec->x + 0x80) >> 8);
	vec->y = (int)((vec->y + 0x80) >> 8);
}

public static void FT_Vector_Rotate(FT_Vector_* vec, int angle)
{
	int shift = 0;
	FT_Vector_ v = new FT_Vector_();
	if ((vec == null) || (angle == 0))
		return;
	v = (FT_Vector_)(*vec);
	if (((v.x) == (0)) && ((v.y) == (0)))
		return;
	shift = (int)(ft_trig_prenorm(&v));
	ft_trig_pseudo_rotate(&v, (int)(angle));
	v.x = (int)(ft_trig_downscale((int)(v.x)));
	v.y = (int)(ft_trig_downscale((int)(v.y)));
	if ((shift) > (0))
	{
		int half = (int)(1 << (shift - 1));
		vec->x = (int)((v.x + half - ((v.x) < (0))) >> shift);
		vec->y = (int)((v.y + half - ((v.y) < (0))) >> shift);
	}
	else
	{
		shift = (int)(-shift);
		vec->x = (int)(v.x << shift);
		vec->y = (int)(v.y << shift);
	}

}

public static int FT_Vector_Length(FT_Vector_* vec)
{
	int shift = 0;
	FT_Vector_ v = new FT_Vector_();
	if (vec == null)
		return (int)(0);
	v = (FT_Vector_)(*vec);
	if ((v.x) == (0))
	{
		return (int)((v.y) < (0) ? -(v.y) : (v.y));
	}
	else if ((v.y) == (0))
	{
		return (int)((v.x) < (0) ? -(v.x) : (v.x));
	}

	shift = (int)(ft_trig_prenorm(&v));
	ft_trig_pseudo_polarize(&v);
	v.x = (int)(ft_trig_downscale((int)(v.x)));
	if ((shift) > (0))
		return (int)((v.x + (1 << (shift - 1))) >> shift);
	return (int)((uint)(v.x) << -shift);
}

public static void FT_Vector_Polarize(FT_Vector_* vec, int* length, int* angle)
{
	int shift = 0;
	FT_Vector_ v = new FT_Vector_();
	if (((vec == null) || (length == null)) || (angle == null))
		return;
	v = (FT_Vector_)(*vec);
	if (((v.x) == (0)) && ((v.y) == (0)))
		return;
	shift = (int)(ft_trig_prenorm(&v));
	ft_trig_pseudo_polarize(&v);
	v.x = (int)(ft_trig_downscale((int)(v.x)));
	*length = (int)((shift) >= (0) ? (v.x >> shift) : (int)((uint)(v.x) << -shift));
	*angle = (int)(v.y);
}

public static void FT_Vector_From_Polar(FT_Vector_* vec, int length, int angle)
{
	if (vec == null)
		return;
	vec->x = (int)(length);
	vec->y = (int)(0);
	FT_Vector_Rotate(vec, (int)(angle));
}

public static int FT_Angle_Diff(int angle1, int angle2)
{
	int delta = (int)(angle2 - angle1);
	while (delta <= -(180 << 16))
	{ delta += (int)((180 << 16) * 2); }
	while ((delta) > (180 << 16))
	{ delta -= (int)((180 << 16) * 2); }
	return (int)(delta);
}

public static void* ft_mem_alloc(FT_MemoryRec_ memory, int size, int* p_error)
{
	int error = 0;
	void* block = ft_mem_qalloc(memory, (int)(size), &error);
	if (((error == 0) && ((block) != null)) && ((size) > (0)))
		CRuntime.memset(block, (int)(0), (ulong)(size));
	*p_error = (int)(error);
	return block;
}

public static void* ft_mem_qalloc(FT_MemoryRec_ memory, int size, int* p_error)
{
	int error = (int)(FT_Err_Ok);
	void* block = null;
	if ((size) > (0))
	{
		block = memory.alloc(memory, (int)(size));
		if (block == null)
			error = (int)(FT_Err_Out_Of_Memory);
	}
	else if ((size) < (0))
	{
		error = (int)(FT_Err_Invalid_Argument);
	}

	*p_error = (int)(error);
	return block;
}

public static void* ft_mem_realloc(FT_MemoryRec_ memory, int item_size, int cur_count, int new_count, void* block, int* p_error)
{
	int error = (int)(FT_Err_Ok);
	block = ft_mem_qrealloc(memory, (int)(item_size), (int)(cur_count), (int)(new_count), block, &error);
	if (((error == 0) && ((block) != null)) && ((new_count) > (cur_count)))
		CRuntime.memset((sbyte*)(block) + cur_count * item_size, (int)(0), (ulong)((new_count - cur_count) * item_size));
	*p_error = (int)(error);
	return block;
}

public static void* ft_mem_qrealloc(FT_MemoryRec_ memory, int item_size, int cur_count, int new_count, void* block, int* p_error)
{
	int error = (int)(FT_Err_Ok);
	if ((((cur_count) < (0)) || ((new_count) < (0))) || ((item_size) < (0)))
	{
		error = (int)(FT_Err_Invalid_Argument);
	}
	else if (((new_count) == (0)) || ((item_size) == (0)))
	{
		ft_mem_free(memory, block);
		block = null;
	}
	else if ((new_count) > (2147483647 / item_size))
	{
		error = (int)(FT_Err_Array_Too_Large);
	}
	else if ((cur_count) == (0))
	{
		do
		{
		}
		while ((0) != 0);
		block = memory.alloc(memory, (int)(new_count * item_size));
		if ((block) == null)
			error = (int)(FT_Err_Out_Of_Memory);
	}
	else
	{
		void* block2;
		int cur_size = (int)(cur_count * item_size);
		int new_size = (int)(new_count * item_size);
		block2 = memory.realloc(memory, (int)(cur_size), (int)(new_size), block);
		if (block2 == null)
			error = (int)(FT_Err_Out_Of_Memory);
		else
			block = block2;
	}

	*p_error = (int)(error);
	return block;
}

public static void ft_mem_free(FT_MemoryRec_ memory, void* P)
{
	if ((P) != null)
		memory.free(memory, P);
}

public static void* ft_mem_dup(FT_MemoryRec_ memory, void* address, int size, int* p_error)
{
	int error = 0;
	void* p = ft_mem_qalloc(memory, (int)(size), &error);
	if (((error == 0) && ((address) != null)) && ((size) > (0)))
		CRuntime.memcpy(p, address, (ulong)(size));
	*p_error = (int)(error);
	return p;
}

public static void* ft_mem_strdup(FT_MemoryRec_ memory, sbyte* str, int* p_error)
{
	int len = (int)(str ? (int)(CRuntime.strlen(str)) + 1 : 0);
	return ft_mem_dup(memory, str, (int)(len), p_error);
}

public static int ft_mem_strcpyn(sbyte* dst, sbyte* src, int size)
{
	while (((size) > (1)) && (*src != 0))
	{
		*dst++ = (sbyte)(*src++);
		size--;
	}
	*dst = (sbyte)(0);
	return (int)(*src != 0);
}

public static FT_ListNodeRec_* FT_List_Find(FT_ListRec_* list, void* data)
{
	FT_ListNodeRec_* cur;
	if (list == null)
		return null;
	cur = list->head;
	while ((cur) != null)
	{
		if ((cur->data) == (data))
			return cur;
		cur = cur->next;
	}
	return null;
}

public static void FT_List_Add(FT_ListRec_* list, FT_ListNodeRec_* node)
{
	FT_ListNodeRec_* before;
	if ((list == null) || (node == null))
		return;
	before = list->tail;
	node->next = null;
	node->prev = before;
	if ((before) != null)
		before->next = node;
	else
		list->head = node;
	list->tail = node;
}

public static void FT_List_Insert(FT_ListRec_* list, FT_ListNodeRec_* node)
{
	FT_ListNodeRec_* after;
	if ((list == null) || (node == null))
		return;
	after = list->head;
	node->next = after;
	node->prev = null;
	if (after == null)
		list->tail = node;
	else
		after->prev = node;
	list->head = node;
}

public static void FT_List_Remove(FT_ListRec_* list, FT_ListNodeRec_* node)
{
	FT_ListNodeRec_* before;
	FT_ListNodeRec_* after;
	if ((list == null) || (node == null))
		return;
	before = node->prev;
	after = node->next;
	if ((before) != null)
		before->next = after;
	else
		list->head = after;
	if ((after) != null)
		after->prev = before;
	else
		list->tail = before;
}

public static void FT_List_Up(FT_ListRec_* list, FT_ListNodeRec_* node)
{
	FT_ListNodeRec_* before;
	FT_ListNodeRec_* after;
	if ((list == null) || (node == null))
		return;
	before = node->prev;
	after = node->next;
	if (before == null)
		return;
	before->next = after;
	if ((after) != null)
		after->prev = before;
	else
		list->tail = before;
	node->prev = null;
	node->next = list->head;
	list->head->prev = node;
	list->head = node;
}

public static int FT_List_Iterate(FT_ListRec_* list, int (FT_ListNodeRec_*, void*) * iterator, void* user)
{
	FT_ListNodeRec_* cur;
	int error = (int)(FT_Err_Ok);
	if ((list == null) || (iterator == null))
		return (int)(FT_Err_Invalid_Argument);
	cur = list->head;
	while ((cur) != null)
	{
		FT_ListNodeRec_* next = cur->next;
		error = (int)(iterator(cur, user));
		if ((error) != 0)
			break;
		cur = next;
	}
	return (int)(error);
}

public static void FT_List_Finalize(FT_ListRec_* list, void (FT_MemoryRec_*, void*, void*) * destroy, FT_MemoryRec_ memory, void* user)
{
	FT_ListNodeRec_* cur;
	if ((list == null) || (memory == null))
		return;
	cur = list->head;
	while ((cur) != null)
	{
		FT_ListNodeRec_* next = cur->next;
		void* data = cur->data;
		if ((destroy) != null)
			destroy(memory, data, user);
		do
		{
			(ft_mem_free(memory, (cur)));
			(cur) = null;
		}
		while ((0) != 0);
		cur = next;
	}
	list->head = null;
	list->tail = null;
}

}
}